/**
 * @file imu_health_monitor.c
 * @brief Safety-critical IMU Health Monitor for Ardupilot flight controllers. Monitors accelerometer and gyroscope sensors for anomalies, performs cross-validation between redundant sensors, and triggers failsafe conditions when sensor health degrades below acceptable thresholds.
 * 
 * @details This file is automatically generated by STUNIR for safety-critical
 *          avionics systems. It conforms to DO-178C DAL_A requirements.
 * 
 * @certification
 *   - Standard: DO-178C
 *   - Design Assurance Level: DAL_A
 *   - Catastrophic Failure: True
 * 
 * @target
 *   - Architecture: ARM_Cortex_M4
 *   - Processor: STM32F427
 *   - Clock: 168 MHz
 * 
 * @timing
 *   - Max Execution Time: 100 us
 *   - Update Rate: 400 Hz
 *   - Deadline: 2500 us
 * 
 * @safety_properties
 *   - No Dynamic Allocation: True
 *   - No Recursion: True
 *   - Bounded Loops: True
 *   - Integer Overflow Checks: True
 *   - Array Bounds Checks: True
 * 
 * @version 1.0.0
 * @date 2026-01-31T00:06:57Z
 * @generator STUNIR v1.0.0 (Ada SPARK Pipeline)
 * 
 * @warning DO NOT MODIFY - This file is auto-generated.
 *          Changes will be lost on regeneration.
 * 
 * @copyright Copyright (c) 2026 STUNIR Project
 * @license MIT
 */


#ifndef IMU_HEALTH_MONITOR_H
#define IMU_HEALTH_MONITOR_H

/* MISRA C 2012 Rule 20.1: Standard library includes */
#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <limits.h>

/* Compiler compatibility */
#ifdef __cplusplus
extern "C" {
#endif

/* ============================================================ */
/*                         CONSTANTS                            */
/* ============================================================ */

/** @brief Maximum number of redundant IMU sensors */
#define MAX_IMU_COUNT ((uint8_t)3)
/** @brief Accelerometer variance threshold (mm/s^2)^2 scaled x1000 */
#define ACCEL_HEALTHY_THRESHOLD ((int32_t)100)
/** @brief Gyroscope variance threshold (mrad/s)^2 scaled x1000 */
#define GYRO_HEALTHY_THRESHOLD ((int32_t)50)
/** @brief Maximum acceptable difference between redundant sensors */
#define CROSS_VALIDATION_TOLERANCE ((int32_t)200)
/** @brief Number of samples in health history buffer */
#define HEALTH_HISTORY_SIZE ((uint8_t)8)
/** @brief Minimum healthy samples required in history */
#define MIN_HEALTHY_SAMPLES ((uint8_t)6)
/** @brief Consecutive failures before failsafe activation */
#define FAILSAFE_TRIGGER_COUNT ((uint8_t)3)
/** @brief Expected gravity magnitude (mm/s^2) */
#define GRAVITY_MAGNITUDE ((int32_t)9810)
/** @brief Acceptable gravity deviation (mm/s^2) */
#define GRAVITY_TOLERANCE ((int32_t)500)

/* ============================================================ */
/*                      TYPE DEFINITIONS                        */
/* ============================================================ */

/** @brief IMU_Status enumeration */
typedef enum {
    IMU_STATUS_HEALTHY = 0,
    IMU_STATUS_DEGRADED = 1,
    IMU_STATUS_FAILED = 2,
    IMU_STATUS_UNCALIBRATED = 3,
    IMU_STATUS_NOT_PRESENT = 4
} IMU_Status;

/** @brief Failsafe_Action enumeration */
typedef enum {
    FAILSAFE_ACTION_NONE = 0,
    FAILSAFE_ACTION_WARN = 1,
    FAILSAFE_ACTION_SWITCH_IMU = 2,
    FAILSAFE_ACTION_LAND_IMMEDIATELY = 3,
    FAILSAFE_ACTION_TERMINATE = 4
} Failsafe_Action;

/** @brief Axis enumeration */
typedef enum {
    AXIS_X = 0,
    AXIS_Y = 1,
    AXIS_Z = 2
} Axis;

/** @brief Vector3_I32 structure */
typedef struct {
    int32_t x;
    int32_t y;
    int32_t z;
} Vector3_I32;

/** @brief IMU_Reading structure */
typedef struct {
    Vector3_I32 accel;
    Vector3_I32 gyro;
    uint32_t timestamp_us;
    bool valid;
} IMU_Reading;

/** @brief IMU_Health_State structure */
typedef struct {
    IMU_Status status;
    int32_t accel_variance;
    int32_t gyro_variance;
    uint8_t consecutive_failures;
    uint8_t health_history[8];
    uint8_t history_index;
    uint32_t last_update_us;
} IMU_Health_State;

/** @brief Monitor_State structure */
typedef struct {
    IMU_Health_State imu_health[3];
    uint8_t primary_imu;
    uint8_t active_imu_count;
    bool system_healthy;
    bool failsafe_active;
    Failsafe_Action pending_action;
    uint32_t total_cycles;
    uint32_t error_count;
} Monitor_State;

/** @brief Diagnostic_Report structure */
typedef struct {
    uint8_t imu_index;
    IMU_Status status;
    int32_t accel_magnitude;
    int32_t gyro_magnitude;
    int32_t deviation_from_primary;
    uint32_t uptime_us;
} Diagnostic_Report;


/* ============================================================ */
/*                   FUNCTION DECLARATIONS                      */
/* ============================================================ */

/**
 * @brief Initialize IMU health monitor state. Must be called once before first update.
 * @param[out] state Parameter
 * @return int32_t Return value
 * @timing WCET: 15 us
 * @pre state != NULL
 * @post state->primary_imu == 0
 * @post state->active_imu_count == 0
 * @post state->system_healthy == false
 * @post state->failsafe_active == false
 */
int32_t imu_monitor_init(Monitor_State* state);

/**
 * @brief Compute squared magnitude of 3D vector. Uses fixed-point to avoid sqrt.
 * @param[in] vec Parameter
 * @return int32_t Return value
 * @timing WCET: 5 us
 * @pre vec != NULL
 * @post result >= 0
 */
int32_t compute_magnitude_squared(const Vector3_I32* vec);

/**
 * @brief Validate accelerometer reading against gravity check and range limits.
 * @param[in] reading Parameter
 * @return bool Return value
 * @timing WCET: 8 us
 * @pre reading != NULL
 */
bool validate_accel_reading(const IMU_Reading* reading);

/**
 * @brief Validate gyroscope reading against bias and noise limits.
 * @param[in] reading Parameter
 * @return bool Return value
 * @timing WCET: 6 us
 * @pre reading != NULL
 */
bool validate_gyro_reading(const IMU_Reading* reading);

/**
 * @brief Cross-validate readings between two IMU sensors.
 * @param[in] reading1 Parameter
 * @param[in] reading2 Parameter
 * @return int32_t Return value
 * @timing WCET: 12 us
 * @pre reading1 != NULL
 * @pre reading2 != NULL
 * @post result >= 0
 */
int32_t cross_validate_imus(const IMU_Reading* reading1, const IMU_Reading* reading2);

/**
 * @brief Update circular health history buffer for an IMU.
 * @param[inout] health Parameter
 * @param[in] healthy Parameter
 * @timing WCET: 4 us
 * @pre health != NULL
 */
void update_health_history(IMU_Health_State* health, bool healthy);

/**
 * @brief Count healthy samples in history buffer.
 * @param[in] health Parameter
 * @return uint8_t Return value
 * @timing WCET: 5 us
 * @pre health != NULL
 * @post result <= HEALTH_HISTORY_SIZE
 */
uint8_t count_healthy_samples(const IMU_Health_State* health);

/**
 * @brief Determine overall IMU status based on health metrics.
 * @param[in] health Parameter
 * @return IMU_Status Return value
 * @timing WCET: 8 us
 * @pre health != NULL
 */
IMU_Status determine_imu_status(const IMU_Health_State* health);

/**
 * @brief Select best available IMU as primary sensor.
 * @param[inout] state Parameter
 * @return uint8_t Return value
 * @timing WCET: 10 us
 * @pre state != NULL
 * @post result < MAX_IMU_COUNT || result == 255
 */
uint8_t select_primary_imu(Monitor_State* state);

/**
 * @brief Determine appropriate failsafe action based on system state.
 * @param[in] state Parameter
 * @return Failsafe_Action Return value
 * @timing WCET: 6 us
 * @pre state != NULL
 */
Failsafe_Action determine_failsafe_action(const Monitor_State* state);

/**
 * @brief Main update function. Called at 400Hz to process new IMU readings.
 * @param[inout] state Parameter
 * @param[in] readings Parameter
 * @param[in] imu_count Parameter
 * @param[in] current_time_us Parameter
 * @return Failsafe_Action Return value
 * @timing WCET: 85 us
 * @pre state != NULL
 * @pre imu_count <= MAX_IMU_COUNT
 */
Failsafe_Action imu_monitor_update(Monitor_State* state, const IMU_Reading* readings, uint8_t imu_count, uint32_t current_time_us);

/**
 * @brief Generate diagnostic report for a specific IMU.
 * @param[in] state Parameter
 * @param[in] imu_index Parameter
 * @param[in] reading Parameter
 * @param[out] report Parameter
 * @return int32_t Return value
 * @timing WCET: 15 us
 * @pre state != NULL
 * @pre imu_index < MAX_IMU_COUNT
 * @pre report != NULL
 */
int32_t imu_get_diagnostic(const Monitor_State* state, uint8_t imu_index, const IMU_Reading* reading, Diagnostic_Report* report);

/**
 * @brief Quick check if system is safe for continued flight.
 * @param[in] state Parameter
 * @return bool Return value
 * @timing WCET: 3 us
 * @pre state != NULL
 */
bool imu_is_system_safe(const Monitor_State* state);


#ifdef __cplusplus
}
#endif

#endif /* IMU_HEALTH_MONITOR_H */
