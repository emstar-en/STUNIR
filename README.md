# STUNIR

STUNIR is a **model-facing, deterministic generation harness** for turning a human-authored **spec** into:

- a canonical **Intermediate Representation (IR)**
- one or more **runtime outputs** (hosted and/or compiled)
- a **receipt bundle** (machine-checkable proofs/attestations) that binds the entire pipeline

STUNIR is designed for workflows where:

- Humans author *specs* (and occasionally review proofs).
- Models propose and orchestrate.
- **Only deterministic tooling is trusted** to produce IR, artifacts, and receipts.

STUNIR is not meant to be a human-operated CLI product. Humans typically do **not** interact with a STUNIR pack directly.

## What STUNIR is (and is not)

### STUNIR is

- A repeatable way to compile **spec → IR → artifacts** under strict determinism controls.
- A receipt system that makes outputs auditable and replayable.
- A structure for treating models as **untrusted planners** and the toolchain as the **sole producer** of commitments.

### STUNIR is not

- A deployment platform.
- A “run these commands” developer UX.
- A promise that every supported language is equally turnkey as a runtime *today*.

STUNIR’s contract is: **if an artifact exists, it is receipt-bound**.

## Core idea: shackle models to a deterministic toolchain

A model may:

- choose targets
- propose edits
- propose plans

…but it must not be the authority for:

- what the IR “means”
- what artifacts “are”
- whether a build “counts”

Instead, the deterministic toolchain produces:

- canonical IR commitments
- artifacts
- receipts

Verification is also deterministic. Models can present the raw proof, but the proof is generated by a deterministic process.

## Pipeline (conceptual)

Inputs:

- **Spec** (human-authored)
- **STUNIR Pack** (this repository + its deterministic tooling)
- **Build Epoch** (explicit time pin / determinism control)
- **Target Selection** (what to generate)

Outputs:

- **IR commitment** (canonical, hash-addressed meaning)
- **Artifacts** (hosted runtimes, compiled runtimes, raw language modules)
- **Receipts** (proof bundle binding inputs → tools → outputs)

## Output taxonomy (stable even as language support grows)

Instead of maintaining a brittle “list of languages,” STUNIR describes outputs by **execution mode** and **role**.

### Execution modes

#### 1) Hosted runtimes (mass-market)

A **hosted runtime** output is a complete runnable project whose execution engine is an existing runtime/VM already present in the environment.

If the host runtime is installed, this output functions like an “assembled runtime.”

Examples:

- Python
- Node.js
- JVM
- .NET
- Ruby
- PHP

Receipt expectations (hosted):

- host runtime fingerprint (name/version/platform)
- dependency closure digest (lockfile/resolved set)
- entrypoint + generated sources digests
- determinism controls (epoch, env guards)

#### 2) Compiled runtimes (direct-to-environment)

A **compiled runtime** output produces a low-level artifact intended for execution without a language VM (or via a minimal platform runtime like a WASM engine).

Examples:

- Assembly (default) → native artifacts via assembler/linker
- WASM → portable modules (optionally WASI)

Receipt expectations (compiled):

- toolchain identity (assembler/linker/compiler) + flags
- target ABI/triple + platform assumptions
- produced artifact hashes

#### 3) Raw outputs (language artifacts)

A **raw output** is a language-facing artifact intended for interoperability, embedding, verification, or downstream compilation.

Raw outputs may be:

- general-purpose source (e.g., C variants, Rust, Go, Haskell, Erlang/Elixir, Lisp)
- logic/constraint modules (e.g., Prolog, Datalog, ASP, MiniZinc)
- proof/safety gate inputs (e.g., SMT-LIB)

Receipt expectations (solver/prover-backed raw modules):

- solver identity + flags + determinism settings (threads/seed)
- input module hash + data hash
- output certificate/model/trace hash (when available)

### Roles (how a target is used)

A single language can appear in multiple roles depending on how STUNIR uses it.

- **Host Runtime Role** (Python/Node/JVM/.NET/Ruby/PHP)
  - the language runtime/VM is the execution engine

- **Backend Compiler Role** (C/Rust/Go/Haskell/Erlang/Elixir/…)
  - the language toolchain produces a distributable runtime (native/WASM/BEAM/etc.)

- **Logic/Constraint Role** (Datalog/ASP/MiniZinc/Prolog)
  - the artifact expresses rules/constraints/search, executed by an embedded engine or a pinned external solver

- **Proof/Safety Gate Role** (SMT)
  - the artifact proves/checks properties; outputs are pass/fail plus checkable side artifacts when available

## Promotion workflow (staging → compiled distribution)

STUNIR supports a partner-friendly two-stage deployment model:

1) **Stage using hosted runtimes** (fast iteration)

- generate a hosted runtime project (e.g., Python/Node)
- partners integrate and test live on their preferred hosting platform

2) **Promote to compiled runtimes** (broad distribution)

- promote from the same IR commitment
- generate compiled deliverables (Assembly/WASM) for target machines
- ship artifacts together with receipts for verification and replay

### Live modification policy (important)

If a partner modifies hosted runtime code during staging, treat that change as either:

- a **receipt-tracked input** (overlay/patch/spec update that becomes part of spec/IR inputs), or
- a **local experiment** (not expected to match promoted compiled outputs until reconciled)

STUNIR does not attempt to “own” what happens beyond the point where deterministic verification completes.

## Receipts: what they are supposed to prove

A receipt bundle is meant to make the generation pipeline **checkable by a small deterministic verifier**.

At minimum, receipts should bind:

- the **exact inputs** (spec + pack + target selection + epoch)
- the **exact tools** used (versions, digests, flags)
- the **exact outputs** (artifact hashes)

Stronger receipt bundles may additionally include:

- canonicalization traces
- solver/prover side artifacts (models, unsat cores, certificates)
- deterministic replay logs

A verifier should be able to recompute commitments and confirm that the receipt bundle matches, without trusting a model.

## Integration contract (for orchestrators)

STUNIR is intended to be called by an orchestrator (often a model under constraints) that:

- provides a spec
- selects targets
- ensures determinism inputs (epoch / environment constraints)
- triggers deterministic generation and deterministic verification

The orchestrator is responsible for:

- ensuring the STUNIR pack itself is pinned by digest
- ensuring tool invocations are policy-compliant (e.g., single-threaded, pinned versions)

STUNIR is responsible for:

- canonical IR generation
- artifact generation
- receipt emission
- deterministic verification outputs

## Repository conventions

This repository may evolve, but STUNIR packs typically include:

- `spec/` — example or reference specs (optional)
- `tools/` — deterministic compilers/normalizers/receipt emitters
- `receipts/` — receipt schema, examples, and emitted receipt bundles
- `build/` — build outputs and intermediate commitments
- `asm/` / `wasm/` — compiled runtime outputs (when applicable)
- `schemas/` — JSON Schema / format definitions for targets, receipts, and IR

## Design principles

- **Determinism-first**: outputs must be reproducible under the same inputs.
- **Canonical meaning**: IR has a unique normal form suitable for hashing and equivalence.
- **Small verifiers**: verification should be simpler than generation.
- **Models are untrusted**: models can propose; tools commit.
- **Extensible targets**: add languages by declaring mode + role, not by rewriting the worldview.

## Target descriptor (optional)

To avoid hardcoding language lists, targets can be described with a small descriptor object.

At minimum:

- `mode`: `hosted | compiled | raw`
- `role`: `host_runtime | backend_compiler | logic_constraint | proof_safety`

(See `schemas/` in this repo if present.)
