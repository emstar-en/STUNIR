"""CLIPS emitter for expert systems.

This module provides the CLIPSEmitter class for generating
CLIPS expert system code from Rule IR.

CLIPS (C Language Integrated Production System) is a widely used
expert system tool developed by NASA.
"""

from typing import List, Dict, Any, Optional

from ir.rules import RuleBase, Rule, Fact, FactTemplate, FunctionDef
from ir.rules import PatternCondition, TestCondition, CompositeCondition
from ir.rules import AssertAction, RetractAction, ModifyAction, BindAction, CallAction, PrintoutAction, HaltAction
from ir.rules import EmitterResult
from .base import BaseExpertSystemEmitter, canonical_json, compute_sha256


class CLIPSEmitter(BaseExpertSystemEmitter):
    """Emitter for CLIPS expert system language.
    
    Generates CLIPS code from a RuleBase including:
    - deftemplate: Template definitions
    - deffacts: Initial fact definitions
    - defrule: Rule definitions
    - deffunction: Function definitions
    
    CLIPS syntax reference:
    ```clips
    ; Comments start with semicolon
    
    (deftemplate person
       (slot name (type STRING))
       (slot age (type INTEGER) (default 0)))
    
    (deffacts initial
       (person (name "John") (age 30)))
    
    (defrule greet
       (person (name ?n))
       =>
       (printout t "Hello " ?n crlf))
    ```
    """
    
    DIALECT = "clips"
    VERSION = "6.4"
    
    # CLIPS-specific type mapping
    TYPE_MAP = {
        "i8": "INTEGER",
        "i16": "INTEGER",
        "i32": "INTEGER",
        "i64": "INTEGER",
        "f32": "FLOAT",
        "f64": "FLOAT",
        "bool": "SYMBOL",
        "string": "STRING",
        "symbol": "SYMBOL",
        "any": "?VARIABLE",
        "list": "MULTIFIELD",
        "fact-address": "FACT-ADDRESS",
        "external-address": "EXTERNAL-ADDRESS",
        "instance": "INSTANCE",
        "instance-name": "INSTANCE-NAME",
        "instance-address": "INSTANCE-ADDRESS"
    }
    
    def __init__(self, pretty_print: bool = True):
        """Initialize CLIPS emitter.
        
        Args:
            pretty_print: Whether to format output with indentation
        """
        super().__init__(pretty_print)
    
    def emit(self, rulebase: RuleBase) -> EmitterResult:
        """Emit CLIPS code from a RuleBase.
        
        Args:
            rulebase: The knowledge base to emit
            
        Returns:
            EmitterResult with CLIPS code and manifest
        """
        self._output = []
        self._warnings = []
        
        # Header
        self._emit_header(rulebase)
        
        # Templates
        for template in rulebase.templates:
            self._emit_template(template)
        
        # Global variables
        if rulebase.globals:
            self._emit_globals(rulebase.globals)
        
        # Functions
        for func in rulebase.functions.values():
            self._emit_function(func)
        
        # Initial facts
        if rulebase.initial_facts:
            self._emit_initial_facts(rulebase.initial_facts, rulebase.name)
        
        # Rules
        for rule in rulebase.rules:
            self._emit_rule(rule)
        
        code = "\n".join(self._output)
        manifest = self._generate_manifest(rulebase, code)
        
        return EmitterResult(
            code=code,
            manifest=manifest,
            warnings=self._warnings
        )
    
    def _emit_header(self, rulebase: RuleBase) -> None:
        """Emit CLIPS file header."""
        self._line(f";;;; CLIPS Expert System: {rulebase.name}")
        self._line(f";;;; Generated by STUNIR {self.DIALECT} Emitter v{self.VERSION}")
        self._line("")
    
    def _emit_template(self, template: FactTemplate) -> None:
        """Emit a deftemplate.
        
        Args:
            template: The template to emit
        """
        self._line(f"(deftemplate {template.name}")
        self._indent += 3
        
        # Documentation
        if template.documentation:
            self._line(f'"{template.documentation}"')
        
        # Regular slots
        for slot_name, slot_type in template.slots:
            clips_type = self._map_type(slot_type)
            default = template.default_values.get(slot_name)
            
            parts = [f"(slot {slot_name}"]
            parts.append(f"(type {clips_type})")
            if default is not None:
                parts.append(f"(default {self._format_value(default)})")
            parts.append(")")
            self._line(" ".join(parts))
        
        # Multislots
        for slot_name, slot_type in template.multislots:
            clips_type = self._map_type(slot_type)
            self._line(f"(multislot {slot_name} (type {clips_type}))")
        
        self._indent -= 3
        self._line(")")
        self._line("")
    
    def _emit_globals(self, globals_dict: Dict[str, Any]) -> None:
        """Emit global variables.
        
        Args:
            globals_dict: Dictionary of global variables
        """
        self._line("(defglobal")
        self._indent += 3
        for name, value in globals_dict.items():
            self._line(f"?*{name}* = {self._format_value(value)}")
        self._indent -= 3
        self._line(")")
        self._line("")
    
    def _emit_function(self, func: FunctionDef) -> None:
        """Emit a deffunction.
        
        Args:
            func: The function to emit
        """
        params = " ".join(f"?{p}" for p in func.parameters)
        self._line(f"(deffunction {func.name} ({params})")
        self._indent += 3
        
        # Documentation
        if func.documentation:
            self._line(f'"{func.documentation}"')
        
        # Body
        self._line(func.body)
        
        self._indent -= 3
        self._line(")")
        self._line("")
    
    def _emit_rule(self, rule: Rule) -> None:
        """Emit a defrule.
        
        Args:
            rule: The rule to emit
        """
        # Module prefix if specified
        if rule.module:
            rule_name = f"{rule.module}::{rule.name}"
        else:
            rule_name = rule.name
        
        self._line(f"(defrule {rule_name}")
        self._indent += 3
        
        # Documentation
        if rule.documentation:
            self._line(f'"{rule.documentation}"')
        
        # Declaration block (salience, auto-focus)
        declarations = []
        if rule.salience != 0:
            declarations.append(f"(salience {rule.salience})")
        if rule.auto_focus:
            declarations.append("(auto-focus TRUE)")
        
        if declarations:
            self._line(f"(declare {' '.join(declarations)})")
        
        # Conditions (LHS)
        for condition in rule.conditions:
            self._emit_condition(condition)
        
        # Arrow separating LHS from RHS
        self._line("=>")
        
        # Actions (RHS)
        for action in rule.actions:
            self._emit_action(action)
        
        self._indent -= 3
        self._line(")")
        self._line("")
    
    def _emit_action(self, action) -> None:
        """Emit a rule action with CLIPS-specific handling.
        
        Args:
            action: The action to emit
        """
        if isinstance(action, HaltAction):
            self._line("(halt)")
        else:
            super()._emit_action(action)
    
    def _generate_manifest(self, rulebase: RuleBase, code: str) -> Dict[str, Any]:
        """Generate CLIPS-specific manifest.
        
        Args:
            rulebase: The knowledge base
            code: The generated code
            
        Returns:
            Manifest dict with CLIPS metadata
        """
        manifest = super()._generate_manifest(rulebase, code)
        
        # Add CLIPS-specific metadata
        manifest["clips_info"] = {
            "requires_clips_version": "6.30+",
            "uses_defglobal": len(rulebase.globals) > 0,
            "uses_deffunction": len(rulebase.functions) > 0,
            "total_conditions": sum(len(r.conditions) for r in rulebase.rules),
            "total_actions": sum(len(r.actions) for r in rulebase.rules)
        }
        
        # Recompute manifest hash with new fields
        manifest["manifest_hash"] = compute_sha256(
            canonical_json({k: v for k, v in manifest.items() if k != "manifest_hash"}).encode()
        )
        
        return manifest
