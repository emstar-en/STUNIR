"""Jess emitter for expert systems.

This module provides the JessEmitter class for generating
Jess expert system code from Rule IR.

Jess (Java Expert System Shell) is a rule engine for the Java platform
with CLIPS-like syntax and Java integration capabilities.
"""

from typing import List, Dict, Any, Optional, Set

from ir.rules import RuleBase, Rule, Fact, FactTemplate, FunctionDef
from ir.rules import PatternCondition, TestCondition, CompositeCondition
from ir.rules import AssertAction, RetractAction, ModifyAction, BindAction, CallAction, PrintoutAction, HaltAction
from ir.rules import EmitterResult
from .base import BaseExpertSystemEmitter, canonical_json, compute_sha256


class JessEmitter(BaseExpertSystemEmitter):
    """Emitter for Jess expert system language (Java-based).
    
    Generates Jess code from a RuleBase including:
    - deftemplate: Template definitions
    - deffacts: Initial fact definitions
    - defrule: Rule definitions
    - deffunction: Function definitions
    - Java integration (imports, method calls)
    
    Jess syntax reference:
    ```lisp
    ; Jess is similar to CLIPS but Java-based
    
    (deftemplate person
       (slot name)
       (slot age (type INTEGER) (default 0)))
    
    (deffacts initial
       (person (name "John") (age 30)))
    
    ; Java integration
    (import java.util.*)
    (bind ?list (new ArrayList))
    (call ?list add "item")
    ```
    """
    
    DIALECT = "jess"
    VERSION = "7.1"
    
    # Jess-specific type mapping
    TYPE_MAP = {
        "i8": "INTEGER",
        "i16": "INTEGER",
        "i32": "INTEGER",
        "i64": "LONG",
        "f32": "FLOAT",
        "f64": "DOUBLE",
        "bool": "SYMBOL",
        "string": "STRING",
        "symbol": "SYMBOL",
        "any": "ANY",
        "list": "LIST",
        "object": "OBJECT"
    }
    
    # Java type mapping for integration
    JAVA_TYPE_MAP = {
        "i8": "byte",
        "i16": "short",
        "i32": "int",
        "i64": "long",
        "f32": "float",
        "f64": "double",
        "bool": "boolean",
        "string": "String"
    }
    
    def __init__(self, pretty_print: bool = True, java_integration: bool = False):
        """Initialize Jess emitter.
        
        Args:
            pretty_print: Whether to format output with indentation
            java_integration: Whether to enable Java integration features
        """
        super().__init__(pretty_print)
        self.java_integration = java_integration
        self._imports: Set[str] = set()
    
    def emit(self, rulebase: RuleBase) -> EmitterResult:
        """Emit Jess code from a RuleBase.
        
        Args:
            rulebase: The knowledge base to emit
            
        Returns:
            EmitterResult with Jess code and manifest
        """
        self._output = []
        self._warnings = []
        # Preserve imports that were added before emit()
        # self._imports = set()  # Don't clear existing imports
        
        # Header
        self._emit_header(rulebase)
        
        # Java imports (if enabled)
        if self.java_integration and self._imports:
            self._emit_java_imports()
        
        # Templates
        for template in rulebase.templates:
            self._emit_template(template)
        
        # Global variables
        if rulebase.globals:
            self._emit_globals(rulebase.globals)
        
        # Functions
        for func in rulebase.functions.values():
            self._emit_function(func)
        
        # Initial facts
        if rulebase.initial_facts:
            self._emit_initial_facts(rulebase.initial_facts, rulebase.name)
        
        # Rules
        for rule in rulebase.rules:
            self._emit_rule(rule)
        
        code = "\n".join(self._output)
        manifest = self._generate_manifest(rulebase, code)
        
        return EmitterResult(
            code=code,
            manifest=manifest,
            warnings=self._warnings
        )
    
    def _emit_header(self, rulebase: RuleBase) -> None:
        """Emit Jess file header."""
        self._line(f";;;; Jess Expert System: {rulebase.name}")
        self._line(f";;;; Generated by STUNIR {self.DIALECT} Emitter v{self.VERSION}")
        if self.java_integration:
            self._line(";;;; Java Integration Enabled")
        self._line("")
    
    def _emit_java_imports(self) -> None:
        """Emit Java import statements."""
        for imp in sorted(self._imports):
            self._line(f"(import {imp})")
        self._line("")
    
    def _emit_template(self, template: FactTemplate) -> None:
        """Emit a deftemplate.
        
        Args:
            template: The template to emit
        """
        self._line(f"(deftemplate {template.name}")
        self._indent += 3
        
        # Documentation
        if template.documentation:
            self._line(f'"{template.documentation}"')
        
        # Regular slots
        for slot_name, slot_type in template.slots:
            jess_type = self._map_type(slot_type)
            default = template.default_values.get(slot_name)
            
            parts = [f"(slot {slot_name}"]
            parts.append(f"(type {jess_type})")
            if default is not None:
                parts.append(f"(default {self._format_value(default)})")
            parts.append(")")
            self._line(" ".join(parts))
        
        # Multislots
        for slot_name, slot_type in template.multislots:
            jess_type = self._map_type(slot_type)
            self._line(f"(multislot {slot_name} (type {jess_type}))")
        
        self._indent -= 3
        self._line(")")
        self._line("")
    
    def _emit_globals(self, globals_dict: Dict[str, Any]) -> None:
        """Emit global variables.
        
        Args:
            globals_dict: Dictionary of global variables
        """
        self._line("(defglobal")
        self._indent += 3
        for name, value in globals_dict.items():
            self._line(f"?*{name}* = {self._format_value(value)}")
        self._indent -= 3
        self._line(")")
        self._line("")
    
    def _emit_function(self, func: FunctionDef) -> None:
        """Emit a deffunction.
        
        Args:
            func: The function to emit
        """
        params = " ".join(f"?{p}" for p in func.parameters)
        self._line(f"(deffunction {func.name} ({params})")
        self._indent += 3
        
        # Documentation
        if func.documentation:
            self._line(f'"{func.documentation}"')
        
        # Body
        self._line(func.body)
        
        self._indent -= 3
        self._line(")")
        self._line("")
    
    def _emit_rule(self, rule: Rule) -> None:
        """Emit a defrule.
        
        Args:
            rule: The rule to emit
        """
        # Module prefix if specified
        if rule.module:
            rule_name = f"{rule.module}::{rule.name}"
        else:
            rule_name = rule.name
        
        self._line(f"(defrule {rule_name}")
        self._indent += 3
        
        # Documentation
        if rule.documentation:
            self._line(f'"{rule.documentation}"')
        
        # Declaration block (salience, auto-focus, etc.)
        declarations = []
        if rule.salience != 0:
            declarations.append(f"(salience {rule.salience})")
        if rule.auto_focus:
            declarations.append("(auto-focus TRUE)")
        
        if declarations:
            self._line(f"(declare {' '.join(declarations)})")
        
        # Conditions (LHS)
        for condition in rule.conditions:
            self._emit_condition(condition)
        
        # Arrow separating LHS from RHS
        self._line("=>")
        
        # Actions (RHS)
        for action in rule.actions:
            self._emit_action(action)
        
        self._indent -= 3
        self._line(")")
        self._line("")
    
    def _emit_action(self, action) -> None:
        """Emit a rule action with Jess-specific handling.
        
        Args:
            action: The action to emit
        """
        if isinstance(action, HaltAction):
            self._line("(halt)")
        elif isinstance(action, CallAction):
            # Jess supports Java method calls
            if self.java_integration and "." in action.function_name:
                # Java method call: (call ?obj method args...)
                parts = action.function_name.rsplit(".", 1)
                if len(parts) == 2:
                    obj, method = parts
                    args = " ".join(self._format_value(a) for a in action.arguments)
                    if args:
                        self._line(f"(call ?{obj} {method} {args})")
                    else:
                        self._line(f"(call ?{obj} {method})")
                else:
                    # Regular function call
                    args = " ".join(self._format_value(a) for a in action.arguments)
                    self._line(f"({action.function_name} {args})")
            else:
                # Regular function call
                args = " ".join(self._format_value(a) for a in action.arguments)
                self._line(f"({action.function_name} {args})")
        else:
            super()._emit_action(action)
    
    def add_java_import(self, class_name: str) -> None:
        """Add a Java import.
        
        Args:
            class_name: Fully qualified Java class name
        """
        self._imports.add(class_name)
    
    def emit_java_new(self, class_name: str, *args) -> str:
        """Generate a Java constructor call.
        
        Args:
            class_name: Java class name
            *args: Constructor arguments
            
        Returns:
            Jess code for creating new Java object
        """
        if args:
            arg_str = " ".join(self._format_value(a) for a in args)
            return f"(new {class_name} {arg_str})"
        return f"(new {class_name})"
    
    def emit_java_call(self, obj: str, method: str, *args) -> str:
        """Generate a Java method call.
        
        Args:
            obj: Object variable name (without ?)
            method: Method name
            *args: Method arguments
            
        Returns:
            Jess code for calling Java method
        """
        if args:
            arg_str = " ".join(self._format_value(a) for a in args)
            return f"(call ?{obj} {method} {arg_str})"
        return f"(call ?{obj} {method})"
    
    def emit_java_get(self, obj: str, field: str) -> str:
        """Generate a Java field getter.
        
        Args:
            obj: Object variable name (without ?)
            field: Field name
            
        Returns:
            Jess code for getting Java field
        """
        return f"(get-member ?{obj} {field})"
    
    def emit_java_static_call(self, class_name: str, method: str, *args) -> str:
        """Generate a static Java method call.
        
        Args:
            class_name: Fully qualified class name
            method: Static method name
            *args: Method arguments
            
        Returns:
            Jess code for calling static Java method
        """
        if args:
            arg_str = " ".join(self._format_value(a) for a in args)
            return f"(call {class_name} {method} {arg_str})"
        return f"(call {class_name} {method})"
    
    def _generate_manifest(self, rulebase: RuleBase, code: str) -> Dict[str, Any]:
        """Generate Jess-specific manifest.
        
        Args:
            rulebase: The knowledge base
            code: The generated code
            
        Returns:
            Manifest dict with Jess metadata
        """
        manifest = super()._generate_manifest(rulebase, code)
        
        # Add Jess-specific metadata
        manifest["jess_info"] = {
            "requires_jess_version": "7.0+",
            "java_integration": self.java_integration,
            "java_imports": list(self._imports),
            "uses_defglobal": len(rulebase.globals) > 0,
            "uses_deffunction": len(rulebase.functions) > 0,
            "total_conditions": sum(len(r.conditions) for r in rulebase.rules),
            "total_actions": sum(len(r.actions) for r in rulebase.rules)
        }
        
        # Update statistics with import count
        manifest["statistics"]["java_imports"] = len(self._imports)
        
        # Recompute manifest hash with new fields
        manifest["manifest_hash"] = compute_sha256(
            canonical_json({k: v for k, v in manifest.items() if k != "manifest_hash"}).encode()
        )
        
        return manifest
