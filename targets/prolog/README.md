# STUNIR Prolog Targets

This directory contains code generators for Prolog-family logic programming languages.

## Supported Targets

### SWI-Prolog (`swi_prolog`)

The primary Prolog target, generating code for [SWI-Prolog](https://www.swi-prolog.org/), the most widely-used open-source Prolog implementation.

**Features:**
- Module declarations with exports
- Facts and rules
- DCG (Definite Clause Grammar) rules
- Cut (!) and negation-as-failure (\\+)
- Dynamic and multifile predicates
- Type hints (PlDoc-style comments)
- Deterministic output for reproducibility

### GNU Prolog (`gnu_prolog`)

Secondary Prolog target with Constraint Logic Programming support, generating code for [GNU Prolog](http://www.gprolog.org/).

**Features:**
- File-based organization (no module system)
- Public predicate declarations (`:- public/1`)
- Facts and rules
- CLP(FD) - Finite Domain Constraints
- CLP(B) - Boolean Constraints
- CLP(R) - Real Number Constraints (optional)
- Cut (!) and negation-as-failure (\\+)
- Dynamic predicates
- Native compilation support
- Deterministic output for reproducibility

**Key Differences from SWI-Prolog:**

| Feature | SWI-Prolog | GNU Prolog |
|---------|------------|------------|
| Module system | `:- module(Name, []).` | None (file-based) |
| Exports | Module exports | `:- public(pred/N).` |
| Dynamic | `:- dynamic p/N.` | `:- dynamic(p/N).` |
| CLP(FD) | `use_module(library(clpfd))` | Built-in |
| CLP(B) | Separate library | Built-in |
| Native compile | No | `gplc` generates executable |

## Usage

### SWI-Prolog Usage

```python
from targets.prolog.swi_prolog import SWIPrologEmitter, SWIPrologConfig

# Create emitter with default config
emitter = SWIPrologEmitter()

# Define IR
ir = {
    "module": "family",
    "exports": [{"predicate": "grandparent", "arity": 2}],
    "clauses": [
        {"kind": "fact", "predicate": "parent", "args": [
            {"kind": "atom", "value": "tom"},
            {"kind": "atom", "value": "bob"}
        ]},
        {"kind": "rule",
         "head": {"kind": "compound", "functor": "grandparent", "args": [
             {"kind": "variable", "name": "X"},
             {"kind": "variable", "name": "Z"}
         ]},
         "body": [
             {"kind": "compound", "functor": "parent", "args": [
                 {"kind": "variable", "name": "X"},
                 {"kind": "variable", "name": "Y"}
             ]},
             {"kind": "compound", "functor": "parent", "args": [
                 {"kind": "variable", "name": "Y"},
                 {"kind": "variable", "name": "Z"}
             ]}
         ]}
    ]
}

# Generate code
result = emitter.emit(ir)
print(result.code)
```

### GNU Prolog Usage

```python
from targets.prolog.gnu_prolog import GNUPrologEmitter, GNUPrologConfig

# Create emitter with CLP enabled
config = GNUPrologConfig(
    enable_clpfd=True,
    enable_clpb=True
)
emitter = GNUPrologEmitter(config)

# Define IR with CLP(FD) constraints
ir = {
    "module": "puzzle",
    "exports": [{"predicate": "solve", "arity": 1}],
    "clauses": [
        {"kind": "rule",
         "head": {"kind": "compound", "functor": "solve", "args": [
             {"kind": "variable", "name": "X"}
         ]},
         "body": [
             {"kind": "compound", "functor": "domain", "args": [
                 {"kind": "variable", "name": "X"},
                 {"kind": "number", "value": 1},
                 {"kind": "number", "value": 9}
             ]},
             {"kind": "compound", "functor": "#>", "args": [
                 {"kind": "variable", "name": "X"},
                 {"kind": "number", "value": 5}
             ]},
             {"kind": "compound", "functor": "labeling", "args": [
                 {"kind": "list_term", "elements": [
                     {"kind": "variable", "name": "X"}
                 ]}
             ]}
         ]}
    ]
}

# Generate code
result = emitter.emit(ir)
print(result.code)
print(f"CLP features used: {result.clp_features}")
```

### GNU Prolog Output (with CLP)

```prolog
/*
 * STUNIR Generated GNU Prolog Source
 * File: puzzle
 * Generated: 2026-01-29 10:30:00
 * CLP Features: clpfd
 * 
 * This file was automatically generated by STUNIR.
 * Compile with: gplc -o program puzzle.pl
 * Do not edit manually.
 */

% Public predicates
:- public(solve/1).

% CLP Features used in this file:
% - CLP(FD): Finite Domain Constraints
%   Operators: #=, #\=, #<, #>, #=<, #>=
%   Use fd_domain/3 or X in L..H for domains
%   Use fd_labeling/1 for search

solve(X) :-
    fd_domain(X, 1, 9),
    X #> 5,
    fd_labeling([X]).
```

### SWI-Prolog Configuration Options

```python
config = SWIPrologConfig(
    module_prefix="myapp",      # Prefix for module names
    emit_module=True,           # Generate module declaration
    emit_comments=True,         # Generate header comments
    emit_type_hints=True,       # Generate %% pred/N hints
    indent="    ",              # Indentation string
    line_width=80,              # Line width limit
    use_tabling=False,          # Enable :- table declarations
    use_constraints=False,      # Enable CLP(FD) support
    emit_timestamps=True,       # Include timestamp in header
    emit_sha256=True,           # Include hash in result
)

emitter = SWIPrologEmitter(config)
```

### GNU Prolog Configuration Options

```python
config = GNUPrologConfig(
    file_prefix="myapp",        # Prefix for filenames
    emit_comments=True,         # Generate header comments
    emit_public=True,           # Generate :- public declarations
    emit_initialization=True,   # Include initialization
    indent="    ",              # Indentation string
    line_width=80,              # Line width limit
    enable_clpfd=True,          # Enable CLP(FD) constraints
    enable_clpb=True,           # Enable CLP(B) constraints
    enable_clpr=False,          # Enable CLP(R) constraints
    native_compile=False,       # Generate gplc commands
    emit_timestamps=True,       # Include timestamp in header
    emit_sha256=True,           # Include hash in result
)

emitter = GNUPrologEmitter(config)
```

## CLP Support (GNU Prolog)

### CLP(FD) - Finite Domain Constraints

GNU Prolog has built-in support for finite domain constraints:

```python
# Domain constraint
{"kind": "compound", "functor": "domain", "args": [
    {"kind": "variable", "name": "X"},
    {"kind": "number", "value": 1},
    {"kind": "number", "value": 100}
]}
# Generates: fd_domain(X, 1, 100)

# Arithmetic constraint
{"kind": "compound", "functor": "#=", "args": [
    {"kind": "compound", "functor": "+", "args": [
        {"kind": "variable", "name": "X"},
        {"kind": "variable", "name": "Y"}
    ]},
    {"kind": "number", "value": 10}
]}
# Generates: X + Y #= 10

# All different constraint
{"kind": "compound", "functor": "all_different", "args": [
    {"kind": "variable", "name": "Vars"}
]}
# Generates: fd_all_different(Vars)

# Labeling (search)
{"kind": "compound", "functor": "labeling", "args": [
    {"kind": "variable", "name": "Vars"}
]}
# Generates: fd_labeling(Vars)
```

### CLP(FD) Operators

| IR Operator | GNU Prolog |
|-------------|------------|
| `==` or `#=` | `#=` (equal) |
| `!=` or `#\=` | `#\=` (not equal) |
| `<` or `#<` | `#<` (less than) |
| `>` or `#>` | `#>` (greater than) |
| `<=` or `#=<` | `#=<` (less or equal) |
| `>=` or `#>=` | `#>=` (greater or equal) |

### CLP(B) - Boolean Constraints

```python
# Boolean AND
{"kind": "compound", "functor": "#/\\", "args": [
    {"kind": "variable", "name": "X"},
    {"kind": "variable", "name": "Y"}
]}
# Generates: (X #/\ Y)

# Boolean OR
{"kind": "compound", "functor": "#\\/", "args": [
    {"kind": "variable", "name": "X"},
    {"kind": "variable", "name": "Y"}
]}
# Generates: (X #\/ Y)

# Boolean NOT
{"kind": "compound", "functor": "#\\", "args": [
    {"kind": "variable", "name": "X"}
]}
# Generates: #\ X

# Equivalence
{"kind": "compound", "functor": "#<=>", "args": [
    {"kind": "variable", "name": "X"},
    {"kind": "variable", "name": "Y"}
]}
# Generates: (X #<=> Y)
```

## Logic IR

The Prolog emitters use the Logic IR extension (`tools/ir/logic_ir.py`) which provides:

### Terms

| Kind | Description | Example |
|------|-------------|--------|
| `variable` | Logic variable | `{"kind": "variable", "name": "X"}` |
| `atom` | Prolog atom | `{"kind": "atom", "value": "hello"}` |
| `compound` | Compound term | `{"kind": "compound", "functor": "f", "args": [...]}` |
| `list_term` | Prolog list | `{"kind": "list_term", "elements": [...], "tail": ...}` |
| `anonymous` | Anonymous var | `{"kind": "anonymous"}` |

### Clauses

| Kind | Description | Example |
|------|-------------|--------|
| `fact` | Ground clause | `{"kind": "fact", "predicate": "p", "args": [...]}` |
| `rule` | Head :- Body | `{"kind": "rule", "head": {...}, "body": [...]}` |

### Goals

| Kind | Description |
|------|-------------|
| `compound` | Call predicate |
| `cut` | Cut (!) |
| `negation` | Negation-as-failure (\\+) |
| `unification` | X = Y |

## Unification Algorithm

The Logic IR includes a complete unification algorithm implementation:

```python
from tools.ir.logic_ir import Variable, Atom, Compound, unify, UnificationError

X = Variable("X")
a = Atom("hello")

# Basic unification
subst = unify(X, a)
assert subst.get(X) == a

# Compound unification
t1 = Compound("f", [X, Atom("b")])
t2 = Compound("f", [Atom("a"), Variable("Y")])
subst = unify(t1, t2)
# X -> a, Y -> b
```

## DCG Support

Both emitters support Definite Clause Grammars:

```python
ir = {
    "module": "parser",
    "clauses": [],
    "dcg_rules": [
        {
            "head": {"kind": "compound", "functor": "sentence", "args": []},
            "body": [
                {"kind": "nonterminal", "term": {"kind": "compound", "functor": "noun_phrase", "args": []}},
                {"kind": "nonterminal", "term": {"kind": "compound", "functor": "verb_phrase", "args": []}}
            ]
        },
        {
            "head": {"kind": "compound", "functor": "noun_phrase", "args": []},
            "body": [
                {"kind": "terminal", "terminals": ["the"]},
                {"kind": "nonterminal", "term": {"kind": "compound", "functor": "noun", "args": []}}
            ]
        }
    ]
}
```

Generates:

```prolog
sentence --> noun_phrase, verb_phrase.
noun_phrase --> [the], noun.
```

## Testing

Run tests:

```bash
# Logic IR tests
python -m pytest tests/ir/test_logic_ir.py -v

# SWI-Prolog emitter tests
python -m pytest tests/codegen/test_swi_prolog_generator.py -v

# GNU Prolog emitter tests
python -m pytest tests/codegen/test_gnu_prolog_generator.py -v

# All Prolog tests
python -m pytest tests/codegen/test_*prolog*.py tests/ir/test_logic_ir.py -v
```

### YAP Prolog (`yap`)

High-performance Prolog target with tabling (memoization) support, generating code for [YAP Prolog](https://github.com/vscosta/yap-6.3).

**Features:**
- Module declarations (similar to SWI-Prolog)
- Tabling (memoization) with `:- table pred/N` directives
- Automatic recursive predicate detection for tabling
- Indexing directives for performance optimization
- Facts and rules
- DCG (Definite Clause Grammar) rules
- Cut (!) and negation-as-failure (\\+)
- Dynamic, multifile, and discontiguous predicates
- Thread-local predicates
- Type hints (PlDoc-style comments)
- Deterministic output for reproducibility

**Key Differences from SWI-Prolog:**

| Feature | SWI-Prolog | YAP Prolog |
|---------|------------|------------|
| Tabling | `:- table p/N` (library) | `:- table p/N` (optimized) |
| Indexing | Automatic | `:- index(pred, [Args])` |
| Performance | Good | Excellent (WAM optimized) |
| Threads | Library | Built-in |
| Attributed vars | Library | Built-in |

## Usage

### YAP Prolog Usage

```python
from targets.prolog.yap import YAPPrologEmitter, YAPPrologConfig

# Create emitter with tabling enabled (default)
config = YAPPrologConfig(
    enable_tabling=True,
    enable_indexing=True
)
emitter = YAPPrologEmitter(config)

# Define IR with recursive predicate (Fibonacci)
ir = {
    "module": "math",
    "clauses": [
        {"kind": "fact", "predicate": "fib", "args": [0, 0]},
        {"kind": "fact", "predicate": "fib", "args": [1, 1]},
        {"kind": "rule",
         "head": {"kind": "compound", "functor": "fib", "args": [
             {"kind": "variable", "name": "N"},
             {"kind": "variable", "name": "F"}
         ]},
         "body": [
             {"kind": "compound", "functor": ">", "args": [
                 {"kind": "variable", "name": "N"},
                 1
             ]},
             {"kind": "compound", "functor": "fib", "args": [
                 {"kind": "variable", "name": "N1"},
                 {"kind": "variable", "name": "F1"}
             ]},
             {"kind": "compound", "functor": "fib", "args": [
                 {"kind": "variable", "name": "N2"},
                 {"kind": "variable", "name": "F2"}
             ]}
         ]}
    ]
}

# Generate code
result = emitter.emit(ir)
print(result.code)
print(f"Tabled predicates: {result.tabled_predicates}")
print(f"Indexed predicates: {result.indexed_predicates}")
```

### YAP Prolog Output (with Tabling)

```prolog
/*
 * STUNIR Generated YAP Prolog Module
 * Module: math
 * Generated: 2026-01-29 10:30:00
 * Tabled predicates: 1
 * 
 * This file was automatically generated by STUNIR.
 * YAP Prolog target with tabling support.
 * Do not edit manually.
 */

:- module(stunir_math, [fib/2]).

% Tabling directives (memoization)
:- table fib/2.

%% fib/2 [tabled]

fib(0, 0).
fib(1, 1).
fib(N, F) :-
    N > 1,
    fib(N1, F1),
    fib(N2, F2).
```

### YAP Prolog Configuration Options

```python
config = YAPPrologConfig(
    module_prefix="myapp",       # Prefix for module names
    emit_module=True,            # Generate module declaration
    emit_comments=True,          # Generate header comments
    emit_type_hints=True,        # Generate %% pred/N hints
    indent="    ",               # Indentation string
    line_width=80,               # Line width limit
    enable_tabling=True,         # Auto-table recursive predicates
    tabling_mode='variant',      # Tabling mode: variant, subsumptive
    enable_indexing=True,        # Emit indexing directives
    auto_index_threshold=5,      # Min clauses to add indexing
    enable_thread_local=False,   # Thread-local predicates
    emit_timestamps=True,        # Include timestamp in header
    emit_sha256=True,            # Include hash in result
    file_extension=".pl",        # .pl or .yap
)

emitter = YAPPrologEmitter(config)
```

## Tabling Support (YAP Prolog)

YAP's tabling provides automatic memoization for recursive predicates, converting exponential-time algorithms to linear-time:

### Without Tabling (Exponential Time)

```prolog
% fib(30, X) takes ~1 million calls
fib(0, 0).
fib(1, 1).
fib(N, F) :-
    N > 1,
    N1 is N - 1, N2 is N - 2,
    fib(N1, F1), fib(N2, F2),
    F is F1 + F2.
```

### With Tabling (Linear Time)

```prolog
% fib(30, X) takes ~30 calls
:- table fib/2.
fib(0, 0).
fib(1, 1).
fib(N, F) :-
    N > 1,
    N1 is N - 1, N2 is N - 2,
    fib(N1, F1), fib(N2, F2),
    F is F1 + F2.
```

### Tabling Modes

| Mode | Description |
|------|-------------|
| `variant` | Default - cache based on variant calls |
| `subsumptive` | More aggressive caching |
| `lattice` | Aggregation tabling |
| `monotonic` | Incremental tabling |

## Indexing Directives (YAP Prolog)

YAP allows fine-grained control over clause indexing:

```python
# Explicit indexing annotation in IR
ir = {
    "module": "graph",
    "indexed": [
        {"predicate": "edge", "arity": 2, "args": [1, 2]}
    ],
    "clauses": [...]
}

# Generates:
# :- index(edge, [1, 2]).
```

### Datalog (`datalog`)

Datalog target generating code for the Datalog query language - a pure, declarative subset of Prolog with guaranteed termination.

**Features:**
- Bottom-up evaluation semantics
- Stratified negation support
- Automatic stratification analysis
- Head restriction validation (no function symbols)
- Range restriction validation (safety checking)
- Set semantics (no duplicate results)
- Multiple dialect support (standard, Souffle)
- Deterministic output for reproducibility

**Key Differences from Prolog:**

| Feature | Prolog | Datalog |
|---------|--------|---------|
| Evaluation | Top-down (SLD) | Bottom-up (fixpoint) |
| Termination | May not terminate | Always terminates |
| Function symbols | Allowed anywhere | Only in rule bodies |
| Negation | NAF (`\+`) | Stratified (`not`) |
| Semantics | Bag (duplicates) | Set (no duplicates) |
| Cut operator | `!` allowed | Not allowed |
| Side effects | IO, assert/retract | Pure declarative |

## Datalog Usage

```python
from targets.prolog.datalog import DatalogEmitter, DatalogConfig, ValidationLevel

# Create emitter with default strict validation
emitter = DatalogEmitter()

# Define IR for family relationships
ir = {
    "module": "family",
    "predicates": [
        {"name": "parent", "clauses": [
            {"kind": "fact", "predicate": "parent",
             "args": [{"kind": "atom", "value": "tom"},
                     {"kind": "atom", "value": "bob"}]},
            {"kind": "fact", "predicate": "parent",
             "args": [{"kind": "atom", "value": "bob"},
                     {"kind": "atom", "value": "ann"}]}
        ]},
        {"name": "ancestor", "clauses": [
            # Base case
            {"kind": "rule",
             "head": {"kind": "compound", "functor": "ancestor",
                     "args": [{"kind": "variable", "name": "X"},
                             {"kind": "variable", "name": "Y"}]},
             "body": [
                 {"kind": "call",
                  "term": {"kind": "compound", "functor": "parent",
                          "args": [{"kind": "variable", "name": "X"},
                                  {"kind": "variable", "name": "Y"}]}}
             ]},
            # Recursive case
            {"kind": "rule",
             "head": {"kind": "compound", "functor": "ancestor",
                     "args": [{"kind": "variable", "name": "X"},
                             {"kind": "variable", "name": "Z"}]},
             "body": [
                 {"kind": "call",
                  "term": {"kind": "compound", "functor": "parent",
                          "args": [{"kind": "variable", "name": "X"},
                                  {"kind": "variable", "name": "Y"}]}},
                 {"kind": "call",
                  "term": {"kind": "compound", "functor": "ancestor",
                          "args": [{"kind": "variable", "name": "Y"},
                                  {"kind": "variable", "name": "Z"}]}}
             ]}
        ]}
    ]
}

# Generate code
result = emitter.emit(ir)
print(result.code)
print(f"Stratification: {result.stratification.strata}")
```

### Datalog Output

```prolog
%
% STUNIR Generated Datalog Program
% Module: family
% Generated: 2026-01-29 10:30:00
% 
% This file was automatically generated by STUNIR.
% Datalog: Bottom-up evaluation, stratified negation
%

% Facts
parent(tom, bob).
parent(bob, ann).

% Stratum 0: ancestor
ancestor(X, Y) :- parent(X, Y).
ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).
```

### Datalog with Stratified Negation

```python
ir = {
    "module": "birds",
    "predicates": [
        {"name": "bird", "clauses": [
            {"kind": "fact", "predicate": "bird",
             "args": [{"kind": "atom", "value": "tweety"}]}
        ]},
        {"name": "penguin", "clauses": [
            {"kind": "fact", "predicate": "penguin",
             "args": [{"kind": "atom", "value": "tux"}]}
        ]},
        {"name": "flies", "clauses": [
            {"kind": "rule",
             "head": {"kind": "compound", "functor": "flies",
                     "args": [{"kind": "variable", "name": "X"}]},
             "body": [
                 {"kind": "call",
                  "term": {"kind": "compound", "functor": "bird",
                          "args": [{"kind": "variable", "name": "X"}]}},
                 {"kind": "negation",
                  "inner": {"kind": "call",
                           "term": {"kind": "compound", "functor": "penguin",
                                   "args": [{"kind": "variable", "name": "X"}]}}}
             ]}
        ]}
    ]
}

# Generates:
# bird(tweety).
# penguin(tux).
# flies(X) :- bird(X), not penguin(X).
#
# Stratification: {bird: 0, penguin: 0, flies: 1}
```

### Datalog Configuration Options

```python
config = DatalogConfig(
    emit_comments=True,          # Generate header comments
    emit_timestamps=True,        # Include timestamp in header
    emit_sha256=True,            # Include hash in result
    validation_level=ValidationLevel.STRICT,  # STRICT, WARN, LENIENT
    check_range_restriction=True,  # Validate safety
    check_stratification=True,   # Validate negation
    file_extension=".dl",        # .dl or .datalog
    indent="    ",               # Indentation string
    line_width=80,               # Line width limit
    dialect="standard",          # standard, souffle
)

emitter = DatalogEmitter(config)
```

## Datalog Restrictions

### 1. Head Restriction (No Function Symbols)

Function symbols are not allowed in rule heads:

```python
# INVALID - function symbol 'succ' in head
{"kind": "rule",
 "head": {"kind": "compound", "functor": "nat",
         "args": [{"kind": "compound", "functor": "succ",
                  "args": [{"kind": "variable", "name": "X"}]}]},
 "body": [...]}
# Raises DatalogRestrictionError!

# VALID - only atoms/variables in head
{"kind": "rule",
 "head": {"kind": "compound", "functor": "nat",
         "args": [{"kind": "variable", "name": "X"}]},
 "body": [...]}
```

### 2. Range Restriction (Safety)

Every variable in the head must appear in a positive body literal:

```python
# INVALID - X not in positive body
{"kind": "rule",
 "head": {"kind": "compound", "functor": "unsafe",
         "args": [{"kind": "variable", "name": "X"}]},
 "body": [
     {"kind": "negation",
      "inner": {"kind": "call",
               "term": {"kind": "compound", "functor": "known",
                       "args": [{"kind": "variable", "name": "X"}]}}}
 ]}
# Raises DatalogRestrictionError!

# VALID - X in positive body
{"kind": "rule",
 "head": {"kind": "compound", "functor": "safe",
         "args": [{"kind": "variable", "name": "X"}]},
 "body": [
     {"kind": "call",
      "term": {"kind": "compound", "functor": "known",
              "args": [{"kind": "variable", "name": "X"}]}},
     {"kind": "negation",
      "inner": {"kind": "call",
               "term": {"kind": "compound", "functor": "excluded",
                       "args": [{"kind": "variable", "name": "X"}]}}}
 ]}
```

### 3. Stratified Negation

Negation must be stratifiable (no negative cycles):

```python
# INVALID - negative cycle between p and q
# p(X) :- not q(X).
# q(X) :- not p(X).
# Raises StratificationError!

# VALID - stratified negation
# bird(tweety).
# penguin(tux).
# flies(X) :- bird(X), not penguin(X).  # flies depends on penguin
```

## Stratification Algorithm

The emitter uses Tarjan's algorithm to find strongly connected components and detect negative cycles:

1. **Build dependency graph**: predicate â†’ {(dependency, is_negated)}
2. **Find SCCs**: Using Tarjan's algorithm
3. **Check for negative cycles**: Within each SCC
4. **Assign strata**: Topological sort of SCCs

```python
result = emitter.stratify(ir)
print(f"Stratifiable: {result.is_stratifiable}")
print(f"Strata: {result.strata}")
print(f"Errors: {result.errors}")
```

## Future Targets

- SICStus Prolog
- XSB Prolog
- Ciao Prolog
- Souffle (specialized Datalog)

## Testing

Run tests:

```bash
# Logic IR tests
python -m pytest tests/ir/test_logic_ir.py -v

# SWI-Prolog emitter tests
python -m pytest tests/codegen/test_swi_prolog_generator.py -v

# GNU Prolog emitter tests
python -m pytest tests/codegen/test_gnu_prolog_generator.py -v

# YAP Prolog emitter tests
python -m pytest tests/codegen/test_yap_generator.py -v

# Datalog emitter tests
python -m pytest tests/codegen/test_datalog_generator.py -v

# All Prolog tests
python -m pytest tests/codegen/test_*prolog*.py tests/codegen/test_yap*.py tests/codegen/test_datalog*.py tests/ir/test_logic_ir.py -v
```

## See Also

- [SWI-Prolog Documentation](https://www.swi-prolog.org/pldoc/)
- [GNU Prolog Manual](http://www.gprolog.org/manual/gprolog.html)
- [Logic IR Schema](../../schemas/logic_ir.json)
- [Logic IR Implementation](../../tools/ir/logic_ir.py)
