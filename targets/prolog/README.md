# STUNIR Prolog Targets

This directory contains code generators for Prolog-family logic programming languages.

## Supported Targets

### SWI-Prolog (`swi_prolog`)

The primary Prolog target, generating code for [SWI-Prolog](https://www.swi-prolog.org/), the most widely-used open-source Prolog implementation.

**Features:**
- Module declarations with exports
- Facts and rules
- DCG (Definite Clause Grammar) rules
- Cut (!) and negation-as-failure (\\+)
- Dynamic and multifile predicates
- Type hints (PlDoc-style comments)
- Deterministic output for reproducibility

### GNU Prolog (`gnu_prolog`)

Secondary Prolog target with Constraint Logic Programming support, generating code for [GNU Prolog](http://www.gprolog.org/).

**Features:**
- File-based organization (no module system)
- Public predicate declarations (`:- public/1`)
- Facts and rules
- CLP(FD) - Finite Domain Constraints
- CLP(B) - Boolean Constraints
- CLP(R) - Real Number Constraints (optional)
- Cut (!) and negation-as-failure (\\+)
- Dynamic predicates
- Native compilation support
- Deterministic output for reproducibility

**Key Differences from SWI-Prolog:**

| Feature | SWI-Prolog | GNU Prolog |
|---------|------------|------------|
| Module system | `:- module(Name, []).` | None (file-based) |
| Exports | Module exports | `:- public(pred/N).` |
| Dynamic | `:- dynamic p/N.` | `:- dynamic(p/N).` |
| CLP(FD) | `use_module(library(clpfd))` | Built-in |
| CLP(B) | Separate library | Built-in |
| Native compile | No | `gplc` generates executable |

## Usage

### SWI-Prolog Usage

```python
from targets.prolog.swi_prolog import SWIPrologEmitter, SWIPrologConfig

# Create emitter with default config
emitter = SWIPrologEmitter()

# Define IR
ir = {
    "module": "family",
    "exports": [{"predicate": "grandparent", "arity": 2}],
    "clauses": [
        {"kind": "fact", "predicate": "parent", "args": [
            {"kind": "atom", "value": "tom"},
            {"kind": "atom", "value": "bob"}
        ]},
        {"kind": "rule",
         "head": {"kind": "compound", "functor": "grandparent", "args": [
             {"kind": "variable", "name": "X"},
             {"kind": "variable", "name": "Z"}
         ]},
         "body": [
             {"kind": "compound", "functor": "parent", "args": [
                 {"kind": "variable", "name": "X"},
                 {"kind": "variable", "name": "Y"}
             ]},
             {"kind": "compound", "functor": "parent", "args": [
                 {"kind": "variable", "name": "Y"},
                 {"kind": "variable", "name": "Z"}
             ]}
         ]}
    ]
}

# Generate code
result = emitter.emit(ir)
print(result.code)
```

### GNU Prolog Usage

```python
from targets.prolog.gnu_prolog import GNUPrologEmitter, GNUPrologConfig

# Create emitter with CLP enabled
config = GNUPrologConfig(
    enable_clpfd=True,
    enable_clpb=True
)
emitter = GNUPrologEmitter(config)

# Define IR with CLP(FD) constraints
ir = {
    "module": "puzzle",
    "exports": [{"predicate": "solve", "arity": 1}],
    "clauses": [
        {"kind": "rule",
         "head": {"kind": "compound", "functor": "solve", "args": [
             {"kind": "variable", "name": "X"}
         ]},
         "body": [
             {"kind": "compound", "functor": "domain", "args": [
                 {"kind": "variable", "name": "X"},
                 {"kind": "number", "value": 1},
                 {"kind": "number", "value": 9}
             ]},
             {"kind": "compound", "functor": "#>", "args": [
                 {"kind": "variable", "name": "X"},
                 {"kind": "number", "value": 5}
             ]},
             {"kind": "compound", "functor": "labeling", "args": [
                 {"kind": "list_term", "elements": [
                     {"kind": "variable", "name": "X"}
                 ]}
             ]}
         ]}
    ]
}

# Generate code
result = emitter.emit(ir)
print(result.code)
print(f"CLP features used: {result.clp_features}")
```

### GNU Prolog Output (with CLP)

```prolog
/*
 * STUNIR Generated GNU Prolog Source
 * File: puzzle
 * Generated: 2026-01-29 10:30:00
 * CLP Features: clpfd
 * 
 * This file was automatically generated by STUNIR.
 * Compile with: gplc -o program puzzle.pl
 * Do not edit manually.
 */

% Public predicates
:- public(solve/1).

% CLP Features used in this file:
% - CLP(FD): Finite Domain Constraints
%   Operators: #=, #\=, #<, #>, #=<, #>=
%   Use fd_domain/3 or X in L..H for domains
%   Use fd_labeling/1 for search

solve(X) :-
    fd_domain(X, 1, 9),
    X #> 5,
    fd_labeling([X]).
```

### SWI-Prolog Configuration Options

```python
config = SWIPrologConfig(
    module_prefix="myapp",      # Prefix for module names
    emit_module=True,           # Generate module declaration
    emit_comments=True,         # Generate header comments
    emit_type_hints=True,       # Generate %% pred/N hints
    indent="    ",              # Indentation string
    line_width=80,              # Line width limit
    use_tabling=False,          # Enable :- table declarations
    use_constraints=False,      # Enable CLP(FD) support
    emit_timestamps=True,       # Include timestamp in header
    emit_sha256=True,           # Include hash in result
)

emitter = SWIPrologEmitter(config)
```

### GNU Prolog Configuration Options

```python
config = GNUPrologConfig(
    file_prefix="myapp",        # Prefix for filenames
    emit_comments=True,         # Generate header comments
    emit_public=True,           # Generate :- public declarations
    emit_initialization=True,   # Include initialization
    indent="    ",              # Indentation string
    line_width=80,              # Line width limit
    enable_clpfd=True,          # Enable CLP(FD) constraints
    enable_clpb=True,           # Enable CLP(B) constraints
    enable_clpr=False,          # Enable CLP(R) constraints
    native_compile=False,       # Generate gplc commands
    emit_timestamps=True,       # Include timestamp in header
    emit_sha256=True,           # Include hash in result
)

emitter = GNUPrologEmitter(config)
```

## CLP Support (GNU Prolog)

### CLP(FD) - Finite Domain Constraints

GNU Prolog has built-in support for finite domain constraints:

```python
# Domain constraint
{"kind": "compound", "functor": "domain", "args": [
    {"kind": "variable", "name": "X"},
    {"kind": "number", "value": 1},
    {"kind": "number", "value": 100}
]}
# Generates: fd_domain(X, 1, 100)

# Arithmetic constraint
{"kind": "compound", "functor": "#=", "args": [
    {"kind": "compound", "functor": "+", "args": [
        {"kind": "variable", "name": "X"},
        {"kind": "variable", "name": "Y"}
    ]},
    {"kind": "number", "value": 10}
]}
# Generates: X + Y #= 10

# All different constraint
{"kind": "compound", "functor": "all_different", "args": [
    {"kind": "variable", "name": "Vars"}
]}
# Generates: fd_all_different(Vars)

# Labeling (search)
{"kind": "compound", "functor": "labeling", "args": [
    {"kind": "variable", "name": "Vars"}
]}
# Generates: fd_labeling(Vars)
```

### CLP(FD) Operators

| IR Operator | GNU Prolog |
|-------------|------------|
| `==` or `#=` | `#=` (equal) |
| `!=` or `#\=` | `#\=` (not equal) |
| `<` or `#<` | `#<` (less than) |
| `>` or `#>` | `#>` (greater than) |
| `<=` or `#=<` | `#=<` (less or equal) |
| `>=` or `#>=` | `#>=` (greater or equal) |

### CLP(B) - Boolean Constraints

```python
# Boolean AND
{"kind": "compound", "functor": "#/\\", "args": [
    {"kind": "variable", "name": "X"},
    {"kind": "variable", "name": "Y"}
]}
# Generates: (X #/\ Y)

# Boolean OR
{"kind": "compound", "functor": "#\\/", "args": [
    {"kind": "variable", "name": "X"},
    {"kind": "variable", "name": "Y"}
]}
# Generates: (X #\/ Y)

# Boolean NOT
{"kind": "compound", "functor": "#\\", "args": [
    {"kind": "variable", "name": "X"}
]}
# Generates: #\ X

# Equivalence
{"kind": "compound", "functor": "#<=>", "args": [
    {"kind": "variable", "name": "X"},
    {"kind": "variable", "name": "Y"}
]}
# Generates: (X #<=> Y)
```

## Logic IR

The Prolog emitters use the Logic IR extension (`tools/ir/logic_ir.py`) which provides:

### Terms

| Kind | Description | Example |
|------|-------------|--------|
| `variable` | Logic variable | `{"kind": "variable", "name": "X"}` |
| `atom` | Prolog atom | `{"kind": "atom", "value": "hello"}` |
| `compound` | Compound term | `{"kind": "compound", "functor": "f", "args": [...]}` |
| `list_term` | Prolog list | `{"kind": "list_term", "elements": [...], "tail": ...}` |
| `anonymous` | Anonymous var | `{"kind": "anonymous"}` |

### Clauses

| Kind | Description | Example |
|------|-------------|--------|
| `fact` | Ground clause | `{"kind": "fact", "predicate": "p", "args": [...]}` |
| `rule` | Head :- Body | `{"kind": "rule", "head": {...}, "body": [...]}` |

### Goals

| Kind | Description |
|------|-------------|
| `compound` | Call predicate |
| `cut` | Cut (!) |
| `negation` | Negation-as-failure (\\+) |
| `unification` | X = Y |

## Unification Algorithm

The Logic IR includes a complete unification algorithm implementation:

```python
from tools.ir.logic_ir import Variable, Atom, Compound, unify, UnificationError

X = Variable("X")
a = Atom("hello")

# Basic unification
subst = unify(X, a)
assert subst.get(X) == a

# Compound unification
t1 = Compound("f", [X, Atom("b")])
t2 = Compound("f", [Atom("a"), Variable("Y")])
subst = unify(t1, t2)
# X -> a, Y -> b
```

## DCG Support

Both emitters support Definite Clause Grammars:

```python
ir = {
    "module": "parser",
    "clauses": [],
    "dcg_rules": [
        {
            "head": {"kind": "compound", "functor": "sentence", "args": []},
            "body": [
                {"kind": "nonterminal", "term": {"kind": "compound", "functor": "noun_phrase", "args": []}},
                {"kind": "nonterminal", "term": {"kind": "compound", "functor": "verb_phrase", "args": []}}
            ]
        },
        {
            "head": {"kind": "compound", "functor": "noun_phrase", "args": []},
            "body": [
                {"kind": "terminal", "terminals": ["the"]},
                {"kind": "nonterminal", "term": {"kind": "compound", "functor": "noun", "args": []}}
            ]
        }
    ]
}
```

Generates:

```prolog
sentence --> noun_phrase, verb_phrase.
noun_phrase --> [the], noun.
```

## Testing

Run tests:

```bash
# Logic IR tests
python -m pytest tests/ir/test_logic_ir.py -v

# SWI-Prolog emitter tests
python -m pytest tests/codegen/test_swi_prolog_generator.py -v

# GNU Prolog emitter tests
python -m pytest tests/codegen/test_gnu_prolog_generator.py -v

# All Prolog tests
python -m pytest tests/codegen/test_*prolog*.py tests/ir/test_logic_ir.py -v
```

### YAP Prolog (`yap`)

High-performance Prolog target with tabling (memoization) support, generating code for [YAP Prolog](https://github.com/vscosta/yap-6.3).

**Features:**
- Module declarations (similar to SWI-Prolog)
- Tabling (memoization) with `:- table pred/N` directives
- Automatic recursive predicate detection for tabling
- Indexing directives for performance optimization
- Facts and rules
- DCG (Definite Clause Grammar) rules
- Cut (!) and negation-as-failure (\\+)
- Dynamic, multifile, and discontiguous predicates
- Thread-local predicates
- Type hints (PlDoc-style comments)
- Deterministic output for reproducibility

**Key Differences from SWI-Prolog:**

| Feature | SWI-Prolog | YAP Prolog |
|---------|------------|------------|
| Tabling | `:- table p/N` (library) | `:- table p/N` (optimized) |
| Indexing | Automatic | `:- index(pred, [Args])` |
| Performance | Good | Excellent (WAM optimized) |
| Threads | Library | Built-in |
| Attributed vars | Library | Built-in |

## Usage

### YAP Prolog Usage

```python
from targets.prolog.yap import YAPPrologEmitter, YAPPrologConfig

# Create emitter with tabling enabled (default)
config = YAPPrologConfig(
    enable_tabling=True,
    enable_indexing=True
)
emitter = YAPPrologEmitter(config)

# Define IR with recursive predicate (Fibonacci)
ir = {
    "module": "math",
    "clauses": [
        {"kind": "fact", "predicate": "fib", "args": [0, 0]},
        {"kind": "fact", "predicate": "fib", "args": [1, 1]},
        {"kind": "rule",
         "head": {"kind": "compound", "functor": "fib", "args": [
             {"kind": "variable", "name": "N"},
             {"kind": "variable", "name": "F"}
         ]},
         "body": [
             {"kind": "compound", "functor": ">", "args": [
                 {"kind": "variable", "name": "N"},
                 1
             ]},
             {"kind": "compound", "functor": "fib", "args": [
                 {"kind": "variable", "name": "N1"},
                 {"kind": "variable", "name": "F1"}
             ]},
             {"kind": "compound", "functor": "fib", "args": [
                 {"kind": "variable", "name": "N2"},
                 {"kind": "variable", "name": "F2"}
             ]}
         ]}
    ]
}

# Generate code
result = emitter.emit(ir)
print(result.code)
print(f"Tabled predicates: {result.tabled_predicates}")
print(f"Indexed predicates: {result.indexed_predicates}")
```

### YAP Prolog Output (with Tabling)

```prolog
/*
 * STUNIR Generated YAP Prolog Module
 * Module: math
 * Generated: 2026-01-29 10:30:00
 * Tabled predicates: 1
 * 
 * This file was automatically generated by STUNIR.
 * YAP Prolog target with tabling support.
 * Do not edit manually.
 */

:- module(stunir_math, [fib/2]).

% Tabling directives (memoization)
:- table fib/2.

%% fib/2 [tabled]

fib(0, 0).
fib(1, 1).
fib(N, F) :-
    N > 1,
    fib(N1, F1),
    fib(N2, F2).
```

### YAP Prolog Configuration Options

```python
config = YAPPrologConfig(
    module_prefix="myapp",       # Prefix for module names
    emit_module=True,            # Generate module declaration
    emit_comments=True,          # Generate header comments
    emit_type_hints=True,        # Generate %% pred/N hints
    indent="    ",               # Indentation string
    line_width=80,               # Line width limit
    enable_tabling=True,         # Auto-table recursive predicates
    tabling_mode='variant',      # Tabling mode: variant, subsumptive
    enable_indexing=True,        # Emit indexing directives
    auto_index_threshold=5,      # Min clauses to add indexing
    enable_thread_local=False,   # Thread-local predicates
    emit_timestamps=True,        # Include timestamp in header
    emit_sha256=True,            # Include hash in result
    file_extension=".pl",        # .pl or .yap
)

emitter = YAPPrologEmitter(config)
```

## Tabling Support (YAP Prolog)

YAP's tabling provides automatic memoization for recursive predicates, converting exponential-time algorithms to linear-time:

### Without Tabling (Exponential Time)

```prolog
% fib(30, X) takes ~1 million calls
fib(0, 0).
fib(1, 1).
fib(N, F) :-
    N > 1,
    N1 is N - 1, N2 is N - 2,
    fib(N1, F1), fib(N2, F2),
    F is F1 + F2.
```

### With Tabling (Linear Time)

```prolog
% fib(30, X) takes ~30 calls
:- table fib/2.
fib(0, 0).
fib(1, 1).
fib(N, F) :-
    N > 1,
    N1 is N - 1, N2 is N - 2,
    fib(N1, F1), fib(N2, F2),
    F is F1 + F2.
```

### Tabling Modes

| Mode | Description |
|------|-------------|
| `variant` | Default - cache based on variant calls |
| `subsumptive` | More aggressive caching |
| `lattice` | Aggregation tabling |
| `monotonic` | Incremental tabling |

## Indexing Directives (YAP Prolog)

YAP allows fine-grained control over clause indexing:

```python
# Explicit indexing annotation in IR
ir = {
    "module": "graph",
    "indexed": [
        {"predicate": "edge", "arity": 2, "args": [1, 2]}
    ],
    "clauses": [...]
}

# Generates:
# :- index(edge, [1, 2]).
```

### XSB Prolog (`xsb`)

Advanced Prolog target with sophisticated tabling features, generating code for [XSB Prolog](http://xsb.sourceforge.net/).

**Features:**
- Advanced tabling (more sophisticated than YAP)
- Incremental tabling (`:- table pred/N as incremental`)
- Answer subsumption (`:- table pred/N as subsumptive`)
- Well-founded semantics (WFS) for sound negation
- Lattice tabling for aggregation operations
- Different module syntax (`:- export(...)`, `:- import(...)`)
- Trie-based indexing
- DCG (Definite Clause Grammar) rules
- Cut (!) and tabled negation (tnot)
- Dynamic and multifile predicates
- Deterministic output for reproducibility

**Key Differences from YAP and SWI-Prolog:**

| Feature | SWI-Prolog | YAP Prolog | XSB Prolog |
|---------|------------|------------|------------|
| Module syntax | `:- module(Name, [])` | `:- module(Name, [])` | `:- export(pred/N)` |
| Module imports | `:- use_module()` | `:- use_module()` | `:- import(pred/N from mod)` |
| Incremental tabling | Not native | Limited | `:- table p/N as incremental` |
| Subsumptive | Library | `as subsumptive` | `:- table p/N as subsumptive` |
| Answer subsumption | Limited | Limited | Built-in |
| WFS | Limited | Limited | Built-in, automatic |
| Lattice tabling | Library | Library | `:- table p(_,_,lattice(op/3))` |
| Negation | NAF | NAF | WFS (sound) |
| File extension | `.pl` | `.pl` / `.yap` | `.P` (case-sensitive) |

## XSB Prolog Usage

```python
from targets.prolog.xsb import XSBPrologEmitter, XSBPrologConfig

# Create emitter with advanced tabling enabled
config = XSBPrologConfig(
    enable_tabling=True,
    auto_incremental=True,
    enable_wfs=True
)
emitter = XSBPrologEmitter(config)

# Define IR with dynamic graph and incremental tabling
ir = {
    "module": "graph",
    "dynamic": [{"predicate": "edge", "arity": 2}],
    "tabled": [{"predicate": "reachable", "arity": 2, "mode": "incremental"}],
    "clauses": [
        {"kind": "rule",
         "head": {"kind": "compound", "functor": "reachable", "args": [
             {"kind": "variable", "name": "X"},
             {"kind": "variable", "name": "Y"}
         ]},
         "body": [
             {"kind": "compound", "functor": "edge", "args": [
                 {"kind": "variable", "name": "X"},
                 {"kind": "variable", "name": "Y"}
             ]}
         ]},
        {"kind": "rule",
         "head": {"kind": "compound", "functor": "reachable", "args": [
             {"kind": "variable", "name": "X"},
             {"kind": "variable", "name": "Z"}
         ]},
         "body": [
             {"kind": "compound", "functor": "edge", "args": [
                 {"kind": "variable", "name": "X"},
                 {"kind": "variable", "name": "Y"}
             ]},
             {"kind": "compound", "functor": "reachable", "args": [
                 {"kind": "variable", "name": "Y"},
                 {"kind": "variable", "name": "Z"}
             ]}
         ]}
    ]
}

# Generate code
result = emitter.emit(ir)
print(result.code)
print(f"Tabled predicates: {result.tabled_predicates}")
print(f"Incremental predicates: {result.incremental_predicates}")
```

### XSB Prolog Output (with Incremental Tabling)

```prolog
/*
 * STUNIR Generated XSB Prolog Module
 * Module: graph
 * Generated: 2026-01-29 10:30:00
 * Tabled predicates: 1
 *   - Incremental: 1
 * 
 * This file was automatically generated by STUNIR.
 * XSB Prolog target with advanced tabling support.
 * Do not edit manually.
 */

% Exports
:- export(reachable/2).

:- dynamic edge/2 as incremental.

% Tabling directives (XSB advanced tabling)
:- table reachable/2 as incremental.

reachable(X, Y) :-
    edge(X, Y).
reachable(X, Z) :-
    edge(X, Y),
    reachable(Y, Z).
```

### XSB Prolog Configuration Options

```python
config = XSBPrologConfig(
    module_prefix="myapp",           # Prefix for module names
    emit_exports=True,               # Generate :- export directives
    emit_comments=True,              # Generate header comments
    emit_type_hints=True,            # Generate %% pred/N hints
    indent="    ",                   # Indentation string
    line_width=80,                   # Line width limit
    enable_tabling=True,             # Auto-table recursive predicates
    default_tabling_mode='variant',  # variant, incremental, subsumptive
    auto_incremental=True,           # Auto-detect incremental candidates
    auto_subsumptive=False,          # Auto-detect subsumptive candidates
    enable_wfs=True,                 # Enable well-founded semantics hints
    max_answers=None,                # Default max answers (None = unlimited)
    emit_timestamps=True,            # Include timestamp in header
    emit_sha256=True,                # Include hash in result
    file_extension=".P",             # XSB convention: .P (uppercase)
)

emitter = XSBPrologEmitter(config)
```

## XSB Advanced Tabling Modes

### Incremental Tabling

Allows dynamic updates to tabled predicates:

```prolog
:- table reachable/2 as incremental.
:- dynamic edge/2 as incremental.

reachable(X, Y) :- edge(X, Y).
reachable(X, Z) :- edge(X, Y), reachable(Y, Z).

% When edge facts change, reachable results update automatically
% assert(edge(a, b))   % Tables re-evaluated incrementally
% retract(edge(b, c))  % Tables updated
```

### Subsumptive Tabling

More aggressive answer caching:

```prolog
:- table ancestor/2 as subsumptive.

ancestor(X, Y) :- parent(X, Y).
ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).
```

### Lattice Tabling

Aggregation operations on tabled answers:

```prolog
% Shortest path with answer subsumption using min lattice
:- table shortest(_,_,min/3).

shortest(X, X, 0).
shortest(X, Z, D) :-
    edge(X, Y, W),
    shortest(Y, Z, D1),
    D is D1 + W.
```

### Well-Founded Semantics (WFS)

XSB implements well-founded semantics automatically for sound negation:

```prolog
:- table win/1.
:- table lose/1.

win(X) :- move(X, Y), tnot(lose(Y)).
lose(X) :- move(X, Y), tnot(win(Y)).

% XSB computes the well-founded model automatically
% Handles circular dependencies through three-valued logic:
% true, false, undefined
```

### Datalog (`datalog`)

Datalog target generating code for the Datalog query language - a pure, declarative subset of Prolog with guaranteed termination.

**Features:**
- Bottom-up evaluation semantics
- Stratified negation support
- Automatic stratification analysis
- Head restriction validation (no function symbols)
- Range restriction validation (safety checking)
- Set semantics (no duplicate results)
- Multiple dialect support (standard, Souffle)
- Deterministic output for reproducibility

**Key Differences from Prolog:**

| Feature | Prolog | Datalog |
|---------|--------|---------|
| Evaluation | Top-down (SLD) | Bottom-up (fixpoint) |
| Termination | May not terminate | Always terminates |
| Function symbols | Allowed anywhere | Only in rule bodies |
| Negation | NAF (`\+`) | Stratified (`not`) |
| Semantics | Bag (duplicates) | Set (no duplicates) |
| Cut operator | `!` allowed | Not allowed |
| Side effects | IO, assert/retract | Pure declarative |

## Datalog Usage

```python
from targets.prolog.datalog import DatalogEmitter, DatalogConfig, ValidationLevel

# Create emitter with default strict validation
emitter = DatalogEmitter()

# Define IR for family relationships
ir = {
    "module": "family",
    "predicates": [
        {"name": "parent", "clauses": [
            {"kind": "fact", "predicate": "parent",
             "args": [{"kind": "atom", "value": "tom"},
                     {"kind": "atom", "value": "bob"}]},
            {"kind": "fact", "predicate": "parent",
             "args": [{"kind": "atom", "value": "bob"},
                     {"kind": "atom", "value": "ann"}]}
        ]},
        {"name": "ancestor", "clauses": [
            # Base case
            {"kind": "rule",
             "head": {"kind": "compound", "functor": "ancestor",
                     "args": [{"kind": "variable", "name": "X"},
                             {"kind": "variable", "name": "Y"}]},
             "body": [
                 {"kind": "call",
                  "term": {"kind": "compound", "functor": "parent",
                          "args": [{"kind": "variable", "name": "X"},
                                  {"kind": "variable", "name": "Y"}]}}
             ]},
            # Recursive case
            {"kind": "rule",
             "head": {"kind": "compound", "functor": "ancestor",
                     "args": [{"kind": "variable", "name": "X"},
                             {"kind": "variable", "name": "Z"}]},
             "body": [
                 {"kind": "call",
                  "term": {"kind": "compound", "functor": "parent",
                          "args": [{"kind": "variable", "name": "X"},
                                  {"kind": "variable", "name": "Y"}]}},
                 {"kind": "call",
                  "term": {"kind": "compound", "functor": "ancestor",
                          "args": [{"kind": "variable", "name": "Y"},
                                  {"kind": "variable", "name": "Z"}]}}
             ]}
        ]}
    ]
}

# Generate code
result = emitter.emit(ir)
print(result.code)
print(f"Stratification: {result.stratification.strata}")
```

### Datalog Output

```prolog
%
% STUNIR Generated Datalog Program
% Module: family
% Generated: 2026-01-29 10:30:00
% 
% This file was automatically generated by STUNIR.
% Datalog: Bottom-up evaluation, stratified negation
%

% Facts
parent(tom, bob).
parent(bob, ann).

% Stratum 0: ancestor
ancestor(X, Y) :- parent(X, Y).
ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).
```

### Datalog with Stratified Negation

```python
ir = {
    "module": "birds",
    "predicates": [
        {"name": "bird", "clauses": [
            {"kind": "fact", "predicate": "bird",
             "args": [{"kind": "atom", "value": "tweety"}]}
        ]},
        {"name": "penguin", "clauses": [
            {"kind": "fact", "predicate": "penguin",
             "args": [{"kind": "atom", "value": "tux"}]}
        ]},
        {"name": "flies", "clauses": [
            {"kind": "rule",
             "head": {"kind": "compound", "functor": "flies",
                     "args": [{"kind": "variable", "name": "X"}]},
             "body": [
                 {"kind": "call",
                  "term": {"kind": "compound", "functor": "bird",
                          "args": [{"kind": "variable", "name": "X"}]}},
                 {"kind": "negation",
                  "inner": {"kind": "call",
                           "term": {"kind": "compound", "functor": "penguin",
                                   "args": [{"kind": "variable", "name": "X"}]}}}
             ]}
        ]}
    ]
}

# Generates:
# bird(tweety).
# penguin(tux).
# flies(X) :- bird(X), not penguin(X).
#
# Stratification: {bird: 0, penguin: 0, flies: 1}
```

### Datalog Configuration Options

```python
config = DatalogConfig(
    emit_comments=True,          # Generate header comments
    emit_timestamps=True,        # Include timestamp in header
    emit_sha256=True,            # Include hash in result
    validation_level=ValidationLevel.STRICT,  # STRICT, WARN, LENIENT
    check_range_restriction=True,  # Validate safety
    check_stratification=True,   # Validate negation
    file_extension=".dl",        # .dl or .datalog
    indent="    ",               # Indentation string
    line_width=80,               # Line width limit
    dialect="standard",          # standard, souffle
)

emitter = DatalogEmitter(config)
```

## Datalog Restrictions

### 1. Head Restriction (No Function Symbols)

Function symbols are not allowed in rule heads:

```python
# INVALID - function symbol 'succ' in head
{"kind": "rule",
 "head": {"kind": "compound", "functor": "nat",
         "args": [{"kind": "compound", "functor": "succ",
                  "args": [{"kind": "variable", "name": "X"}]}]},
 "body": [...]}
# Raises DatalogRestrictionError!

# VALID - only atoms/variables in head
{"kind": "rule",
 "head": {"kind": "compound", "functor": "nat",
         "args": [{"kind": "variable", "name": "X"}]},
 "body": [...]}
```

### 2. Range Restriction (Safety)

Every variable in the head must appear in a positive body literal:

```python
# INVALID - X not in positive body
{"kind": "rule",
 "head": {"kind": "compound", "functor": "unsafe",
         "args": [{"kind": "variable", "name": "X"}]},
 "body": [
     {"kind": "negation",
      "inner": {"kind": "call",
               "term": {"kind": "compound", "functor": "known",
                       "args": [{"kind": "variable", "name": "X"}]}}}
 ]}
# Raises DatalogRestrictionError!

# VALID - X in positive body
{"kind": "rule",
 "head": {"kind": "compound", "functor": "safe",
         "args": [{"kind": "variable", "name": "X"}]},
 "body": [
     {"kind": "call",
      "term": {"kind": "compound", "functor": "known",
              "args": [{"kind": "variable", "name": "X"}]}},
     {"kind": "negation",
      "inner": {"kind": "call",
               "term": {"kind": "compound", "functor": "excluded",
                       "args": [{"kind": "variable", "name": "X"}]}}}
 ]}
```

### 3. Stratified Negation

Negation must be stratifiable (no negative cycles):

```python
# INVALID - negative cycle between p and q
# p(X) :- not q(X).
# q(X) :- not p(X).
# Raises StratificationError!

# VALID - stratified negation
# bird(tweety).
# penguin(tux).
# flies(X) :- bird(X), not penguin(X).  # flies depends on penguin
```

## Stratification Algorithm

The emitter uses Tarjan's algorithm to find strongly connected components and detect negative cycles:

1. **Build dependency graph**: predicate → {(dependency, is_negated)}
2. **Find SCCs**: Using Tarjan's algorithm
3. **Check for negative cycles**: Within each SCC
4. **Assign strata**: Topological sort of SCCs

```python
result = emitter.stratify(ir)
print(f"Stratifiable: {result.is_stratifiable}")
print(f"Strata: {result.strata}")
print(f"Errors: {result.errors}")
```

### ECLiPSe (`eclipse`)

ECLiPSe is a powerful constraint logic programming system focused on **optimization** rather than just constraint satisfaction. It provides multiple constraint libraries (IC, FD, R, Q), advanced search strategies, and branch-and-bound optimization.

**Features:**
- Constraint optimization (minimize/maximize, bb_min/bb_max)
- Multiple CLP libraries:
  - IC (Interval Constraints) - Most powerful, handles reals and integers
  - FD (Finite Domain) - Classic CLP(FD) with # operators
  - R (Real numbers) - CLP(R)
  - Q (Rationals) - CLP(Q)
- Global constraints (alldifferent, element, cumulative)
- Advanced search strategies (search/6, labeling)
- Branch-and-bound optimization
- Module system with `:- module(name).`
- Uses `.ecl` file extension

**Key Differences from Other Prolog Systems:**

| Feature | GNU Prolog | SWI-Prolog | ECLiPSe |
|---------|------------|------------|---------|
| File extension | `.pl` | `.pl` | `.ecl` |
| Module syntax | None | `:- module(Name, [])` | `:- module(Name).` |
| CLP(FD) | Built-in `#=` | `library(clpfd)` `:in` | `lib(ic)` `$=` or `lib(fd)` `#=` |
| CLP(R) | Limited | `library(clpr)` | `lib(ic)` (unified) |
| Optimization | `fd_minimize` | `labeling([min(X)],...)` | `minimize/2`, `bb_min/3` |
| Search | `fd_labeling` | `labeling/2` | `search/6` (advanced) |
| Global constraints | `fd_all_different` | `all_different/1` | `alldifferent/1` |

## ECLiPSe Usage

```python
from targets.prolog.eclipse import ECLiPSeEmitter, ECLiPSeConfig

# Create emitter with IC library (default, most powerful)
config = ECLiPSeConfig(
    default_library='ic',
    use_ic_global=True,
    use_branch_bound=True
)
emitter = ECLiPSeEmitter(config)

# Define IR with constraint optimization
ir = {
    "module": "scheduling",
    "clauses": [
        {"kind": "rule",
         "head": {"kind": "compound", "functor": "solve", "args": [
             {"kind": "variable", "name": "Tasks"},
             {"kind": "variable", "name": "Cost"}
         ]},
         "body": [
             # Define domains: X :: 1..10
             {"kind": "compound", "functor": "::", "args": [
                 {"kind": "variable", "name": "Tasks"},
                 {"kind": "compound", "functor": "..", "args": [
                     {"kind": "number", "value": 1},
                     {"kind": "number", "value": 10}
                 ]}
             ]},
             # All different constraint
             {"kind": "compound", "functor": "alldifferent", "args": [
                 {"kind": "variable", "name": "Tasks"}
             ]},
             # Minimize the cost
             {"kind": "compound", "functor": "minimize", "args": [
                 {"kind": "compound", "functor": "labeling", "args": [
                     {"kind": "variable", "name": "Tasks"}
                 ]},
                 {"kind": "variable", "name": "Cost"}
             ]}
         ]}
    ]
}

# Generate code
result = emitter.emit(ir)
print(result.code)
print(f"Libraries used: {result.libraries_used}")
print(f"Has optimization: {result.has_optimization}")
```

### ECLiPSe Output (with Optimization)

```prolog
/*
 * STUNIR Generated ECLiPSe Source
 * Module: scheduling
 * Generated: 2026-01-29 10:30:00
 * Libraries: branch_and_bound, ic, ic_global
 * Features: Constraint Optimization
 * 
 * This file was automatically generated by STUNIR.
 * Run with: eclipse -b file.ecl -e 'main'
 * Do not edit manually.
 */

:- module(scheduling).

% Library imports
:- lib(branch_and_bound).
:- lib(ic).
:- lib(ic_global).

% Exported predicates
:- export(solve/2).

solve(Tasks, Cost) :-
    Tasks :: 1..10,
    alldifferent(Tasks),
    minimize(labeling(Tasks), Cost).
```

### ECLiPSe Configuration Options

```python
config = ECLiPSeConfig(
    module_prefix="myapp",          # Prefix for module names
    emit_comments=True,             # Generate header comments
    emit_timestamps=True,           # Include timestamp in header
    indent="    ",                  # Indentation string
    line_width=80,                  # Line width limit
    
    # Library selection (IC is recommended default)
    default_library="ic",           # Primary constraint library: ic|fd
    use_ic_global=True,             # Use lib(ic_global) for global constraints
    use_ic_search=True,             # Use lib(ic_search) for advanced search
    use_branch_bound=True,          # Use lib(branch_and_bound)
    
    # Search defaults
    default_select="first_fail",    # Default variable selection
    default_choice="indomain_middle",  # Default value selection
    
    # Optimization
    enable_optimization=True,       # Enable minimize/maximize
    optimization_timeout=None,      # Timeout in seconds (None = unlimited)
)

emitter = ECLiPSeEmitter(config)
```

## ECLiPSe Constraint Libraries

### IC Library (Interval Constraints - Recommended)

The IC library is the most powerful, handling both integers and reals:

```python
# IC uses $ prefix for constraints
# Domain: X :: 1..9
# Constraint: X $= Y + 1
# Not equal: X $\= Y
```

### FD Library (Finite Domains)

Classic CLP(FD) with # operators (like GNU Prolog):

```python
# FD uses # prefix for constraints  
# Domain: X :: 1..9
# Constraint: X #= Y + 1
# Not equal: X #\= Y

# Use FD library:
config = ECLiPSeConfig(default_library='fd')
```

### Global Constraints

```python
# alldifferent - all values must be different
{"kind": "compound", "functor": "alldifferent", "args": [
    {"kind": "variable", "name": "List"}
]}
# Generates: alldifferent(List)

# element - constraint indexing into a list
{"kind": "compound", "functor": "element", "args": [
    {"kind": "variable", "name": "I"},
    {"kind": "list_term", "elements": [...]},
    {"kind": "variable", "name": "E"}
]}
# Generates: element(I, [1,2,3], E)
```

## ECLiPSe Optimization

### Minimize/Maximize

```python
# Minimize cost
{"kind": "compound", "functor": "minimize", "args": [
    {"kind": "compound", "functor": "solve", "args": [...]},
    {"kind": "variable", "name": "Cost"}
]}
# Generates: minimize(solve(...), Cost)

# Maximize profit
{"kind": "compound", "functor": "maximize", "args": [
    {"kind": "compound", "functor": "compute", "args": [...]},
    {"kind": "variable", "name": "Profit"}
]}
# Generates: maximize(compute(...), Profit)
```

### Branch-and-Bound (bb_min, bb_max)

More control over optimization with options:

```python
{"kind": "compound", "functor": "bb_min", "args": [
    {"kind": "compound", "functor": "solve", "args": [...]},
    {"kind": "variable", "name": "Cost"}
]}
# Generates: bb_min(solve(...), Cost, bb_options{})
```

## ECLiPSe Search Strategies

### Simple Labeling

```python
{"kind": "compound", "functor": "labeling", "args": [
    {"kind": "variable", "name": "Vars"}
]}
# Generates: labeling(Vars)
```

### Advanced Search (search/6)

```python
# search(Vars, ArgNo, Select, Choice, Method, Options)
{"kind": "compound", "functor": "search", "args": [
    {"kind": "variable", "name": "Vars"},
    {"kind": "number", "value": 0},
    {"kind": "atom", "value": "first_fail"},
    {"kind": "atom", "value": "indomain_middle"}
]}
# Generates: search(Vars, 0, first_fail, indomain_middle, complete, [])
```

### Variable Selection Methods

| Method | Description |
|--------|-------------|
| `first_fail` | Variable with smallest domain first |
| `most_constrained` | Variable with most constraints first |
| `occurrence` | Variable appearing in most constraints |
| `input_order` | Process variables in order given |
| `max_regret` | Largest difference between two smallest values |

### Value Choice Methods

| Method | Description |
|--------|-------------|
| `indomain` | Try values in increasing order |
| `indomain_middle` | Try middle value first |
| `indomain_min` | Try minimum value first |
| `indomain_max` | Try maximum value first |
| `indomain_split` | Binary domain splitting |

### Mercury (`mercury`)

Mercury is a pure declarative logic/functional programming language designed for reliable software with compile-time type checking. Unlike traditional Prolog, Mercury requires **mandatory type, mode, and determinism declarations**.

**Features:**
- Strong static typing with type inference
- Mode declarations (in, out, in_out, di, uo)
- Determinism declarations (det, semidet, multi, nondet)
- Module system with interface/implementation sections
- Functions (in addition to predicates)
- Purity tracking (pure, semipure, impure)
- Compile-time type checking
- Higher-order predicates and functions

**Key Differences from Traditional Prolog:**

| Feature | Prolog | Mercury |
|---------|--------|---------|
| Type declarations | Optional | **Mandatory** |
| Mode declarations | None | **Mandatory** |
| Determinism | Implicit | **Mandatory** |
| Dynamic predicates | `assert/retract` | **Not supported** |
| Cut operator | `!` | Limited |
| Module system | Varies | Strict interface/impl |
| Type checking | Runtime | **Compile-time** |
| Purity | Not tracked | pure/semipure/impure |

## Mercury Usage

```python
from targets.prolog.mercury import MercuryEmitter, MercuryConfig

# Create emitter with config
config = MercuryConfig(
    module_prefix="my",
    emit_comments=True,
    infer_determinism=True
)
emitter = MercuryEmitter(config)

# Define IR
ir = {
    "module": "math",
    "types": [
        {
            "name": "result",
            "kind": "enum",
            "constructors": ["ok", "error"]
        }
    ],
    "predicates": [{
        "name": "add",
        "clauses": [{
            "kind": "rule",
            "head": {"kind": "compound", "functor": "add", "args": [
                {"kind": "variable", "name": "X"},
                {"kind": "variable", "name": "Y"},
                {"kind": "variable", "name": "Z"}
            ]},
            "body": [{
                "kind": "unification",
                "left": {"kind": "variable", "name": "Z"},
                "right": {"kind": "compound", "functor": "+", "args": [
                    {"kind": "variable", "name": "X"},
                    {"kind": "variable", "name": "Y"}
                ]}
            }]
        }]
    }],
    "functions": [{
        "name": "double",
        "params": [{"name": "X", "type": "i32"}],
        "return_type": "i32",
        "body": {"kind": "binary_op", "op": "*",
                 "left": {"kind": "var", "name": "X"},
                 "right": {"kind": "literal", "value": 2}}
    }]
}

# Generate code
result = emitter.emit(ir)
print(result.code)
```

### Mercury Output

```mercury
%--------------------------------------------------------------------------%
% STUNIR Generated Mercury Module
% Module: math
% Generated: 2026-01-29 12:00:00
%--------------------------------------------------------------------------%

:- module my_math.

:- interface.

:- type result ---> ok ; error.

:- pred add(int::in, int::in, int::out) is det.

:- func double(int) = int is det.

:- implementation.

:- import_module int.

% add/3
add(X, Y, Z) :-
    Z = X + Y.

double(X) = X * 2.

:- end_module my_math.
```

### Mercury Configuration Options

| Option | Default | Description |
|--------|---------|-------------|
| `module_prefix` | `"stunir"` | Prefix for module names |
| `emit_interface` | `True` | Emit `:- interface.` section |
| `emit_implementation` | `True` | Emit `:- implementation.` section |
| `emit_comments` | `True` | Emit documentation comments |
| `emit_type_declarations` | `True` | Emit `:- type` declarations |
| `emit_pred_declarations` | `True` | Emit `:- pred` declarations |
| `emit_func_declarations` | `True` | Emit `:- func` declarations |
| `emit_determinism` | `True` | Emit determinism annotations |
| `infer_types` | `True` | Auto-infer types from IR |
| `infer_modes` | `True` | Auto-infer modes |
| `infer_determinism` | `True` | Auto-infer determinism |
| `default_determinism` | `"det"` | Default if cannot infer |
| `emit_end_module` | `True` | Emit `:- end_module` |

## Mercury Type System

### Type Declarations

```mercury
% Enumeration type
:- type color ---> red ; green ; blue.

% Parametric type
:- type maybe(T) ---> yes(T) ; no.

% Record type
:- type point ---> point(x :: int, y :: int).
```

### Type Mapping (IR → Mercury)

| IR Type | Mercury Type |
|---------|--------------|
| `i32`, `i64` | `int` |
| `f32`, `f64` | `float` |
| `bool` | `bool` |
| `string` | `string` |
| `char` | `char` |
| `list(T)` | `list(T)` |
| `void` | `{}` (unit) |
| `any` | `univ` |

## Mercury Mode System

Modes describe argument instantiation:

| Mode | Symbol | Description |
|------|--------|-------------|
| Input | `in` | Must be ground on call |
| Output | `out` | Free on call, ground on success |
| In/Out | `in_out` | Ground, may be more ground |
| Unique input | `ui` | Unique, destroyed by call |
| Unique output | `uo` | Created uniquely |
| Dead input | `di` | Dead after call |

### Mode Declaration Syntax

```mercury
:- pred append(list(T), list(T), list(T)).
:- mode append(in, in, out) is det.
:- mode append(out, out, in) is multi.
```

## Mercury Determinism

| Determinism | Solutions | Can Fail? | Use Case |
|-------------|-----------|-----------|----------|
| `det` | Exactly 1 | No | Most functions |
| `semidet` | 0 or 1 | Yes | Lookup, search |
| `multi` | ≥1 | No | Generators |
| `nondet` | ≥0 | Yes | Backtracking |
| `failure` | 0 | Always | Error paths |
| `erroneous` | N/A | Never returns | Exceptions |
| `cc_multi` | ≥1, committed | No | First solution |
| `cc_nondet` | ≥0, committed | Yes | First if exists |

### Determinism Declaration Syntax

```mercury
:- pred lookup(key, map, value).
:- mode lookup(in, in, out) is semidet.  % May fail

:- pred member(T, list(T)).
:- mode member(out, in) is nondet.  % Multiple solutions
```

## Future Targets

- SICStus Prolog
- Ciao Prolog
- Souffle (specialized Datalog)

## Testing

Run tests:

```bash
# Logic IR tests
python -m pytest tests/ir/test_logic_ir.py -v

# SWI-Prolog emitter tests
python -m pytest tests/codegen/test_swi_prolog_generator.py -v

# GNU Prolog emitter tests
python -m pytest tests/codegen/test_gnu_prolog_generator.py -v

# YAP Prolog emitter tests
python -m pytest tests/codegen/test_yap_generator.py -v

# XSB Prolog emitter tests
python -m pytest tests/codegen/test_xsb_generator.py -v

# Datalog emitter tests
python -m pytest tests/codegen/test_datalog_generator.py -v

# ECLiPSe emitter tests
python -m pytest tests/codegen/test_eclipse_generator.py -v

# Mercury emitter tests
python -m pytest tests/codegen/test_mercury_generator.py -v

# All Prolog tests
python -m pytest tests/codegen/test_*prolog*.py tests/codegen/test_yap*.py tests/codegen/test_xsb*.py tests/codegen/test_datalog*.py tests/codegen/test_eclipse*.py tests/codegen/test_mercury*.py tests/ir/test_logic_ir.py -v
```

## See Also

- [SWI-Prolog Documentation](https://www.swi-prolog.org/pldoc/)
- [GNU Prolog Manual](http://www.gprolog.org/manual/gprolog.html)
- [Mercury Language Reference](https://mercurylang.org/documentation/)
- [Logic IR Schema](../../schemas/logic_ir.json)
- [Logic IR Implementation](../../tools/ir/logic_ir.py)


### Tau Prolog (`tau_prolog`)

Tau Prolog is a **JavaScript-based Prolog implementation** that runs natively in web browsers and Node.js. It provides full ISO Prolog compatibility while adding unique features for JavaScript interoperability and DOM manipulation.

**Features:**
- JavaScript-based execution (runs in browser and Node.js)
- ISO Prolog compliant syntax
- Module system (`:- use_module(library(X)).`)
- JavaScript interoperability (`apply/4`, `prop/3`, `global/2`)
- DOM manipulation predicates (browser only)
- Standard libraries (lists, strings, format, etc.)
- Async/Promise-based query execution
- Deterministic output for reproducibility

**Key Differences from Traditional Prolog:**

| Feature | Traditional Prolog | Tau Prolog |
|---------|-------------------|------------|
| Runtime | Native binary | JavaScript |
| Browser support | No | **Yes** |
| Node.js support | No | **Yes** |
| DOM manipulation | No | **Yes** (via `dom` library) |
| JS interop | No | **Yes** (via `js` library) |
| Compilation | Native compilation | Interpreted |
| CLP support | Full (varies) | Limited |

## Tau Prolog Usage

### Basic Usage

```python
from targets.prolog.tau_prolog import TauPrologEmitter, TauPrologConfig

# Create emitter with default config
emitter = TauPrologEmitter()

# Define IR
ir = {
    "module": "family",
    "exports": [{"predicate": "grandparent", "arity": 2}],
    "clauses": [
        {"kind": "fact", "predicate": "parent", "args": [
            {"kind": "atom", "value": "tom"},
            {"kind": "atom", "value": "bob"}
        ]},
        {"kind": "rule",
         "head": {"kind": "compound", "functor": "grandparent", "args": [
             {"kind": "variable", "name": "X"},
             {"kind": "variable", "name": "Z"}
         ]},
         "body": [
             {"kind": "compound", "functor": "parent", "args": [
                 {"kind": "variable", "name": "X"},
                 {"kind": "variable", "name": "Y"}
             ]},
             {"kind": "compound", "functor": "parent", "args": [
                 {"kind": "variable", "name": "Y"},
                 {"kind": "variable", "name": "Z"}
             ]}
         ]}
    ]
}

# Generate code
result = emitter.emit(ir)
print(result.code)
print(f"Libraries used: {result.libraries_used}")
print(f"Has DOM: {result.has_dom}")
print(f"Has JS interop: {result.has_js_interop}")
```

### Tau Prolog Output

```prolog
/*
 * STUNIR Generated Tau Prolog Module
 * Module: family
 * Generated: 2026-01-29 10:30:00
 * Target Runtime: browser
 * Libraries: lists
 * 
 * This file was automatically generated by STUNIR.
 * Tau Prolog: JavaScript-based Prolog for browsers and Node.js
 * https://tau-prolog.org/
 * Do not edit manually.
 */

:- module(stunir_family, [grandparent/2, parent/2]).

:- use_module(library(lists)).

%% grandparent/2
%% parent/2

parent(tom, bob).

grandparent(X, Z) :-
    parent(X, Y),
    parent(Y, Z).
```

### Tau Prolog Configuration Options

```python
config = TauPrologConfig(
    module_prefix="myapp",          # Prefix for module names
    emit_module=True,               # Generate module declaration
    emit_comments=True,             # Generate header comments
    emit_type_hints=True,           # Generate %% pred/N hints
    indent="    ",                  # Indentation string
    line_width=80,                  # Line width limit
    
    # Tau Prolog specific options
    enable_dom=False,               # Include DOM predicates
    enable_js_interop=True,         # Enable JavaScript interop
    target_runtime="browser",       # "browser" or "node"
    emit_loader_js=False,           # Emit JavaScript loader code
    
    # Library options
    auto_include_libraries=True,    # Auto-detect needed libraries
    default_libraries=['lists'],    # Default libraries to include
    
    # Output options
    emit_timestamps=True,           # Include timestamp in header
    emit_sha256=True,               # Include hash in result
)

emitter = TauPrologEmitter(config)
```

## JavaScript Interoperability

### Calling JavaScript Functions

```python
# IR for calling console.log
ir = {
    "module": "jstest",
    "clauses": [
        {"kind": "rule",
         "head": {"kind": "compound", "functor": "log_message", "args": [
             {"kind": "variable", "name": "Msg"}
         ]},
         "body": [
             {"kind": "compound", "functor": "global", "args": [
                 {"kind": "atom", "value": "console"},
                 {"kind": "variable", "name": "C"}
             ]},
             {"kind": "compound", "functor": "apply", "args": [
                 {"kind": "variable", "name": "C"},
                 {"kind": "atom", "value": "log"},
                 {"kind": "list_term", "elements": [
                     {"kind": "variable", "name": "Msg"}
                 ]},
                 {"kind": "anonymous"}
             ]}
         ]}
    ]
}
```

Generates:

```prolog
:- use_module(library(js)).

log_message(Msg) :-
    global(console, C),
    apply(C, log, [Msg], _).
```

### JavaScript Predicates

| Predicate | Arity | Description |
|-----------|-------|-------------|
| `global/2` | 2 | Get global JS object (`global(console, C)`) |
| `apply/4` | 4 | Call JS method (`apply(Obj, Method, Args, Result)`) |
| `prop/3` | 3 | Get JS property (`prop(Obj, Prop, Value)`) |
| `set_prop/3` | 3 | Set JS property |
| `new/3` | 3 | Create new JS object (`new(Constructor, Args, Instance)`) |
| `json_prolog/2` | 2 | Convert JSON string to Prolog term |
| `prolog_json/2` | 2 | Convert Prolog term to JSON string |

## DOM Manipulation (Browser Only)

### DOM Predicates

```python
config = TauPrologConfig(enable_dom=True, target_runtime="browser")
emitter = TauPrologEmitter(config)

# IR for DOM manipulation
ir = {
    "module": "ui",
    "clauses": [
        {"kind": "rule",
         "head": {"kind": "compound", "functor": "set_output", "args": [
             {"kind": "variable", "name": "Text"}
         ]},
         "body": [
             {"kind": "compound", "functor": "get_by_id", "args": [
                 {"kind": "atom", "value": "output"},
                 {"kind": "variable", "name": "E"}
             ]},
             {"kind": "compound", "functor": "set_html", "args": [
                 {"kind": "variable", "name": "E"},
                 {"kind": "variable", "name": "Text"}
             ]}
         ]}
    ]
}
```

Generates:

```prolog
:- use_module(library(dom)).

set_output(Text) :-
    get_by_id(output, E),
    set_html(E, Text).
```

### Available DOM Predicates

| Predicate | Arity | Description |
|-----------|-------|-------------|
| `get_by_id/2` | 2 | Get element by ID |
| `get_by_class/2` | 2 | Get elements by class |
| `get_by_tag/2` | 2 | Get elements by tag name |
| `create/2` | 2 | Create new element |
| `get_html/2` | 2 | Get element's innerHTML |
| `set_html/2` | 2 | Set element's innerHTML |
| `get_attr/3` | 3 | Get element attribute |
| `set_attr/3` | 3 | Set element attribute |
| `append_child/2` | 2 | Append child element |
| `remove_child/2` | 2 | Remove child element |
| `bind/4` | 4 | Bind event handler |
| `unbind/2` | 2 | Unbind event handler |

## Browser Integration Example

### HTML Usage

```html
<!DOCTYPE html>
<html>
<head>
    <title>Tau Prolog Demo</title>
    <script src="https://cdn.tau-prolog.org/tau-prolog.js"></script>
    <script src="https://cdn.tau-prolog.org/modules/lists.js"></script>
    <script src="https://cdn.tau-prolog.org/modules/dom.js"></script>
</head>
<body>
    <div id="output"></div>
    <script>
        // STUNIR Generated Tau Prolog Program (paste generated code here)
        const program = `
            :- module(stunir_demo, [factorial/2, show_result/1]).
            :- use_module(library(lists)).
            :- use_module(library(dom)).
            
            factorial(0, 1).
            factorial(N, F) :-
                N > 0,
                N1 is N - 1,
                factorial(N1, F1),
                F is N * F1.
            
            show_result(N) :-
                factorial(N, F),
                get_by_id(output, E),
                atom_concat('Result: ', F, Text),
                set_html(E, Text).
        `;
        
        // Create Tau Prolog session
        const session = pl.create();
        session.consult(program);
        
        // Execute query
        session.query("show_result(5).");
        session.answer(answer => console.log(pl.format_answer(answer)));
    </script>
</body>
</html>
```

### Node.js Usage

```javascript
// STUNIR Generated Tau Prolog for Node.js
const pl = require("tau-prolog");
require("tau-prolog/modules/lists")(pl);

const program = `
    :- module(stunir_demo, [fibonacci/2]).
    :- use_module(library(lists)).
    
    fibonacci(0, 0).
    fibonacci(1, 1).
    fibonacci(N, F) :-
        N > 1,
        N1 is N - 1,
        N2 is N - 2,
        fibonacci(N1, F1),
        fibonacci(N2, F2),
        F is F1 + F2.
`;

const session = pl.create();
session.consult(program);

session.query("fibonacci(10, X).");
session.answer(answer => {
    console.log(pl.format_answer(answer));
    // X = 55
});
```

## JavaScript Loader Generation

The Tau Prolog emitter can optionally generate JavaScript loader code:

```python
config = TauPrologConfig(
    emit_loader_js=True,
    target_runtime="browser"  # or "node"
)
emitter = TauPrologEmitter(config)

result = emitter.emit(ir)

# Prolog code
print(result.code)

# JavaScript loader code
print(result.loader_js)
```

## Testing

Run Tau Prolog tests:

```bash
# Tau Prolog emitter tests
python -m pytest tests/codegen/test_tau_prolog_generator.py -v

# All Prolog tests
python -m pytest tests/codegen/test_*prolog*.py -v
```

## Available Libraries

Tau Prolog provides these standard libraries:

| Library | Description | Platform |
|---------|-------------|----------|
| `lists` | List operations (append, member, etc.) | All |
| `apply` | Meta-call predicates | All |
| `assoc` | Association lists | All |
| `charsio` | Character I/O | All |
| `dom` | DOM manipulation | Browser only |
| `format` | String formatting | All |
| `js` | JavaScript interop | All |
| `os` | OS operations | Node.js only |
| `random` | Random number generation | All |
| `statistics` | Runtime statistics | All |
| `strings` | String operations | All |

## References

- Tau Prolog website: https://tau-prolog.org/
- Documentation: http://tau-prolog.org/documentation
- CDN: https://cdn.tau-prolog.org/
- GitHub: https://github.com/tau-prolog/tau-prolog
