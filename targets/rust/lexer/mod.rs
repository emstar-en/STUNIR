//! Lexer emitter module
//!
//! Lexer/tokenizer generator for multiple languages
//!
//! Generated by: STUNIR Emitter Generator v1.0
//! Timestamp: 2026-01-31T02:44:18.376788Z

use crate::types::*;

/// Lexer configuration
#[derive(Debug, Clone)]
pub struct LexerConfig {
    pub indent_width: usize,
    pub validate: bool,
}

impl Default for LexerConfig {
    fn default() -> Self {
        Self {
            indent_width: 2,
            validate: true,
        }
    }
}

/// Type mapping from IR to Lexer
fn map_ir_type(ir_type: &str) -> &'static str {
    match ir_type {
        "i32" => "int32",
        "i64" => "int64",
        "f32" => "float",
        "f64" => "double",
        "bool" => "boolean",
        "string" => "string",
        _ => "int32",
    }
}

/// Emit function code
pub fn emit_function(
    func_name: &str,
    params: &str,
    body: &str,
) -> EmitterResult<String> {
    let mut code = String::new();
    
    code.push_str(&format!("function {}({}) {{\n", func_name, params));
    code.push_str(body);
    code.push_str("\n}\n");
    
    Ok(code)
}

/// Emit complete module
pub fn emit_module(
    module_name: &str,
    _config: &LexerConfig,
) -> EmitterResult<String> {
    let mut code = String::new();
    
    // Header comments
    code.push_str("/* STUNIR Generated Lexer Code */\n");
    code.push_str(&format!("/* Module: {} */\n", module_name));
    code.push_str("/* Generator: Rust Pipeline */\n");
    code.push_str("\n");
    
    // Module body
    code.push_str("// Lexer implementation goes here\n");
    
    Ok(code)
}

/// Main emit entry point
pub fn emit(
    module_name: &str,
) -> EmitterResult<String> {
    let config = LexerConfig::default();
    emit_module(module_name, &config)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_type_mapping() {
        assert_eq!(map_ir_type("i32"), "int32");
        assert_eq!(map_ir_type("bool"), "boolean");
    }

    #[test]
    fn test_emit_function() {
        let result = emit_function("test", "a, b", "    return a + b;");
        assert!(result.is_ok());
        let code = result.unwrap();
        assert!(code.contains("function test"));
    }

    #[test]
    fn test_emit_module() {
        let config = LexerConfig::default();
        let result = emit_module("test_module", &config);
        assert!(result.is_ok());
        let code = result.unwrap();
        assert!(code.contains("STUNIR Generated"));
    }
}
