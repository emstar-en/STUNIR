#!/usr/bin/env python3
"""STUNIR Guile (GNU Scheme) Emitter.

Generates GNU Guile code from STUNIR IR.
Supports module system, GOOPS, and FFI.

Part of Phase 5B: Extended Lisp Implementation.
"""

import time
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional, Set

from ..base import LispEmitterBase, LispEmitterConfig, EmitterResult, compute_sha256, canonical_json
from .types import GuileTypeMapper, GUILE_TYPES


@dataclass
class GuileConfig(LispEmitterConfig):
    """Guile specific configuration."""
    emit_goops: bool = True         # Generate GOOPS classes
    emit_ffi: bool = False          # Generate FFI bindings
    r7rs_mode: bool = False         # R7RS compatibility
    guile_version: str = "3.0"      # Target Guile version


class GuileEmitter(LispEmitterBase):
    """Emitter for GNU Guile code.
    
    Generates valid Guile code with:
    - Module system (define-module)
    - GOOPS class generation
    - FFI bindings for native interop
    - R7RS compatibility mode option
    """
    
    DIALECT = "guile"
    FILE_EXTENSION = ".scm"
    
    # Guile specific operators
    BINARY_OPS = {
        '+': '+',
        '-': '-',
        '*': '*',
        '/': '/',
        '%': 'modulo',
        '==': '=',
        '!=': 'not (=',  # Special handling needed
        '<': '<',
        '>': '>',
        '<=': '<=',
        '>=': '>=',
        'and': 'and',
        'or': 'or',
        '&': 'logand',
        '|': 'logior',
        '^': 'logxor',
    }
    
    def __init__(self, config: GuileConfig):
        """Initialize Guile emitter.
        
        Args:
            config: Guile emitter configuration.
        """
        super().__init__(config)
        self.config: GuileConfig = config
        self.type_mapper = GuileTypeMapper(config.emit_goops)
        self._exports: Set[str] = set()
    
    def emit(self, ir: Dict[str, Any]) -> EmitterResult:
        """Emit Guile code from IR.
        
        Args:
            ir: STUNIR IR dictionary.
            
        Returns:
            EmitterResult with generated code.
        """
        module_name = self._lisp_name(ir.get('module', 'unnamed'))
        
        # Collect exports
        self._exports = set()
        for func in ir.get('functions', []):
            if func.get('exported', True):
                self._exports.add(self._lisp_name(func.get('name', '')))
        for export in ir.get('exports', []):
            self._exports.add(self._lisp_name(export))
        
        # Build code sections
        sections = []
        
        # Header
        sections.append(self._emit_header(module_name))
        
        # Module definition
        sections.append(self._emit_module_def(module_name, ir))
        
        # Type definitions (GOOPS classes)
        if self.config.emit_goops:
            for type_def in ir.get('types', []):
                sections.append(self._emit_goops_class(type_def))
        
        # Functions
        for func in ir.get('functions', []):
            sections.append(self._emit_function(func))
        
        code = "\n\n".join(filter(None, sections))
        
        # Write main file
        main_file = f"{module_name}.scm"
        self._write_file(main_file, code)
        
        return EmitterResult(
            code=code,
            files={main_file: code},
            manifest=self._generate_manifest(ir)
        )
    
    def _emit_header(self, module_name: str) -> str:
        """Emit file header comment."""
        lines = [
            f";;; Generated by STUNIR Guile Emitter",
            f";;; Module: {module_name}",
            f";;; Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}",
        ]
        return "\n".join(lines)
    
    def _emit_module_def(self, module_name: str, ir: Dict[str, Any]) -> str:
        """Emit module definition."""
        prefix = self.config.module_prefix
        
        lines = [f"(define-module ({prefix} {module_name})"]
        
        # Use modules
        if self.config.emit_goops:
            lines.append("  #:use-module (oop goops)")
        if self.config.emit_ffi:
            lines.append("  #:use-module (system foreign)")
        
        # Imports
        for imp in ir.get('imports', []):
            name = self._lisp_name(imp.get('module', imp.get('name', '')))
            lines.append(f"  #:use-module ({prefix} {name})")
        
        # Exports
        if self._exports:
            exports = ' '.join(sorted(self._exports))
            lines.append(f"  #:export ({exports}))")
        else:
            lines.append(")")
        
        return "\n".join(lines)
    
    def _emit_goops_class(self, type_def: Dict[str, Any]) -> str:
        """Emit a GOOPS class definition."""
        name = self._lisp_name(type_def.get('name', 'unnamed'))
        fields = type_def.get('fields', [])
        docstring = type_def.get('docstring', '')
        
        # GOOPS uses angle brackets for class names
        class_name = f"<{name}>"
        
        lines = [f"(define-class {class_name} ()"]
        
        # Slots
        for field in fields:
            fname = self._lisp_name(field.get('name', 'field'))
            lines.append(f"  ({fname}")
            lines.append(f"   #:init-keyword #:{fname}")
            lines.append(f"   #:accessor {name}-{fname})")
        
        if docstring:
            lines.append(f'  #:documentation "{docstring}")')
        else:
            # Close the class definition
            if lines[-1].endswith(')'):
                lines[-1] = lines[-1][:-1] + '))'  # Double close
            else:
                lines.append(")")
        
        return "\n".join(lines)
    
    def _emit_function(self, func: Dict[str, Any]) -> str:
        """Emit a function definition."""
        name = self._lisp_name(func.get('name', 'unnamed'))
        params = func.get('params', [])
        body = func.get('body', [])
        docstring = func.get('docstring', func.get('doc', ''))
        
        # Parameter list
        param_names = ' '.join(self._lisp_name(p.get('name', '_')) for p in params)
        
        # Build function
        lines = [f"(define ({name} {param_names})" if param_names else f"(define ({name})"]
        
        # Docstring
        if docstring:
            lines.append(f'  "{docstring}"')
        
        # Body
        if body:
            for stmt in body:
                stmt_str = self._emit_statement(stmt)
                lines.append(f"  {stmt_str}")
        else:
            lines.append("  *unspecified*")
        
        lines.append(")")
        
        return "\n".join(lines)
    
    def _emit_var_decl(self, stmt: Dict[str, Any]) -> str:
        """Emit variable declaration using define or let."""
        name = self._lisp_name(stmt.get('name', '_'))
        value = stmt.get('value', stmt.get('init'))
        
        if value is not None:
            val_str = self._emit_expression(value)
            return f"(define {name} {val_str})"
        return f"(define {name} #f)"
    
    def _emit_assignment(self, stmt: Dict[str, Any]) -> str:
        """Emit assignment statement using set!."""
        name = self._lisp_name(stmt.get('name', stmt.get('target', '_')))
        value = self._emit_expression(stmt.get('value', {}))
        return f"(set! {name} {value})"
    
    def _emit_if_stmt(self, stmt: Dict[str, Any]) -> str:
        """Emit if statement."""
        cond = self._emit_expression(stmt.get('condition', stmt.get('cond', {})))
        then_body = stmt.get('then', stmt.get('consequent', []))
        else_body = stmt.get('else', stmt.get('alternate', []))
        
        # Handle body as list or single statement
        if isinstance(then_body, list):
            if len(then_body) == 1:
                then_str = self._emit_statement(then_body[0])
            elif then_body:
                then_stmts = ' '.join(self._emit_statement(s) for s in then_body)
                then_str = f"(begin {then_stmts})"
            else:
                then_str = '*unspecified*'
        else:
            then_str = self._emit_statement(then_body)
        
        if else_body:
            if isinstance(else_body, list):
                if len(else_body) == 1:
                    else_str = self._emit_statement(else_body[0])
                else:
                    else_stmts = ' '.join(self._emit_statement(s) for s in else_body)
                    else_str = f"(begin {else_stmts})"
            else:
                else_str = self._emit_statement(else_body)
            return f"(if {cond}\n      {then_str}\n      {else_str})"
        
        # Use when for single-branch
        return f"(when {cond}\n    {then_str})"
    
    def _emit_while(self, stmt: Dict[str, Any]) -> str:
        """Emit while loop using named let."""
        cond = self._emit_expression(stmt.get('condition', stmt.get('cond', {})))
        body = stmt.get('body', [])
        
        body_strs = [self._emit_statement(s) for s in body] if body else ['*unspecified*']
        body_str = '\n        '.join(body_strs)
        
        # Use named let for looping
        return f"""(let loop ()
    (when {cond}
        {body_str}
        (loop)))"""
    
    def _emit_for(self, stmt: Dict[str, Any]) -> str:
        """Emit for loop using do."""
        var = self._lisp_name(stmt.get('var', 'i'))
        body = stmt.get('body', [])
        
        # Check if iterating over a collection or a range
        if 'iterable' in stmt:
            iterable = self._emit_expression(stmt['iterable'])
            body_strs = [self._emit_statement(s) for s in body] if body else ['*unspecified*']
            body_str = '\n      '.join(body_strs)
            return f"(for-each\n  (lambda ({var})\n      {body_str})\n  {iterable})"
        else:
            # Range-based loop with do
            start = self._emit_expression(stmt.get('start', {'kind': 'literal', 'value': 0}))
            end = self._emit_expression(stmt.get('end', {'kind': 'literal', 'value': 10}))
            body_strs = [self._emit_statement(s) for s in body] if body else ['*unspecified*']
            body_str = '\n      '.join(body_strs)
            return f"""(do (({var} {start} (+ {var} 1)))
    ((>= {var} {end}))
      {body_str})"""
    
    def _emit_literal(self, value: Any) -> str:
        """Emit a Guile literal."""
        if value is None:
            return "#f"
        if isinstance(value, bool):
            return "#t" if value else "#f"
        if isinstance(value, str):
            escaped = value.replace('\\', '\\\\').replace('"', '\\"')
            return f'"{escaped}"'
        return str(value)
    
    def _emit_binary_op(self, data: Dict[str, Any]) -> str:
        """Emit a binary operation with special handling for !=."""
        op = data.get('op', '+')
        left = self._emit_expression(data.get('left', {}))
        right = self._emit_expression(data.get('right', {}))
        
        if op == '!=':
            return f"(not (= {left} {right}))"
        
        guile_op = self.BINARY_OPS.get(op, op)
        return f"({guile_op} {left} {right})"
    
    def _map_type(self, ir_type: str) -> str:
        """Map IR type to Guile type."""
        return self.type_mapper.map_type(ir_type)
