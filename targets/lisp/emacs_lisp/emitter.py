#!/usr/bin/env python3
"""STUNIR Emacs Lisp Emitter.

Generates GNU Emacs Lisp code from STUNIR IR.
Supports lexical binding, feature management, and Emacs conventions.

Part of Phase 5B: Extended Lisp Implementation.
"""

import time
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional, Set

from ..base import LispEmitterBase, LispEmitterConfig, EmitterResult, compute_sha256, canonical_json
from .types import EmacsLispTypeMapper, EMACS_LISP_TYPES


@dataclass
class EmacsLispConfig(LispEmitterConfig):
    """Emacs Lisp specific configuration."""
    lexical_binding: bool = True       # Enable lexical binding
    emit_provide: bool = True          # Emit provide statement
    byte_compile_warnings: bool = True # Include byte-compile hints
    emacs_version: str = "27.1"        # Target Emacs version
    use_cl_lib: bool = True            # Use cl-lib for CL compatibility


class EmacsLispEmitter(LispEmitterBase):
    """Emitter for GNU Emacs Lisp code.
    
    Generates valid Emacs Lisp code with:
    - Lexical binding enabled by default
    - Feature/package management with provide/require
    - Emacs conventions (defun, defvar, defcustom)
    - Byte-compilation compatibility
    """
    
    DIALECT = "emacs-lisp"
    FILE_EXTENSION = ".el"
    
    # Emacs Lisp specific operators
    BINARY_OPS = {
        '+': '+',
        '-': '-',
        '*': '*',
        '/': '/',
        '%': 'mod',
        '==': '=',
        '!=': '/=',
        '<': '<',
        '>': '>',
        '<=': '<=',
        '>=': '>=',
        'and': 'and',
        'or': 'or',
        '&': 'logand',
        '|': 'logior',
        '^': 'logxor',
        '<<': 'ash',
    }
    
    def __init__(self, config: EmacsLispConfig):
        """Initialize Emacs Lisp emitter.
        
        Args:
            config: Emacs Lisp emitter configuration.
        """
        super().__init__(config)
        self.config: EmacsLispConfig = config
        self.type_mapper = EmacsLispTypeMapper(config.emit_type_hints)
    
    def emit(self, ir: Dict[str, Any]) -> EmitterResult:
        """Emit Emacs Lisp code from IR.
        
        Args:
            ir: STUNIR IR dictionary.
            
        Returns:
            EmitterResult with generated code.
        """
        module_name = self._lisp_name(ir.get('module', 'unnamed'))
        
        # Build code sections
        sections = []
        
        # File header with lexical binding
        sections.append(self._emit_header(module_name))
        
        # Commentary section
        sections.append(self._emit_commentary(ir))
        
        # Code section marker
        sections.append(";;; Code:")
        
        # Require statements
        if self.config.use_cl_lib:
            sections.append("(require 'cl-lib)")
        for imp in ir.get('imports', []):
            sections.append(self._emit_require(imp))
        
        # Variables (defvar/defcustom)
        for var in ir.get('variables', ir.get('globals', [])):
            sections.append(self._emit_defvar(var))
        
        # Functions
        for func in ir.get('functions', []):
            sections.append(self._emit_function(func))
        
        # Provide statement
        if self.config.emit_provide:
            sections.append(f"\n(provide '{module_name})")
            sections.append(f";;; {module_name}.el ends here")
        
        code = "\n\n".join(filter(None, sections))
        
        # Write main file
        main_file = f"{module_name}.el"
        self._write_file(main_file, code)
        
        return EmitterResult(
            code=code,
            files={main_file: code},
            manifest=self._generate_manifest(ir)
        )
    
    def _emit_header(self, module_name: str) -> str:
        """Emit file header with lexical binding."""
        lexical = "; -*-" + (" lexical-binding: t;" if self.config.lexical_binding else "") + " -*-"
        lines = [
            f";;; {module_name}.el --- Generated module {lexical}",
            f"",
            f";;; Generated by STUNIR Emacs Lisp Emitter",
            f";;; Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}",
        ]
        return "\n".join(lines)
    
    def _emit_commentary(self, ir: Dict[str, Any]) -> str:
        """Emit commentary section."""
        doc = ir.get('docstring', ir.get('doc', 'Generated by STUNIR'))
        lines = [
            ";;; Commentary:",
            f";; {doc}",
        ]
        return "\n".join(lines)
    
    def _emit_require(self, imp: Dict[str, Any]) -> str:
        """Emit a require statement."""
        name = imp.get('module', imp.get('name', ''))
        return f"(require '{self._lisp_name(name)})"
    
    def _emit_defvar(self, var: Dict[str, Any]) -> str:
        """Emit a defvar statement."""
        name = self._lisp_name(var.get('name', '_'))
        value = var.get('value', var.get('init'))
        doc = var.get('docstring', var.get('doc', ''))
        
        if value is not None:
            val_str = self._emit_expression(value)
        else:
            val_str = "nil"
        
        if doc:
            return f'(defvar {name} {val_str}\n  "{doc}")'
        return f"(defvar {name} {val_str})"
    
    def _emit_function(self, func: Dict[str, Any]) -> str:
        """Emit a function definition."""
        name = self._lisp_name(func.get('name', 'unnamed'))
        params = func.get('params', [])
        body = func.get('body', [])
        docstring = func.get('docstring', func.get('doc', ''))
        interactive = func.get('interactive', False)
        
        # Parameter list
        param_names = ' '.join(self._lisp_name(p.get('name', '_')) for p in params)
        
        # Build function
        lines = [f"(defun {name} ({param_names})"]
        
        # Docstring
        if docstring:
            lines.append(f'  "{docstring}"')
        
        # Interactive spec
        if interactive:
            lines.append("  (interactive)")
        
        # Body
        if body:
            for stmt in body:
                stmt_str = self._emit_statement(stmt)
                lines.append(f"  {stmt_str}")
        else:
            lines.append("  nil")
        
        lines.append(")")
        
        return "\n".join(lines)
    
    def _emit_var_decl(self, stmt: Dict[str, Any]) -> str:
        """Emit variable declaration using let."""
        name = self._lisp_name(stmt.get('name', '_'))
        value = stmt.get('value', stmt.get('init'))
        
        if value is not None:
            val_str = self._emit_expression(value)
            return f"(let (({name} {val_str})))"
        return f"(let (({name} nil)))"
    
    def _emit_assignment(self, stmt: Dict[str, Any]) -> str:
        """Emit assignment statement using setq."""
        name = self._lisp_name(stmt.get('name', stmt.get('target', '_')))
        value = self._emit_expression(stmt.get('value', {}))
        return f"(setq {name} {value})"
    
    def _emit_if_stmt(self, stmt: Dict[str, Any]) -> str:
        """Emit if statement."""
        cond = self._emit_expression(stmt.get('condition', stmt.get('cond', {})))
        then_body = stmt.get('then', stmt.get('consequent', []))
        else_body = stmt.get('else', stmt.get('alternate', []))
        
        # Handle body as list or single statement
        if isinstance(then_body, list):
            if len(then_body) == 1:
                then_str = self._emit_statement(then_body[0])
            elif then_body:
                then_stmts = ' '.join(self._emit_statement(s) for s in then_body)
                then_str = f"(progn {then_stmts})"
            else:
                then_str = 'nil'
        else:
            then_str = self._emit_statement(then_body)
        
        if else_body:
            if isinstance(else_body, list):
                if len(else_body) == 1:
                    else_str = self._emit_statement(else_body[0])
                else:
                    else_stmts = ' '.join(self._emit_statement(s) for s in else_body)
                    else_str = f"(progn {else_stmts})"
            else:
                else_str = self._emit_statement(else_body)
            return f"(if {cond}\n      {then_str}\n    {else_str})"
        
        # Use when for single-branch
        return f"(when {cond}\n    {then_str})"
    
    def _emit_while(self, stmt: Dict[str, Any]) -> str:
        """Emit while loop."""
        cond = self._emit_expression(stmt.get('condition', stmt.get('cond', {})))
        body = stmt.get('body', [])
        
        body_strs = [self._emit_statement(s) for s in body] if body else ['nil']
        body_str = '\n      '.join(body_strs)
        
        return f"(while {cond}\n      {body_str})"
    
    def _emit_for(self, stmt: Dict[str, Any]) -> str:
        """Emit for loop using dolist or dotimes."""
        var = self._lisp_name(stmt.get('var', 'i'))
        body = stmt.get('body', [])
        
        # Check if iterating over a collection or a range
        if 'iterable' in stmt:
            iterable = self._emit_expression(stmt['iterable'])
            body_strs = [self._emit_statement(s) for s in body] if body else ['nil']
            body_str = '\n      '.join(body_strs)
            return f"(dolist ({var} {iterable})\n      {body_str})"
        else:
            # Range-based loop with dotimes
            start = stmt.get('start', {'kind': 'literal', 'value': 0})
            end = self._emit_expression(stmt.get('end', {'kind': 'literal', 'value': 10}))
            body_strs = [self._emit_statement(s) for s in body] if body else ['nil']
            body_str = '\n      '.join(body_strs)
            return f"(dotimes ({var} {end})\n      {body_str})"
    
    def _emit_literal(self, value: Any) -> str:
        """Emit an Emacs Lisp literal."""
        if value is None:
            return "nil"
        if isinstance(value, bool):
            return "t" if value else "nil"
        if isinstance(value, str):
            escaped = value.replace('\\', '\\\\').replace('"', '\\"')
            return f'"{escaped}"'
        return str(value)
    
    def _map_type(self, ir_type: str) -> str:
        """Map IR type to Emacs Lisp type."""
        return self.type_mapper.map_type(ir_type)
