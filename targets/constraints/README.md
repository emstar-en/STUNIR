# Constraint Programming Emitters

This package provides emitters for constraint programming languages:

- **MiniZinc**: High-level constraint modeling language
- **CHR**: Constraint Handling Rules for Prolog

## Overview

Constraint programming emitters convert the STUNIR Constraint IR to target-specific formats that can be executed by constraint solvers.

## Quick Start

```python
from ir.constraints import (
    ConstraintModel, Domain, VariableType, Objective,
    VariableRef, alldifferent
)
from targets.constraints import MiniZincEmitter

# Create a model
model = ConstraintModel("nqueens")
for i in range(1, 9):
    model.add_int_variable(f"q{i}", 1, 8)

vars_list = [VariableRef(f"q{i}") for i in range(1, 9)]
model.add_constraint(alldifferent(vars_list))
model.set_objective(Objective.satisfy())

# Emit to MiniZinc
emitter = MiniZincEmitter()
result = emitter.emit(model)

print(result.code)
# Output:
# % Model: nqueens
# % Generated by STUNIR MiniZinc Emitter
# 
# include "alldifferent.mzn";
# 
# % Variables
# var 1..8: q1;
# var 1..8: q2;
# ...
# constraint alldifferent([q1, q2, q3, q4, q5, q6, q7, q8]);
# 
# % Solve
# solve satisfy;
```

## Module Structure

```
targets/constraints/
├── __init__.py           # Package exports
├── base.py               # Base emitter class
├── minizinc_emitter.py   # MiniZinc emitter
├── chr_emitter.py        # CHR emitter
└── README.md             # This file
```

## MiniZinc Emitter

### Overview

MiniZinc is a high-level constraint modeling language supported by many constraint solvers including:
- Gecode
- Chuffed
- OR-Tools
- CPLEX
- Gurobi

### Usage

```python
from targets.constraints import MiniZincEmitter

emitter = MiniZincEmitter(pretty_print=True)
result = emitter.emit(model)

# Access generated code
print(result.code)

# Access manifest
print(result.manifest)

# Write to file
result.write_to_file("model.mzn")
result.write_manifest("model_manifest.json")
```

### Generated Output Structure

```minizinc
% Model: example
% Generated by STUNIR MiniZinc Emitter

include "alldifferent.mzn";

% Parameters
int: n = 8;

% Variables
var 1..10: x;
var 1..10: y;

% Arrays
array[1..8] of var 1..8: queens;

% Constraints
constraint x + y = 10;
constraint alldifferent([q1, q2, q3, q4]);

% Solve
solve minimize x + y;

% Output
output [
  "x = ", show(x), "\n",
  "y = ", show(y), "\n"
];
```

### Type Mapping

| IR Type | MiniZinc Type |
|---------|---------------|
| `VariableType.INT` | `int` |
| `VariableType.FLOAT` | `float` |
| `VariableType.BOOL` | `bool` |
| `VariableType.SET` | `set of int` |
| Domain range | `lb..ub` |
| Domain set | `{v1, v2, ...}` |

### Constraint Mapping

| IR Constraint | MiniZinc Syntax |
|---------------|------------------|
| `EQ` | `=` |
| `NE` | `!=` |
| `LT` | `<` |
| `LE` | `<=` |
| `GT` | `>` |
| `GE` | `>=` |
| `AND` | `/\` |
| `OR` | `\/` |
| `NOT` | `not(...)` |
| `IMPLIES` | `->` |
| `IFF` | `<->` |
| `ALLDIFFERENT` | `alldifferent([...])` |
| `CUMULATIVE` | `cumulative(...)` |

## CHR Emitter

### Overview

CHR (Constraint Handling Rules) is a rule-based language for writing constraint solvers, typically embedded in Prolog. It supports:
- Simplification rules
- Propagation rules
- Simpagation rules

### Usage

```python
from targets.constraints import CHREmitter

emitter = CHREmitter(pretty_print=True)
result = emitter.emit(model)

print(result.code)
result.write_to_file("model.pl")
```

### Generated Output Structure

```prolog
%% Model: example
%% Generated by STUNIR CHR Emitter
%%
%% Usage: ?- solve.

:- use_module(library(chr)).
:- use_module(library(lists)).

:- chr_constraint domain/2, eq/2, neq/2, alldifferent/1.

%% Domain rules
domain(X, D), domain(X, D) <=> domain(X, D).
domain(X, D1) \ domain(X, D2) <=> 
  intersection(D1, D2, D3), D3 \= [] |
  domain(X, D3).

%% Constraint propagation rules
eq(X, V), domain(X, D) <=> member(V, D) | X = V.

%% Alldifferent constraint
alldifferent([]) <=> true.
alldifferent([X|Xs]) <=> 
  exclude(X, Xs), alldifferent(Xs).

%% Main solve predicate
solve :-
  make_domain(X, 1, 10),
  make_domain(Y, 1, 10),
  eq(X, Y),
  label([X, Y]).
```

### CHR Rule Types

```python
from targets.constraints.chr_emitter import (
    emit_simplification_rule,
    emit_propagation_rule,
    emit_simpagation_rule
)

# Simplification rule: H <=> G | B
# Replaces head with body
rule = emit_simplification_rule(
    "name", 
    "eq(X, Y)",      # Head
    "ground(Y)",     # Guard
    "X = Y"          # Body
)
# Result: "eq(X, Y) <=> ground(Y) | X = Y."

# Propagation rule: H ==> G | B
# Keeps head and adds body
rule = emit_propagation_rule(
    "name",
    "lt(X, Y)",      # Head
    "",              # Guard (empty)
    "neq(X, Y)"      # Body
)
# Result: "lt(X, Y) ==> neq(X, Y)."

# Simpagation rule: K \ R <=> G | B
# Keeps K, removes R, adds B
rule = emit_simpagation_rule(
    "domain(X, D1)",  # Kept
    "domain(X, D2)",  # Removed
    "D1 \\= D2",      # Guard
    "domain(X, D1)"   # Body
)
# Result: "domain(X, D1) \ domain(X, D2) <=> D1 \= D2 | domain(X, D1)."
```

## Manifest Generation

Both emitters generate a manifest with build information:

```python
result = emitter.emit(model)
print(result.manifest)

# Output:
# {
#   "schema": "stunir.manifest.constraints.minizinc.v1",
#   "generator": "stunir.constraints.minizinc_emitter",
#   "version": "1.0",
#   "model_name": "nqueens",
#   "statistics": {
#     "variables": 8,
#     "arrays": 0,
#     "parameters": 0,
#     "constraints": 1
#   },
#   "output": {
#     "hash": "a1b2c3...",
#     "size": 456,
#     "format": "minizinc"
#   },
#   "warnings": []
# }
```

## Example Problems

### N-Queens (MiniZinc)

```python
from ir.constraints import (
    ConstraintModel, VariableRef, Literal, BinaryOp,
    alldifferent, Objective
)
from targets.constraints import MiniZincEmitter

def create_nqueens_model(n: int) -> ConstraintModel:
    model = ConstraintModel("nqueens")
    model.add_parameter("n", n)
    
    # Queen positions (row i has queen in column queens[i])
    queens = model.add_int_array("queens", n, 1, n)
    
    # All columns different
    vars_list = [VariableRef(f"queens[{i}]") for i in range(1, n + 1)]
    model.add_constraint(alldifferent(vars_list))
    
    model.set_objective(Objective.satisfy())
    return model

model = create_nqueens_model(8)
emitter = MiniZincEmitter()
result = emitter.emit(model)
print(result.code)
```

### SEND+MORE=MONEY (MiniZinc)

```python
from ir.constraints import (
    ConstraintModel, VariableRef, Literal,
    alldifferent, gt, Objective
)
from targets.constraints import MiniZincEmitter

def create_send_more_money_model():
    model = ConstraintModel("send_more_money")
    
    # Variables for each digit
    for letter in ['S', 'E', 'N', 'D', 'M', 'O', 'R', 'Y']:
        model.add_int_variable(letter, 0, 9)
    
    # All different
    vars_list = [VariableRef(c) for c in ['S', 'E', 'N', 'D', 'M', 'O', 'R', 'Y']]
    model.add_constraint(alldifferent(vars_list))
    
    # Leading digits non-zero
    model.add_constraint(gt(VariableRef('S'), Literal(0)))
    model.add_constraint(gt(VariableRef('M'), Literal(0)))
    
    # SEND + MORE = MONEY constraint would need
    # arithmetic expression support
    
    model.set_objective(Objective.satisfy())
    return model

model = create_send_more_money_model()
emitter = MiniZincEmitter()
result = emitter.emit(model)
print(result.code)
```

## Running Generated Code

### MiniZinc

```bash
# Save the model
python generate_model.py > model.mzn

# Run with MiniZinc (requires MiniZinc installation)
minizinc model.mzn

# Or use a specific solver
minizinc --solver gecode model.mzn
```

### CHR/Prolog

```bash
# Save the model
python generate_model.py > model.pl

# Run with SWI-Prolog
swipl -s model.pl -g solve
```

## Extending the Emitters

### Adding a New Emitter

```python
from targets.constraints.base import BaseConstraintEmitter
from ir.constraints import ConstraintModel, ConstraintEmitterResult

class MyEmitter(BaseConstraintEmitter):
    DIALECT = "my_language"
    VERSION = "1.0"
    FILE_EXTENSION = ".myl"
    
    def emit(self, model: ConstraintModel) -> ConstraintEmitterResult:
        self._output = []
        self._warnings = []
        
        # Emit your format
        self._emit_header(model)
        for var in model.variables:
            self._emit_variable(var)
        for constraint in model.constraints:
            self._emit_constraint(constraint)
        self._emit_objective(model.objective)
        
        code = self._get_code()
        manifest = self._generate_manifest(model, code)
        return ConstraintEmitterResult(code, manifest, self._warnings)
    
    def _emit_variable(self, var):
        self._line(f"variable {var.name} in {var.domain}")
    
    def _emit_constraint(self, constraint):
        self._line(f"constraint {constraint}")
    
    def _emit_objective(self, objective):
        self._line(f"objective {objective}")
```

## See Also

- `ir/constraints/README.md` - Constraint IR documentation
- `tests/codegen/test_constraint_emitters.py` - Comprehensive test cases
- [MiniZinc Documentation](https://www.minizinc.org/doc-2.6.4/en/index.html)
- [CHR Documentation](https://www.swi-prolog.org/pldoc/man?section=chr)
