"""MiniZinc constraint model emitter.

This module emits constraint models to MiniZinc format.
"""

from typing import Set

from .base import BaseConstraintEmitter, compute_sha256
from ir.constraints import (
    ConstraintModel, Variable, ArrayVariable, Domain, Parameter,
    Constraint, RelationalConstraint, LogicalConstraint, GlobalConstraint,
    Objective, SearchAnnotation, ConstraintEmitterResult,
    Expression, VariableRef, Literal, Comprehension,
    ConstraintType, ObjectiveType, VariableType, DomainType
)


class MiniZincEmitter(BaseConstraintEmitter):
    """MiniZinc constraint model emitter.
    
    Emits constraint models to MiniZinc (.mzn) format,
    the standard input format for MiniZinc solvers.
    """
    
    DIALECT = "minizinc"
    VERSION = "1.0"
    FILE_EXTENSION = ".mzn"
    
    # Global constraint includes
    GLOBAL_INCLUDES = {
        ConstraintType.ALLDIFFERENT: "alldifferent.mzn",
        ConstraintType.CUMULATIVE: "cumulative.mzn",
        ConstraintType.CIRCUIT: "circuit.mzn",
        ConstraintType.TABLE: "table.mzn",
        ConstraintType.REGULAR: "regular.mzn",
        ConstraintType.BIN_PACKING: "bin_packing.mzn",
        ConstraintType.GLOBAL_CARDINALITY: "global_cardinality.mzn",
        ConstraintType.ELEMENT: "element.mzn",
        ConstraintType.COUNT: "count.mzn",
    }
    
    # Constraint type to MiniZinc operator
    RELATIONAL_OPS = {
        ConstraintType.EQ: "=",
        ConstraintType.NE: "!=",
        ConstraintType.LT: "<",
        ConstraintType.LE: "<=",
        ConstraintType.GT: ">",
        ConstraintType.GE: ">=",
    }
    
    # Global constraint names
    GLOBAL_NAMES = {
        ConstraintType.ALLDIFFERENT: "alldifferent",
        ConstraintType.CUMULATIVE: "cumulative",
        ConstraintType.ELEMENT: "element",
        ConstraintType.TABLE: "table",
        ConstraintType.REGULAR: "regular",
        ConstraintType.CIRCUIT: "circuit",
        ConstraintType.COUNT: "count",
        ConstraintType.BIN_PACKING: "bin_packing",
        ConstraintType.GLOBAL_CARDINALITY: "global_cardinality",
        ConstraintType.SUM: "sum",
    }
    
    def emit(self, model: ConstraintModel) -> ConstraintEmitterResult:
        """Emit MiniZinc model.
        
        Args:
            model: Constraint model to emit
            
        Returns:
            ConstraintEmitterResult with MiniZinc code
        """
        self._output = []
        self._warnings = []
        
        # Validate model
        errors = model.validate()
        for error in errors:
            self._warn(f"Validation error: {error}")
        
        # Emit sections
        self._emit_header(model)
        self._emit_includes(model)
        self._emit_parameters(model)
        self._emit_variables(model)
        self._emit_arrays(model)
        self._emit_constraints(model)
        self._emit_objective(model.objective)
        self._emit_search(model)
        self._emit_output(model)
        
        code = self._get_code()
        manifest = self._generate_manifest(model, code)
        return ConstraintEmitterResult(code, manifest, self._warnings)
    
    def _emit_header(self, model: ConstraintModel) -> None:
        """Emit file header."""
        self._line(f"% Model: {model.name}")
        self._line(f"% Generated by STUNIR MiniZinc Emitter")
        self._line()
    
    def _emit_includes(self, model: ConstraintModel) -> None:
        """Emit include statements for global constraints."""
        includes: Set[str] = set()
        
        for constraint in model.constraints:
            if isinstance(constraint, GlobalConstraint):
                include = self.GLOBAL_INCLUDES.get(constraint.constraint_type)
                if include:
                    includes.add(include)
        
        for include in sorted(includes):
            self._line(f'include "{include}";')
        
        if includes:
            self._line()
    
    def _emit_parameters(self, model: ConstraintModel) -> None:
        """Emit parameter declarations."""
        if not model.parameters:
            return
        
        self._line("% Parameters")
        for param in model.parameters:
            type_str = self._get_type_string(param.param_type)
            self._line(f"{type_str}: {param.name} = {param.value};")
        self._line()
    
    def _emit_variables(self, model: ConstraintModel) -> None:
        """Emit variable declarations."""
        if not model.variables:
            return
        
        self._line("% Variables")
        for var in model.variables:
            self._emit_variable(var)
        self._line()
    
    def _emit_variable(self, var: Variable) -> None:
        """Emit a single variable declaration."""
        domain_str = self._format_domain(var.domain)
        annotations = ""
        if var.annotations:
            annotations = " :: " + " :: ".join(var.annotations)
        self._line(f"var {domain_str}: {var.name}{annotations};")
    
    def _emit_arrays(self, model: ConstraintModel) -> None:
        """Emit array declarations."""
        if not model.arrays:
            return
        
        self._line("% Arrays")
        for arr in model.arrays:
            self._emit_array_variable(arr)
        self._line()
    
    def _emit_array_variable(self, arr: ArrayVariable) -> None:
        """Emit an array variable declaration."""
        index_str = arr.index_set.to_minizinc()
        domain_str = self._format_domain(arr.element_domain)
        annotations = ""
        if arr.annotations:
            annotations = " :: " + " :: ".join(arr.annotations)
        self._line(f"array[{index_str}] of var {domain_str}: {arr.name}{annotations};")
    
    def _emit_constraints(self, model: ConstraintModel) -> None:
        """Emit all constraints."""
        if not model.constraints:
            return
        
        self._line("% Constraints")
        for constraint in model.constraints:
            self._emit_constraint(constraint)
        self._line()
    
    def _emit_constraint(self, constraint: Constraint) -> None:
        """Emit a single constraint."""
        constraint_str = self._format_constraint(constraint)
        if constraint.name:
            self._line(f"constraint {constraint_str};  % {constraint.name}")
        else:
            self._line(f"constraint {constraint_str};")
    
    def _emit_objective(self, objective: Objective) -> None:
        """Emit solve statement."""
        self._line("% Solve")
        if objective.objective_type == ObjectiveType.SATISFY:
            self._line("solve satisfy;")
        elif objective.objective_type == ObjectiveType.MINIMIZE:
            expr_str = self._format_expression(objective.expression)
            self._line(f"solve minimize {expr_str};")
        elif objective.objective_type == ObjectiveType.MAXIMIZE:
            expr_str = self._format_expression(objective.expression)
            self._line(f"solve maximize {expr_str};")
        self._line()
    
    def _emit_search(self, model: ConstraintModel) -> None:
        """Emit search annotations."""
        # Search annotations are typically combined with solve statement
        # This is a simplified version
        pass
    
    def _emit_output(self, model: ConstraintModel) -> None:
        """Emit output statement."""
        if not model.output:
            # Generate default output
            outputs = []
            for var in model.variables:
                outputs.append(f'"{var.name} = ", show({var.name}), "\\n"')
            for arr in model.arrays:
                outputs.append(f'"{arr.name} = ", show({arr.name}), "\\n"')
            
            if outputs:
                self._line("% Output")
                self._line("output [")
                self._indent_inc()
                for i, out in enumerate(outputs):
                    suffix = "," if i < len(outputs) - 1 else ""
                    self._line(f"{out}{suffix}")
                self._indent_dec()
                self._line("];") 
        else:
            self._line("% Output")
            self._line("output [")
            self._indent_inc()
            for i, out in enumerate(model.output):
                suffix = "," if i < len(model.output) - 1 else ""
                self._line(f"{out}{suffix}")
            self._indent_dec()
            self._line("];")
    
    def _format_domain(self, domain: Domain) -> str:
        """Format a domain for MiniZinc."""
        if domain.domain_type == DomainType.RANGE:
            return f"{domain.lower}..{domain.upper}"
        elif domain.domain_type == DomainType.SET:
            values_str = ", ".join(str(v) for v in sorted(domain.values))
            return "{" + values_str + "}"
        elif domain.domain_type == DomainType.BOOL:
            return "bool"
        elif domain.domain_type == DomainType.UNBOUNDED:
            return "int"
        return "int"
    
    def _format_constraint(self, constraint: Constraint) -> str:
        """Format a constraint for MiniZinc."""
        if isinstance(constraint, RelationalConstraint):
            return self._format_relational(constraint)
        elif isinstance(constraint, LogicalConstraint):
            return self._format_logical(constraint)
        elif isinstance(constraint, GlobalConstraint):
            return self._format_global(constraint)
        else:
            self._warn(f"Unknown constraint type: {type(constraint)}")
            return "true"
    
    def _format_relational(self, constraint: RelationalConstraint) -> str:
        """Format a relational constraint."""
        op = self.RELATIONAL_OPS.get(constraint.constraint_type, "=")
        left = self._format_expression(constraint.left)
        right = self._format_expression(constraint.right)
        return f"{left} {op} {right}"
    
    def _format_logical(self, constraint: LogicalConstraint) -> str:
        """Format a logical constraint."""
        if constraint.constraint_type == ConstraintType.NOT:
            inner = self._format_constraint(constraint.operands[0])
            return f"not({inner})"
        elif constraint.constraint_type == ConstraintType.AND:
            parts = [self._format_constraint(c) for c in constraint.operands]
            return " /\\ ".join(f"({p})" for p in parts)
        elif constraint.constraint_type == ConstraintType.OR:
            parts = [self._format_constraint(c) for c in constraint.operands]
            return " \\/ ".join(f"({p})" for p in parts)
        elif constraint.constraint_type == ConstraintType.IMPLIES:
            left = self._format_constraint(constraint.operands[0])
            right = self._format_constraint(constraint.operands[1])
            return f"({left}) -> ({right})"
        elif constraint.constraint_type == ConstraintType.IFF:
            left = self._format_constraint(constraint.operands[0])
            right = self._format_constraint(constraint.operands[1])
            return f"({left}) <-> ({right})"
        else:
            self._warn(f"Unknown logical constraint: {constraint.constraint_type}")
            return "true"
    
    def _format_global(self, constraint: GlobalConstraint) -> str:
        """Format a global constraint."""
        name = self.GLOBAL_NAMES.get(constraint.constraint_type, "unknown")
        args = [self._format_expression(a) for a in constraint.args]
        
        # Handle special cases
        if constraint.constraint_type == ConstraintType.ALLDIFFERENT:
            return f"{name}([{', '.join(args)}])"
        elif constraint.constraint_type == ConstraintType.SUM:
            return f"{name}([{', '.join(args)}])"
        else:
            return f"{name}({', '.join(args)})"
    
    def _get_type_string(self, var_type: VariableType) -> str:
        """Get MiniZinc type string."""
        if var_type is None:
            return "int"
        type_map = {
            VariableType.INT: "int",
            VariableType.FLOAT: "float",
            VariableType.BOOL: "bool",
            VariableType.SET: "set of int",
        }
        return type_map.get(var_type, "int")
