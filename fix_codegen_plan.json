{
  "objectives": [
    "Ensure C/C++ code generation produces correct C/C++ signatures when output filename indicates C/C++ and --target is omitted",
    "Preserve explicit --target behavior to avoid breaking existing workflows",
    "Provide deterministic, transparent target selection with clear warnings",
    "Normalize extension handling to be case-insensitive and robust against complex paths"
  ],
  "issue": "stunir_ir_to_code defaults to Python when --target is not provided, producing Python-style signatures in .cpp output",
  "root_cause": [
    "Run_IR_To_Code initializes Target to Target_Python and only updates it when --target is passed",
    "No auto-detection of target language from output filename extension",
    "Output path is currently unused for target inference"
  ],
  "scope": [
    "STUNIR-main/tools/spark/src/stunir_ir_to_code.adb",
    "STUNIR-main/tools/spark/src/stunir_ir_to_code.ads",
    "stunir_ir_to_code_main.exe build artifact",
    "stunir_execution_workspace/*/generated.* for verification"
  ],
  "assumptions": [
    "Emit_C_Function already emits valid C-style signatures when called",
    "Users may omit --target and rely on output extension heuristics",
    "Target inference should be case-insensitive and based on the last extension (everything after the last dot)",
    "Ada.Directories.Extension is available/usable or manual string parsing will be used"
  ],
  "cases": [
    {
      "case": "--target is provided (recognized)",
      "expected": "Use specified target regardless of output filename extension"
    },
    {
      "case": "--target is provided (unrecognized)",
      "expected": "Fallback to Target_Python and emit warning '[WARN] Invalid target specified. Defaulting to Python.'"
    },
    {
      "case": "--target is not provided and output has .cpp/.cc/.cxx/.CPP",
      "expected": "Select Target_Cpp"
    },
    {
      "case": "--target is not provided and output has .c/.C",
      "expected": "Select Target_C"
    },
    {
      "case": "--target is not provided and output has .h/.hpp/.hh/.hxx",
      "expected": "Select Target_Cpp and emit a warning '[INFO] Header file extension detected. Defaulting to C++ target.'"
    },
    {
      "case": "--target is not provided and output has .py/.rs/.go/.js/.ts/.java/.cs",
      "expected": "Select corresponding target"
    },
    {
      "case": "--target is not provided and output has unknown or no extension",
      "expected": "Keep Target_Python and emit warning '[WARN] Could not infer target from output extension. Defaulting to Python.'"
    },
    {
      "case": "output path includes multiple dots (e.g., generated.v1.cpp)",
      "expected": "Use the last extension for inference (.cpp -> Target_Cpp)"
    }
  ],
  "implementation_steps": [
    "Step 1: Define helper function Infer_Target_From_Output in stunir_ir_to_code.adb body (before Run_IR_To_Code). It should take the output path String and return (Target_Language, Boolean) where Boolean indicates success.",
    "Step 2: Implement extension mapping logic inside helper:",
    "  - Extract extension using Ada.Directories.Extension or by identifying last dot.",
    "  - Convert to lower case.",
    "  - Map: cpp, cc, cxx, hpp, hh, hxx -> Target_Cpp",
    "  - Map: c, h -> Target_C",
    "  - Map: py -> Target_Python",
    "  - Map: rs -> Target_Rust",
    "  - Map: go -> Target_Go",
    "  - Map: js -> Target_JavaScript",
    "  - Map: ts -> Target_TypeScript",
    "  - Map: java -> Target_Java",
    "  - Map: cs -> Target_CSharp",
    "  - Map: wasm -> Target_WASM",
    "  - Map: asm, s -> Target_Assembly_X86",
    "Step 3: Update Run_IR_To_Code:",
    "  - Add boolean flag Target_Explicitly_Set initialized to False.",
    "  - Set flag to True inside loop when '--target' matches.",
    "  - After loop: If not Target_Explicitly_Set, call Infer_Target_From_Output(Output_Path).",
    "  - If inference succeeds, update Target. If fails, log warning.",
    "Step 4: Rebuild using the existing STUNIR Spark build workflow and regenerate stunir_ir_to_code_main.exe."
  ],
  "test_matrix": [
    {
      "name": "cpp_extension_inference",
      "command": "stunir_ir_to_code_main.exe --input ir.json --output generated.cpp",
      "expect": "C++ signatures, no Python type hints"
    },
    {
      "name": "explicit_python_overrides_extension",
      "command": "stunir_ir_to_code_main.exe --input ir.json --output generated.cpp --target python",
      "expect": "Python signatures with type hints"
    },
    {
      "name": "c_extension_inference",
      "command": "stunir_ir_to_code_main.exe --input ir.json --output generated.c",
      "expect": "C signatures"
    },
    {
      "name": "py_extension_inference",
      "command": "stunir_ir_to_code_main.exe --input ir.json --output generated.py",
      "expect": "Python signatures"
    },
    {
      "name": "unknown_extension_warning",
      "command": "stunir_ir_to_code_main.exe --input ir.json --output generated.unknown",
      "expect": "Warning and Python output"
    }
  ],
  "verification_steps": [
    "Run test_matrix scenarios and confirm expected outputs.",
    "Spot-check generated.cpp for absence of Python type hints (no '-> void') and presence of C/C++ parameter lists.",
    "Spot-check generated.cpp for valid return types and parameter formatting from Map_To_C_Type."
  ],
  "acceptance_criteria": [
    "When output extension indicates C/C++, generated code contains C/C++ function signatures (no Python-style type hints).",
    "Explicit --target continues to override output extension.",
    "Warnings are emitted for unknown extensions or invalid --target values.",
    "Existing behavior for Python remains unchanged when explicitly targeted.",
    "No changes to IR parsing or extraction outputs."
  ],
  "risks": [
    "Incorrect extension parsing on Windows paths with multiple dots or no extension",
    "Conflicting expectations around .h defaulting to C vs C++",
    "Unintended changes to target selection when output path is empty"
  ],
  "mitigations": [
    "Use last-dot extension parsing and handle empty extension explicitly",
    "Emit informational warning for header extensions and default to C++",
    "Preserve existing error handling when output path is empty"
  ],
  "rollback_plan": [
    "If build fails, revert changes to stunir_ir_to_code.adb using undo or git checkout.",
    "If inference logic causes crashes, revert to original explicit-only logic."
  ],
  "notes": [
    "Emit_C_Function already emits C-style signatures using Map_To_C_Type and does not include Python hints.",
    "This fix does not alter IR parsing or extraction; it only changes target selection logic."
  ]
}
