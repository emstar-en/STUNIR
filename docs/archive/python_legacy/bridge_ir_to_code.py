#!/usr/bin/env python3
"""
STUNIR IR to Code Bridge (Phase 3)

Converts ir.json to generated code in multiple target languages.
Replaces broken stunir_ir_to_code_main.exe

Usage:
    python bridge_ir_to_code.py --input ir.json --output-dir ./out --target cpp
    python bridge_ir_to_code.py -i ir.json -o ./out --all-targets
"""

import json
import argparse
import sys
from pathlib import Path
from typing import Dict, List, Any, Optional


# Language templates for code generation
TEMPLATES = {
    'cpp': {
        'header': '''#include <stdint.h>
#include <stdbool.h>

// Generated by STUNIR IR to Code Bridge
// Target: C++

''',
        'function': '''{return_type} {name}({params}) {{
    // TODO: Implement function body
}}
''',
        'param_sep': ', ',
        'type_map': {},  # Use types as-is for C++
    },
    'c': {
        'header': '''#include <stdint.h>
#include <stdbool.h>

// Generated by STUNIR IR to Code Bridge
// Target: C

''',
        'function': '''{return_type} {name}({params}) {{
    // TODO: Implement function body
}}
''',
        'param_sep': ', ',
        'type_map': {},
    },
    'python': {
        'header': '''# Generated by STUNIR IR to Code Bridge
# Target: Python

from typing import *

''',
        'function': '''def {name}({params}) -> {return_type}:
    """TODO: Implement function"""
    pass
''',
        'param_sep': ', ',
        'type_map': {
            'void': 'None',
            'int': 'int',
            'char': 'str',
            'bool': 'bool',
            'float': 'float',
            'double': 'float',
        },
    },
    'rust': {
        'header': '''// Generated by STUNIR IR to Code Bridge
// Target: Rust

''',
        'function': '''pub fn {name}({params}) -> {return_type} {{
    // TODO: Implement function body
    todo!()
}}
''',
        'param_sep': ', ',
        'type_map': {
            'void': '()',
            'int': 'i32',
            'char': 'u8',
            'bool': 'bool',
            'float': 'f32',
            'double': 'f64',
        },
    },
    'go': {
        'header': '''// Generated by STUNIR IR to Code Bridge
// Target: Go

package main

''',
        'function': '''func {name}({params}) {return_type} {{
    // TODO: Implement function body
}}
''',
        'param_sep': ', ',
        'type_map': {
            'void': '',
            'int': 'int',
            'char': 'byte',
            'bool': 'bool',
            'float': 'float32',
            'double': 'float64',
        },
    },
    'javascript': {
        'header': '''// Generated by STUNIR IR to Code Bridge
// Target: JavaScript

''',
        'function': '''function {name}({params}) {{
    // TODO: Implement function body
}}
''',
        'param_sep': ', ',
        'type_map': {},
    },
    'java': {
        'header': '''// Generated by STUNIR IR to Code Bridge
// Target: Java

public class Generated {{
''',
        'function': '''    public static {return_type} {name}({params}) {{
        // TODO: Implement function body
    }}
''',
        'param_sep': ', ',
        'type_map': {
            'void': 'void',
            'int': 'int',
            'char': 'char',
            'bool': 'boolean',
            'float': 'float',
            'double': 'double',
        },
    },
    'csharp': {
        'header': '''// Generated by STUNIR IR to Code Bridge
// Target: C#

using System;

public class Generated {{
''',
        'function': '''    public static {return_type} {name}({params}) {{
        // TODO: Implement function body
    }}
''',
        'param_sep': ', ',
        'type_map': {
            'void': 'void',
            'int': 'int',
            'char': 'char',
            'bool': 'bool',
            'float': 'float',
            'double': 'double',
        },
    },
    'swift': {
        'header': '''// Generated by STUNIR IR to Code Bridge
// Target: Swift

import Foundation

''',
        'function': '''func {name}({params}) -> {return_type} {{
    // TODO: Implement function body
}}
''',
        'param_sep': ', ',
        'type_map': {
            'void': 'Void',
            'int': 'Int',
            'char': 'Character',
            'bool': 'Bool',
            'float': 'Float',
            'double': 'Double',
        },
    },
    'kotlin': {
        'header': '''// Generated by STUNIR IR to Code Bridge
// Target: Kotlin

''',
        'function': '''fun {name}({params}): {return_type} {{
    // TODO: Implement function body
}}
''',
        'param_sep': ', ',
        'type_map': {
            'void': 'Unit',
            'int': 'Int',
            'char': 'Char',
            'bool': 'Boolean',
            'float': 'Float',
            'double': 'Double',
        },
    },
}


def validate_ir_json(data: Dict[str, Any]) -> bool:
    """Validate ir.json against expected schema."""
    if 'schema' not in data or data['schema'] != 'stunir_flat_ir_v1':
        raise ValueError("Missing or invalid 'schema' field (expected 'stunir_flat_ir_v1')")
    
    if 'ir_version' not in data or data['ir_version'] != 'v1':
        raise ValueError("Missing or invalid 'ir_version' field (expected 'v1')")
    
    if 'functions' not in data or not isinstance(data['functions'], list):
        raise ValueError("Missing or invalid 'functions' field")
    
    for i, func in enumerate(data['functions']):
        if 'name' not in func:
            raise ValueError(f"Function {i} missing 'name' field")
        if 'args' not in func:
            raise ValueError(f"Function {func.get('name', i)} missing 'args' field")
        if 'return_type' not in func:
            raise ValueError(f"Function {func.get('name', i)} missing 'return_type' field")
        if 'steps' not in func:
            raise ValueError(f"Function {func.get('name', i)} missing 'steps' field")
    
    return True


def map_type_to_target(ir_type: str, target: str) -> str:
    """Map IR type to target language type."""
    template = TEMPLATES.get(target)
    if not template:
        return ir_type

    type_map = template.get('type_map', {})

    # Handle pointers and complex types - count pointer depth
    pointer_count = ir_type.count('*')
    if pointer_count > 0:
        base_type = ir_type.replace('*', '').strip()
        mapped_base = type_map.get(base_type, base_type)
        if target == 'rust':
            # Rust: *mut T, *mut *mut T, etc.
            return '*mut ' * pointer_count + mapped_base
        elif target == 'go':
            # Go: *T, **T, etc.
            return '*' * pointer_count + mapped_base
        else:
            # C/C++: T *, T **, etc. - combine asterisks without spaces between them
            return mapped_base + ' ' + '*' * pointer_count

    return type_map.get(ir_type, ir_type)


def generate_function_code(func: Dict[str, Any], target: str) -> str:
    """Generate function code for a specific target."""
    template = TEMPLATES[target]
    
    # Map return type
    return_type = map_type_to_target(func['return_type'], target)
    if target == 'go' and return_type == '':
        return_type = ''  # Go uses empty string for void
    
    # Generate parameters
    params = []
    for arg in func.get('args', []):
        arg_type = map_type_to_target(arg['type'], target)
        if target == 'python':
            params.append(f"{arg['name']}: {arg_type}")
        elif target == 'go':
            params.append(f"{arg['name']} {arg_type}")
        else:
            params.append(f"{arg_type} {arg['name']}")
    
    param_str = template['param_sep'].join(params) if params else ''
    if target == 'python' and not params:
        param_str = ''
    
    # Format function
    func_code = template['function'].format(
        name=func['name'],
        params=param_str,
        return_type=return_type
    )
    
    return func_code


def generate_code(ir_data: Dict[str, Any], target: str) -> str:
    """Generate code for all functions in the specified target language."""
    validate_ir_json(ir_data)

    template = TEMPLATES[target]
    code_parts = [template['header']]

    for func in ir_data['functions']:
        func_code = generate_function_code(func, target)
        code_parts.append(func_code)

    # Close class wrapper for languages that need it
    if target in ('java', 'csharp'):
        code_parts.append('}')

    return '\n'.join(code_parts)


def get_file_extension(target: str) -> str:
    """Get file extension for target language."""
    extensions = {
        'cpp': '.cpp',
        'c': '.c',
        'python': '.py',
        'rust': '.rs',
        'go': '.go',
        'javascript': '.js',
        'java': '.java',
        'csharp': '.cs',
        'swift': '.swift',
        'kotlin': '.kt',
    }
    return extensions.get(target, f'.{target}')


def main():
    parser = argparse.ArgumentParser(
        description='STUNIR IR to Code Bridge - Convert ir.json to target language code'
    )
    parser.add_argument(
        '-i', '--input',
        required=True,
        help='Path to ir.json input file'
    )
    parser.add_argument(
        '-o', '--output-dir',
        required=True,
        help='Output directory for generated code'
    )
    parser.add_argument(
        '-t', '--target',
        choices=list(TEMPLATES.keys()),
        help='Target language (default: cpp)'
    )
    parser.add_argument(
        '--all-targets',
        action='store_true',
        help='Generate code for all supported targets'
    )
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Enable verbose output'
    )
    
    args = parser.parse_args()
    
    if not args.target and not args.all_targets:
        parser.error('Either --target or --all-targets must be specified')
    
    # Read ir.json
    try:
        with open(args.input, 'r') as f:
            ir_data = json.load(f)
        if args.verbose:
            print(f"Loaded {args.input}")
            print(f"  Schema: {ir_data.get('schema', 'unknown')}")
            print(f"  Functions: {len(ir_data.get('functions', []))}")
    except FileNotFoundError:
        print(f"Error: Input file not found: {args.input}", file=sys.stderr)
        sys.exit(1)
    except json.JSONDecodeError as e:
        print(f"Error: Invalid JSON in input file: {e}", file=sys.stderr)
        sys.exit(1)
    
    # Validate IR
    try:
        validate_ir_json(ir_data)
    except ValueError as e:
        print(f"Error: IR validation failed: {e}", file=sys.stderr)
        sys.exit(1)
    
    # Determine targets to generate
    if args.all_targets:
        targets = list(TEMPLATES.keys())
    else:
        targets = [args.target]
    
    # Generate code for each target
    output_dir = Path(args.output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)
    
    generated_files = []
    for target in targets:
        try:
            code = generate_code(ir_data, target)
            ext = get_file_extension(target)
            module_name = ir_data.get('module_name', 'generated')
            output_file = output_dir / f"{module_name}{ext}"
            
            with open(output_file, 'w') as f:
                f.write(code)
            
            generated_files.append(output_file)
            if args.verbose:
                print(f"Generated {target}: {output_file}")
        except Exception as e:
            print(f"Error generating {target}: {e}", file=sys.stderr)
            if not args.all_targets:
                sys.exit(1)
    
    print(f"\nGenerated {len(generated_files)} file(s) in {output_dir}")
    for f in generated_files:
        print(f"  {f.name}")


if __name__ == '__main__':
    main()
