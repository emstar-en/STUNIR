use crate::errors::StunirError;
use crate::ir_v1::IrV1;
use anyhow::Result;
use std::fs;
use std::path::Path;
use std::os::unix::fs::PermissionsExt;

pub fn emit(ir: &IrV1, out_file: &str) -> Result<()> {
    let mut code = String::new();

    code.push_str("#!/bin/bash\n");
    code.push_str("# Generated by STUNIR Native Core\n");
    code.push_str("# Target: Bash (Shell Primary)\n");
    code.push_str("set -euo pipefail\n\n");

    for func in &ir.functions {
        code.push_str(&format!("{}() {{\n", func.name));
        if func.body.is_empty() {
            code.push_str("    :\n");
        } else {
            for instr in &func.body {
                match instr.op.as_str() {
                    "print" => {
                        let args = instr.args.iter()
                            .map(|s| format!("\"{}\"", s))
                            .collect::<Vec<_>>()
                            .join(" ");
                        code.push_str(&format!("    echo {}\n", args));
                    }
                    _ => {
                        code.push_str(&format!("    # Unknown Op: {}\n", instr.op));
                    }
                }
            }
        }
        code.push_str("}\n\n");
    }

    code.push_str("# Entry Point\n");
    code.push_str("if [[ \"${BASH_SOURCE[0]}\" == \"${0}\" ]]; then\n");
    code.push_str("    main \"$@\"\n");
    code.push_str("fi\n");

    if let Some(parent) = Path::new(out_file).parent() {
        fs::create_dir_all(parent)?;
    }

    fs::write(out_file, &code)
        .map_err(|e| StunirError::Io(format!("Failed to write Bash file: {}", e)))?;

    let mut perms = fs::metadata(out_file)?.permissions();
    perms.set_mode(0o755);
    fs::set_permissions(out_file, perms)?;

    Ok(())
}
