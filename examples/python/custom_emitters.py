#!/usr/bin/env python3
"""STUNIR Custom Emitters Example

This example demonstrates how to create custom code emitters:
- Extending the base emitter class
- Implementing type mappings
- Generating build scripts
- Creating custom output formats

Usage:
    python custom_emitters.py
"""

import json
import hashlib
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional
from dataclasses import dataclass
from datetime import datetime, timezone

# =============================================================================
# Base Emitter Framework
# =============================================================================

def canonical_json(data: Any) -> str:
    """RFC 8785 compliant canonical JSON."""
    return json.dumps(data, sort_keys=True, separators=(',', ':'), ensure_ascii=False)

def compute_sha256(data: str) -> str:
    """Compute SHA-256 hash."""
    return hashlib.sha256(data.encode('utf-8')).hexdigest()

@dataclass
class EmitterOutput:
    """Container for emitter output."""
    code: str
    filename: str
    language: str
    hash: str
    metadata: Dict[str, Any]

class BaseEmitter(ABC):
    """Abstract base class for code emitters.
    
    To create a custom emitter:
    1. Inherit from BaseEmitter
    2. Implement get_type_mapping()
    3. Implement emit_function()
    4. Optionally override emit_header() and emit_footer()
    """
    
    def __init__(self, ir: Dict[str, Any]):
        self.ir = ir
        self.module_name = ir.get("module", {}).get("name", "unnamed")
        self.version = ir.get("module", {}).get("version", "0.0.0")
        self.functions = ir.get("functions", [])
        self.exports = ir.get("exports", [])
    
    @property
    @abstractmethod
    def language_name(self) -> str:
        """Return the language name."""
        pass
    
    @property
    @abstractmethod
    def file_extension(self) -> str:
        """Return the file extension."""
        pass
    
    @abstractmethod
    def get_type_mapping(self) -> Dict[str, str]:
        """Return IR type to language type mapping."""
        pass
    
    @abstractmethod
    def emit_function(self, func: Dict[str, Any]) -> str:
        """Emit code for a single function."""
        pass
    
    def emit_header(self) -> str:
        """Emit file header (override in subclass)."""
        return f"// Generated by STUNIR for {self.language_name}\n"
    
    def emit_footer(self) -> str:
        """Emit file footer (override in subclass)."""
        return ""
    
    def emit(self) -> EmitterOutput:
        """Generate complete output."""
        parts = [self.emit_header()]
        
        for func in self.functions:
            parts.append(self.emit_function(func))
        
        parts.append(self.emit_footer())
        
        code = "\n".join(parts)
        filename = f"{self.module_name}.{self.file_extension}"
        
        return EmitterOutput(
            code=code,
            filename=filename,
            language=self.language_name,
            hash=compute_sha256(code),
            metadata={
                "module": self.module_name,
                "version": self.version,
                "functions": len(self.functions),
                "generated": datetime.now(timezone.utc).isoformat()
            }
        )
    
    def map_type(self, ir_type: str) -> str:
        """Map an IR type to the target language type."""
        mapping = self.get_type_mapping()
        return mapping.get(ir_type, ir_type)

# =============================================================================
# Example Custom Emitters
# =============================================================================

class GoEmitter(BaseEmitter):
    """Custom emitter for Go language."""
    
    @property
    def language_name(self) -> str:
        return "Go"
    
    @property
    def file_extension(self) -> str:
        return "go"
    
    def get_type_mapping(self) -> Dict[str, str]:
        return {
            "i32": "int32",
            "i64": "int64",
            "f32": "float32",
            "f64": "float64",
            "bool": "bool",
            "str": "string",
            "void": ""
        }
    
    def emit_header(self) -> str:
        return f"""// Generated Go module: {self.module_name}
// Version: {self.version}
// Generated by STUNIR Custom Emitter

package {self.module_name}
"""
    
    def emit_function(self, func: Dict[str, Any]) -> str:
        name = func.get("name", "unnamed")
        sig = func.get("signature", {})
        params = sig.get("params", [])
        returns = sig.get("returns", "void")
        
        # Format parameters
        param_strs = []
        for p in params:
            param_strs.append(f"{p['name']} {self.map_type(p['type'])}")
        params_str = ", ".join(param_strs)
        
        # Format return type
        ret_type = self.map_type(returns)
        ret_str = f" {ret_type}" if ret_type else ""
        
        return f"""
func {name}({params_str}){ret_str} {{
    // Implementation placeholder
    panic("not implemented")
}}
"""

class TypeScriptEmitter(BaseEmitter):
    """Custom emitter for TypeScript."""
    
    @property
    def language_name(self) -> str:
        return "TypeScript"
    
    @property
    def file_extension(self) -> str:
        return "ts"
    
    def get_type_mapping(self) -> Dict[str, str]:
        return {
            "i32": "number",
            "i64": "bigint",
            "f32": "number",
            "f64": "number",
            "bool": "boolean",
            "str": "string",
            "void": "void"
        }
    
    def emit_header(self) -> str:
        return f"""/**
 * Generated TypeScript module: {self.module_name}
 * Version: {self.version}
 * Generated by STUNIR Custom Emitter
 */

"use strict";
"""
    
    def emit_function(self, func: Dict[str, Any]) -> str:
        name = func.get("name", "unnamed")
        sig = func.get("signature", {})
        params = sig.get("params", [])
        returns = sig.get("returns", "void")
        
        # Check if exported
        export_prefix = "export " if name in self.exports else ""
        
        # Format parameters
        param_strs = [f"{p['name']}: {self.map_type(p['type'])}" for p in params]
        params_str = ", ".join(param_strs)
        
        return f"""
{export_prefix}function {name}({params_str}): {self.map_type(returns)} {{
    // Implementation placeholder
    throw new Error("Not implemented");
}}
"""

class SwiftEmitter(BaseEmitter):
    """Custom emitter for Swift."""
    
    @property
    def language_name(self) -> str:
        return "Swift"
    
    @property
    def file_extension(self) -> str:
        return "swift"
    
    def get_type_mapping(self) -> Dict[str, str]:
        return {
            "i32": "Int32",
            "i64": "Int64",
            "f32": "Float",
            "f64": "Double",
            "bool": "Bool",
            "str": "String",
            "void": "Void"
        }
    
    def emit_header(self) -> str:
        return f"""//
// Generated Swift module: {self.module_name}
// Version: {self.version}
// Generated by STUNIR Custom Emitter
//

import Foundation
"""
    
    def emit_function(self, func: Dict[str, Any]) -> str:
        name = func.get("name", "unnamed")
        sig = func.get("signature", {})
        params = sig.get("params", [])
        returns = sig.get("returns", "void")
        
        # Access level based on exports
        access = "public " if name in self.exports else ""
        
        # Format parameters
        param_strs = [f"_ {p['name']}: {self.map_type(p['type'])}" for p in params]
        params_str = ", ".join(param_strs)
        
        ret_type = self.map_type(returns)
        ret_str = f" -> {ret_type}" if ret_type != "Void" else ""
        
        return f"""
{access}func {name}({params_str}){ret_str} {{
    // Implementation placeholder
    fatalError("Not implemented")
}}
"""

class KotlinEmitter(BaseEmitter):
    """Custom emitter for Kotlin."""
    
    @property
    def language_name(self) -> str:
        return "Kotlin"
    
    @property
    def file_extension(self) -> str:
        return "kt"
    
    def get_type_mapping(self) -> Dict[str, str]:
        return {
            "i32": "Int",
            "i64": "Long",
            "f32": "Float",
            "f64": "Double",
            "bool": "Boolean",
            "str": "String",
            "void": "Unit"
        }
    
    def emit_header(self) -> str:
        return f"""/**
 * Generated Kotlin module: {self.module_name}
 * Version: {self.version}
 * Generated by STUNIR Custom Emitter
 */

package com.stunir.generated.{self.module_name}
"""
    
    def emit_function(self, func: Dict[str, Any]) -> str:
        name = func.get("name", "unnamed")
        sig = func.get("signature", {})
        params = sig.get("params", [])
        returns = sig.get("returns", "void")
        
        # Format parameters
        param_strs = [f"{p['name']}: {self.map_type(p['type'])}" for p in params]
        params_str = ", ".join(param_strs)
        
        return f"""
fun {name}({params_str}): {self.map_type(returns)} {{
    // Implementation placeholder
    TODO("Not implemented")
}}
"""

# =============================================================================
# Emitter Registry
# =============================================================================

class EmitterRegistry:
    """Registry for managing available emitters."""
    
    _emitters: Dict[str, type] = {}
    
    @classmethod
    def register(cls, name: str, emitter_class: type):
        """Register an emitter class."""
        cls._emitters[name.lower()] = emitter_class
        print(f"   Registered emitter: {name}")
    
    @classmethod
    def get(cls, name: str) -> Optional[type]:
        """Get an emitter class by name."""
        return cls._emitters.get(name.lower())
    
    @classmethod
    def list(cls) -> List[str]:
        """List all registered emitters."""
        return list(cls._emitters.keys())
    
    @classmethod
    def emit_all(cls, ir: Dict[str, Any]) -> Dict[str, EmitterOutput]:
        """Emit code for all registered targets."""
        results = {}
        for name, emitter_class in cls._emitters.items():
            emitter = emitter_class(ir)
            results[name] = emitter.emit()
        return results

# =============================================================================
# Main Demo
# =============================================================================

def main():
    """Demonstrate custom emitter creation and usage."""
    print("="*60)
    print("STUNIR Custom Emitters Example")
    print("="*60)
    print()
    
    # Register custom emitters
    print("ğŸ“ Registering custom emitters...")
    EmitterRegistry.register("go", GoEmitter)
    EmitterRegistry.register("typescript", TypeScriptEmitter)
    EmitterRegistry.register("swift", SwiftEmitter)
    EmitterRegistry.register("kotlin", KotlinEmitter)
    print()
    
    # Sample IR
    ir = {
        "module": {"name": "calculator", "version": "1.0.0"},
        "functions": [
            {
                "name": "add",
                "signature": {
                    "params": [{"name": "a", "type": "i32"}, {"name": "b", "type": "i32"}],
                    "returns": "i32"
                }
            },
            {
                "name": "divide",
                "signature": {
                    "params": [{"name": "x", "type": "f64"}, {"name": "y", "type": "f64"}],
                    "returns": "f64"
                }
            }
        ],
        "exports": ["add", "divide"]
    }
    
    # Emit code for all targets
    print("ğŸ¯ Emitting code for all targets...")
    print()
    results = EmitterRegistry.emit_all(ir)
    
    # Display results
    for name, output in results.items():
        print(f"{'='*60}")
        print(f"Target: {output.language} ({output.filename})")
        print(f"Hash: {output.hash[:16]}...")
        print(f"{'='*60}")
        print(output.code)
        print()
    
    # Summary
    print("="*60)
    print("Summary")
    print("="*60)
    print(f"Emitters registered: {len(EmitterRegistry.list())}")
    print(f"Languages: {', '.join(EmitterRegistry.list())}")
    print(f"Total outputs: {len(results)}")
    print()
    print("âœ… Custom emitters example completed!")
    
    return 0

if __name__ == "__main__":
    exit(main())
