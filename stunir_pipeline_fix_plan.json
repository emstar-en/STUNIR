{
  "plan_title": "STUNIR Pipeline End-to-End Fix & Comprehensive Verification",
  "version": "2.1",
  "created": "2026-02-05",
  "last_updated": "2026-02-05",
  "objective": "Establish a fully reliable, automated pipeline to transform source code (C/C++/others) into STUNIR Intermediate Representation (IR) and emit correct target code, ensuring semantic fidelity of function signatures, parameter names, and type information across all supported languages.",
  "executive_summary": "The STUNIR pipeline currently fails at multiple stages due to broken native tools and format incompatibilities. This plan establishes Python bridge scripts as the primary solution while maintaining compatibility with native tools where possible. Comprehensive cross-language testing ensures the solution works for all supported inputs.",
  "scope": {
    "in_scope": [
      "Extraction: C/C++ function signature extraction via extract_bc_functions.py",
      "Spec Assembly: extraction.json → spec.json (bridge: bridge_spec_assemble.py)",
      "IR Conversion: spec.json → ir.json (bridge: bridge_spec_to_ir.py)",
      "Code Emission: ir.json → generated code (bridge: bridge_ir_to_code.py)",
      "Multi-language support: C, C++, and extensibility for other languages",
      "Verification: Unit tests, integration tests, and cross-section validation",
      "Performance: Efficient batch processing with fail-fast error handling"
    ],
    "out_of_scope": [
      "Function body translation (focus on signatures)",
      "Compilation of original source",
      "Non-function declarations (structs, enums, typedefs - for now)"
    ]
  },
  "supported_languages": {
    "c": {
      "extensions": [".c", ".h"],
      "features": ["pointers", "arrays", "function pointers", "const/volatile", "variadic"],
      "test_sources": ["gnu_bc", "sample_c_projects"]
    },
    "cpp": {
      "extensions": [".cpp", ".hpp", ".cc", ".cxx"],
      "features": ["references", "const methods", "templates (basic)", "namespaces", "operator overloading"],
      "test_sources": ["cpp_samples", "stl_subset"]
    },
    "extensible": {
      "description": "Architecture supports adding new language frontends",
      "requirements": ["Extraction parser for language", "Type mapping to STUNIR types"]
    }
  },
  "supported_output_targets": {
    "tier_1_core": {
      "description": "Primary targets - full support, comprehensive testing",
      "targets": {
        "cpp": {
          "flag": "TARGET_CPP",
          "extension": ".cpp",
          "features": ["headers", "namespaces", "classes", "templates"],
          "test_priority": "critical",
          "test_cases": [
            "Function signatures with all C++ types",
            "Reference parameters",
            "Const methods",
            "Template instantiations",
            "Namespace handling"
          ]
        },
        "c": {
          "flag": "TARGET_C",
          "extension": ".c",
          "features": ["headers", "structs", "enums", "function pointers"],
          "test_priority": "critical",
          "test_cases": [
            "Standard C89/C99/C11 signatures",
            "Complex pointer types",
            "Array parameters",
            "Function pointer callbacks",
            "Struct/union pointers"
          ]
        },
        "python": {
          "flag": "TARGET_PYTHON",
          "extension": ".py",
          "features": ["type hints", "dataclasses", "protocols"],
          "test_priority": "critical",
          "test_cases": [
            "Function definitions with type hints",
            "Optional/Union types",
            "Callable types for callbacks",
            "List/Dict type annotations"
          ]
        }
      }
    },
    "tier_2_systems": {
      "description": "Systems programming targets - high priority",
      "targets": {
        "rust": {
          "flag": "TARGET_RUST",
          "extension": ".rs",
          "features": ["unsafe blocks", "ffi", "traits"],
          "test_priority": "high",
          "test_cases": [
            "Function signatures with ownership",
            "Raw pointers for C interop",
            "Result/Option return types",
            "extern C blocks"
          ]
        },
        "go": {
          "flag": "TARGET_GO",
          "extension": ".go",
          "features": ["interfaces", "cgo", "goroutines"],
          "test_priority": "high",
          "test_cases": [
            "Function signatures",
            "Pointer types",
            "Slice types for arrays",
            "Cgo bindings"
          ]
        },
        "wasm": {
          "flag": "TARGET_WAT",
          "extension": ".wat",
          "features": ["wasm text format", "memory management"],
          "test_priority": "high",
          "test_cases": [
            "Function exports",
            "Parameter types (i32, i64, f32, f64)",
            "Memory access patterns"
          ]
        }
      }
    },
    "tier_3_web": {
      "description": "Web platform targets - medium priority",
      "targets": {
        "javascript": {
          "flag": "TARGET_JS",
          "extension": ".js",
          "features": ["es6+", "modules", "async/await"],
          "test_priority": "medium",
          "test_cases": [
            "Function declarations",
            "JSDoc type annotations",
            "Callback patterns"
          ]
        },
        "typescript": {
          "flag": "TARGET_TS",
          "extension": ".ts",
          "features": ["interfaces", "generics", "utility types"],
          "test_priority": "medium",
          "test_cases": [
            "Typed function signatures",
            "Interface definitions",
            "Generic constraints"
          ]
        }
      }
    },
    "tier_4_specialized": {
      "description": "Domain-specific targets - specialized testing",
      "targets": {
        "bash": {
          "flag": "TARGET_BASH",
          "extension": ".sh",
          "features": ["strict mode", "functions", "pipes"],
          "test_priority": "low",
          "test_cases": [
            "Function definitions",
            "Parameter passing",
            "Return values"
          ]
        },
        "powershell": {
          "flag": "TARGET_POWERSHELL",
          "extension": ".ps1",
          "features": ["cmdlets", "pipelines", "objects"],
          "test_priority": "low",
          "test_cases": [
            "Function definitions",
            "Parameter attributes",
            "Type accelerators"
          ]
        },
        "assembly": {
          "flag": "TARGET_ASSEMBLY",
          "extension": ".s",
          "features": ["x86_64", "arm64", "calling conventions"],
          "test_priority": "low",
          "test_cases": [
            "Function prologue/epilogue",
            "Register allocation",
            "Stack frame setup"
          ]
        },
        "lisp": {
          "flag": "TARGET_LISP",
          "extension": ".lisp",
          "features": ["s-expressions", "macros", "higher-order functions"],
          "test_priority": "low",
          "test_cases": [
            "Function definitions",
            "Type declarations",
            "Callback patterns"
          ]
        },
        "prolog": {
          "flag": "TARGET_PROLOG",
          "extension": ".pl",
          "features": ["predicates", "facts", "rules"],
          "test_priority": "low",
          "test_cases": [
            "Predicate definitions",
            "Type constraints",
            "Mode declarations"
          ]
        }
      }
    },
    "tier_5_experimental": {
      "description": "Experimental/embedded targets - basic validation",
      "targets": {
        "beam": {
          "description": "Erlang/Elixir VM bytecode",
          "flag": "TARGET_BEAM",
          "test_priority": "experimental"
        },
        "fpga": {
          "description": "Hardware description for FPGAs",
          "flag": "TARGET_FPGA",
          "test_priority": "experimental"
        },
        "gpu": {
          "description": "CUDA/OpenCL kernels",
          "flag": "TARGET_GPU",
          "test_priority": "experimental"
        },
        "embedded": {
          "description": "Bare-metal embedded C",
          "flag": "TARGET_EMBEDDED",
          "test_priority": "experimental"
        }
      }
    }
  },
  "pipeline_requirements": {
    "python_version": "3.8+",
    "dependencies": {
      "jinja2": "Template engine for code generation",
      "rich": "Terminal output formatting and progress bars",
      "pydantic": "Data validation for JSON schemas (contracts)",
      "pytest": "Testing framework",
      "pyyaml": "Configuration management"
    },
    "external_tools": {
      "gcc/g++": "C/C++ compilation verification",
      "rustc": "Rust compilation verification (optional)",
      "python": "Python syntax verification",
      "node": "JS/TS syntax verification (optional)",
      "go": "Go build verification (optional)"
    }
  },
  "current_state": {
    "extraction_layer": {
      "component": "extract_bc_functions.py",
      "status": "FIXED",
      "details": "Parameter parsing now handles complex C/C++ constructs: pointers, arrays, function pointers, references, const qualifiers. All 17 edge case tests pass.",
      "artifacts_resolved": ["argN naming", "type/name conflation", "pointer spacing issues"]
    },
    "spec_assembly": {
      "component": "stunir_spec_assemble_main.exe",
      "status": "BROKEN",
      "issue": "Produces empty functions array",
      "root_cause": "Unknown - likely schema mismatch or path resolution",
      "workaround": "bridge_spec_assemble.py (to be created)"
    },
    "ir_conversion": {
      "component": "stunir_spec_to_ir_main.exe",
      "status": "BROKEN",
      "issue": "Fails with 'invalid path name'",
      "root_cause": "Path handling or schema version mismatch",
      "workaround": "bridge_spec_to_ir.py (to be created)"
    },
    "code_emission": {
      "component": "stunir_ir_to_code_main.exe",
      "status": "BROKEN",
      "issue": "Fails to parse valid IR JSON",
      "root_cause": "JSON parsing strictness or format expectations",
      "workaround": "bridge_ir_to_code.py (to be created)"
    }
  },
  "data_contracts": {
    "extraction_json": {
      "schema_version": "extraction.v1",
      "required_fields": ["source_files", "total_functions", "functions"],
      "function_object": {
        "required": ["name", "return_type", "parameters", "source_file"],
        "optional": ["line_number", "docstring", "attributes"]
      },
      "parameter_object": {
        "required": ["type", "name"],
        "constraints": [
          "type must not contain parameter name",
          "name must be valid C/C++ identifier or argN fallback"
        ]
      },
      "invariants": [
        "total_functions === functions.length",
        "All parameter types are valid C/C++ type expressions",
        "All parameter names are unique within function scope"
      ]
    },
    "spec_json": {
      "schema_version": "stunir.spec.v1",
      "required_fields": ["kind", "meta", "modules"],
      "kind_value": "stunir.spec.v1",
      "module_object": {
        "required": ["name", "functions", "types"],
        "function_object": {
          "required": ["name", "signature"],
          "signature_object": {
            "required": ["args", "return_type"],
            "args_array": {
              "item_object": {
                "required": ["name", "type"]
              }
            }
          }
        }
      },
      "invariants": [
        "kind === 'stunir.spec.v1'",
        "modules.length >= 1",
        "module.functions.length matches extraction"
      ]
    },
    "ir_json": {
      "schema_version": "stunir_flat_ir_v1",
      "required_fields": ["schema", "ir_version", "module_name", "functions"],
      "schema_value": "stunir_flat_ir_v1",
      "ir_version_value": "v1",
      "function_object": {
        "required": ["name", "args", "return_type", "steps"],
        "args_array": {
          "item_object": {
            "required": ["name", "type"]
          }
        },
        "steps_array": {
          "min_length": 1,
          "item_object": {
            "required": ["op"]
          }
        }
      },
      "invariants": [
        "schema === 'stunir_flat_ir_v1'",
        "ir_version === 'v1'",
        "functions.length > 0 for non-empty input",
        "All args have valid identifiers",
        "All steps have valid op codes"
      ]
    }
  },
  "phases": [
    {
      "phase_id": "PHASE_1",
      "name": "Spec Assembly Bridge",
      "description": "Create Python bridge to replace broken stunir_spec_assemble_main.exe",
      "input": "extraction.json",
      "output": "spec.json",
      "deliverable": "bridge_spec_assemble.py",
      "tasks": [
        {
          "id": "1.1",
          "task": "Analyze extraction.json schema and map to spec.json requirements",
          "details": "Review all fields, identify mappings, handle edge cases"
        },
        {
          "id": "1.2",
          "task": "Implement extraction.json parser with validation",
          "details": "Validate against data_contracts.extraction_json, fail fast on errors"
        },
        {
          "id": "1.3",
          "task": "Implement spec.json generator",
          "details": "Generate valid stunir.spec.v1 format with all required fields"
        },
        {
          "id": "1.4",
          "task": "Add command-line interface",
          "details": "Support --input, --output, --verbose flags"
        },
        {
          "id": "1.5",
          "task": "Test with gnu_bc batch_01 extraction.json",
          "details": "Verify all 6 functions are present in output spec.json"
        }
      ],
      "acceptance_criteria": [
        "spec.json functions array length equals extraction.json total_functions",
        "All function names match between extraction and spec",
        "All parameter types and names are preserved",
        "Output validates against stunir.spec.v1 schema"
      ]
    },
    {
      "phase_id": "PHASE_2",
      "name": "IR Conversion Bridge",
      "description": "Create Python bridge to replace broken stunir_spec_to_ir_main.exe",
      "input": "spec.json",
      "output": "ir.json",
      "deliverable": "bridge_spec_to_ir.py",
      "tasks": [
        {
          "id": "2.1",
          "task": "Analyze spec.json schema and map to ir.json requirements",
          "details": "Understand function signature mapping to IR format"
        },
        {
          "id": "2.2",
          "task": "Implement spec.json parser with validation",
          "details": "Validate against data_contracts.spec_json"
        },
        {
          "id": "2.3",
          "task": "Implement stunir_flat_ir_v1 generator",
          "details": "Generate valid IR with schema, ir_version, module_name, functions"
        },
        {
          "id": "2.4",
          "task": "Generate minimal valid steps for each function",
          "details": "Use noop or return operations to satisfy IR schema"
        },
        {
          "id": "2.5",
          "task": "Add command-line interface",
          "details": "Support --input, --output, --module-name flags"
        },
        {
          "id": "2.6",
          "task": "Test with spec.json from Phase 1",
          "details": "Verify IR output matches expected format"
        }
      ],
      "acceptance_criteria": [
        "ir.json schema === 'stunir_flat_ir_v1'",
        "ir.json ir_version === 'v1'",
        "All functions from spec are present in IR",
        "All args have correct name and type",
        "Each function has at least one step"
      ]
    },
    {
      "phase_id": "PHASE_3",
      "name": "Multi-Target Code Emission Bridge",
      "description": "Create extensible Python bridge to replace broken stunir_ir_to_code_main.exe, supporting 15+ targets",
      "input": "ir.json",
      "output": "generated code files (e.g., .cpp, .py, .rs)",
      "deliverable": "bridge_ir_to_code.py",
      "tasks": [
        {
          "id": "3.1",
          "task": "Implement IR parser and type mapping system",
          "details": "Parse stunir_flat_ir_v1 and map types to target languages"
        },
        {
          "id": "3.2",
          "task": "Create template-based code generation engine",
          "details": "Jinja2-based system supporting extensible target languages"
        },
        {
          "id": "3.3",
          "task": "Implement core language templates",
          "details": "C++, C, Python code generation with full type support"
        },
        {
          "id": "3.4",
          "task": "Add CLI and target selection",
          "details": "Command-line interface with --target selection and validation"
        },
        {
          "id": "3.6",
          "task": "Add CLI with multi-target support",
          "details": "Support --input, --output-dir, --target <lang> (or --all)"
        },
        {
          "id": "3.7",
          "task": "Verify generated code syntax",
          "details": "Automated syntax check for generated files (gcc, python -m py_compile, rustc --parse-only)"
        }
      ],
      "acceptance_criteria": [
        "Generated code for Tier 1 languages compiles/interprets without errors",
        "Function signatures match IR spec across all targets",
        "No argN artifacts in any language output",
        "Type mapping is idiomatically correct for each target"
      ]
    },
    {
      "phase_id": "PHASE_4",
      "name": "Integration & Orchestration",
      "description": "Create unified pipeline runner handling multi-target generation and reporting",
      "deliverable": "stunir_pipeline.py",
      "tasks": [
        {
          "id": "4.1",
          "task": "Create unified pipeline runner",
          "details": "Chain stages: extraction -> spec -> IR -> multi-target emission"
        },
        {
          "id": "4.2",
          "task": "Implement target configuration system",
          "details": "JSON config to select targets (e.g. ['cpp', 'rust']) to generate"
        },
        {
          "id": "4.3",
          "task": "Add structured reporting",
          "details": "Generate JSON report: { 'files': ..., 'targets': { 'cpp': 'success', 'rust': 'failed' } }"
        },
        {
          "id": "4.4",
          "task": "Implement caching and parallel emission",
          "details": "Skip unchanged stages, run independent target emitters in parallel"
        },
        {
          "id": "4.5",
          "task": "Implement error recovery strategies",
          "details": "Continue partial success if one target fails"
        }
      ]
    },
    {
      "phase_id": "PHASE_5",
      "name": "Comprehensive Testing",
      "description": "Multi-language, cross-section testing with efficient sampling",
      "deliverable": "test_pipeline.py + test suite",
      "test_categories": {
        "unit_tests": {
          "description": "Test individual bridge components",
          "scope": ["Spec assembly", "IR conversion", "Code emission"],
          "count": "20+ test cases",
          "execution_time": "< 5 seconds"
        },
        "language_specific": {
          "c_tests": {
            "description": "C language specific constructs",
            "test_cases": [
              "Primitive types: int, char, float, double, void",
              "Pointers: single, double, triple level",
              "Arrays: fixed size, variable size, multi-dimensional",
              "Function pointers: simple, with qualifiers, complex signatures",
              "Qualifiers: const, volatile, restrict",
              "Structs/Unions: pointers to structs, struct parameters",
              "Variadic functions: printf-style",
              "Unnamed parameters: fallback to argN"
            ],
            "sources": ["test_extraction_logic.py cases", "gnu_bc execute.c"],
            "count": "15+ test cases"
          },
          "cpp_tests": {
            "description": "C++ language specific constructs",
            "test_cases": [
              "References: single, const references",
              "Const methods: implicit this handling",
              "Namespaces: qualified names",
              "Operator overloading: conversion to regular functions",
              "Templates: basic instantiation (if supported)",
              "Default parameters: handling in signatures",
              "Method pointers: member function pointers"
            ],
            "sources": ["cpp_samples directory", "stl_subset"],
            "count": "10+ test cases"
          }
        },
        "integration_tests": {
          "description": "End-to-end pipeline tests",
          "test_cases": [
            "Single function file",
            "Multi-function file",
            "Header-only library",
            "Real-world project: gnu_bc",
            "Cross-platform paths: Windows/Unix"
          ],
          "count": "5+ test scenarios"
        },
        "regression_tests": {
          "description": "Previously failing cases",
          "test_cases": [
            "Original argN artifact: push_b10_const",
            "Pointer type conflation: program_counter *progctr",
            "Empty spec functions issue",
            "IR parsing failures"
          ],
          "count": "4+ test cases"
        }
      },
      "cross_language_output_tests": {
        "description": "Test code emission across all supported output targets",
        "methodology": "Matrix testing: Core input functions × Output targets",
        "core_test_functions": [
          {
            "name": "simple_function",
            "signature": "int add(int a, int b)",
            "purpose": "Basic parameter and return type handling"
          },
          {
            "name": "pointer_function",
            "signature": "void process(const char *data, size_t len)",
            "purpose": "Pointer types and const qualifiers"
          },
          {
            "name": "callback_function",
            "signature": "int register_callback(int (*cb)(int, void*), void *ctx)",
            "purpose": "Function pointers and complex signatures"
          },
          {
            "name": "array_function",
            "signature": "void fill_buffer(char buf[256], int value)",
            "purpose": "Array parameters"
          },
          {
            "name": "reference_function",
            "signature": "void swap(int &a, int &b)",
            "purpose": "C++ reference types"
          }
        ],
        "target_test_matrix": {
          "tier_1_core": {
            "targets": ["cpp", "c", "python"],
            "test_all_core_functions": true,
            "compilation_check": true,
            "syntax_validation": true
          },
          "tier_2_systems": {
            "targets": ["rust", "go", "wasm"],
            "test_all_core_functions": true,
            "compilation_check": true,
            "syntax_validation": true
          },
          "tier_3_web": {
            "targets": ["javascript", "typescript"],
            "test_all_core_functions": true,
            "syntax_validation": true,
            "linting": "eslint/tslint"
          },
          "tier_4_specialized": {
            "targets": ["bash", "powershell", "assembly", "lisp", "prolog"],
            "test_subset": ["simple_function", "pointer_function"],
            "syntax_validation": true
          }
        },
        "efficiency_optimizations": [
          "Reuse same IR for all target tests (generate once, emit many)",
          "Parallel target emission where possible",
          "Skip compilation for targets without compilers installed",
          "Cache successful emissions to avoid re-generation"
        ],
        "validation_rules": [
          "Function name preserved across all targets",
          "Parameter count matches in all outputs",
          "Type semantics preserved (pointers remain pointers, etc.)",
          "No argN artifacts in any output",
          "Generated code is syntactically valid for target language"
        ]
      },
      "target_specific_validation": {
        "cpp": {
          "compiler": "g++ -std=c++17 -Wall -Werror -c",
          "checks": ["syntax", "warnings", "type safety"]
        },
        "c": {
          "compiler": "gcc -std=c11 -Wall -Werror -c",
          "checks": ["syntax", "warnings", "type safety"]
        },
        "python": {
          "tool": "python -m py_compile",
          "checks": ["syntax", "importability"],
          "additional": "mypy type checking if available"
        },
        "rust": {
          "compiler": "rustc --crate-type lib --emit=metadata",
          "checks": ["syntax", "borrow checker warnings"]
        },
        "go": {
          "tool": "go build -o /dev/null",
          "checks": ["syntax", "type checking"]
        },
        "wasm": {
          "tool": "wat2wasm (if available)",
          "checks": ["text format validity"]
        },
        "javascript": {
          "tool": "node --check",
          "checks": ["syntax"]
        },
        "typescript": {
          "tool": "tsc --noEmit",
          "checks": ["syntax", "type checking"]
        }
      },
      "efficiency_strategy": {
        "sampling_method": "Stratified sampling across type constructs",
        "selection_criteria": [
          "Cover all primitive types",
          "Cover all pointer/array levels (0-3)",
          "Cover all qualifier combinations",
          "Include at least one real-world complex function per language"
        ],
        "max_test_cases": 50,
        "parallel_execution": false,
        "fail_fast": true,
        "caching": "Cache extraction results, skip unchanged files"
      }
    }
  ],
  "quality_assurance": {
    "code_review_checklist": [
      "All bridge scripts have input validation",
      "Error messages are descriptive and actionable",
      "JSON output is pretty-printed for debugging",
      "All functions have docstrings",
      "Command-line interfaces follow Unix conventions"
    ],
    "testing_requirements": [
      "Minimum 80% code coverage for bridge scripts",
      "All edge cases from test_extraction_logic.py must pass",
      "Generated code must compile with -Wall -Werror",
      "Pipeline must handle 100+ function files"
    ]
  },
  "risk_mitigation": {
    "native_tool_unfixable": {
      "risk": "Native tools cannot be repaired",
      "mitigation": "Python bridges are primary solution, native tools deprecated"
    },
    "performance_issues": {
      "risk": "Python bridges too slow for large codebases",
      "mitigation": "Implement caching, parallel processing, optimize hot paths"
    },
    "type_system_complexity": {
      "risk": "Complex C++ types not fully supported",
      "mitigation": "Document limitations, graceful degradation to void*"
    },
    "schema_evolution": {
      "risk": "STUNIR schema changes break bridges",
      "mitigation": "Version detection, schema validation, migration scripts"
    }
  },
  "success_criteria": {
    "functional": [
      "Pipeline runs end-to-end without errors",
      "All test cases pass (unit, integration, regression)",
      "Generated code compiles successfully",
      "No argN artifacts in any output"
    ],
    "performance": [
      "Single file processing < 5 seconds",
      "Batch of 50 files < 2 minutes",
      "Memory usage < 500MB for large files"
    ],
    "quality": [
      "Code coverage > 80%",
      "Zero critical bugs",
      "Documentation complete"
    ]
  },
  "timeline": {
    "phase_1": "2-3 days",
    "phase_2": "2-3 days",
    "phase_3": "5-7 days (increased for multi-target)",
    "phase_4": "2 days",
    "phase_5": "5-7 days (increased for matrix testing)",
    "total": "16-22 days"
  }
}