{
  "category": [
    "ir",
    "canonicalization"
  ],
  "evidence": [
    {
      "lines": {
        "end": 70,
        "start": 28
      },
      "note": "Shows spec_to_ir writing build/ir.json and then constructing stub/placeholder manifests rather than emitting asm/ir/*.dcbor with a strict manifest.",
      "path": "scripts/build.sh",
      "sha256": "62e9cfb279b0c0f1519117f570d27e8c40146fb0cef802398765160523f17b58",
      "snippet_sha256": "25f06e223bc1e3c782f3840a52e654aeefb92e767ccaf1de6cd10dfbd2e3110a"
    },
    {
      "lines": {
        "end": 120,
        "start": 1
      },
      "note": "Profile 3 contract requires exactly one IR record and an object-store mapping; canonical IR bytes/hashes must be bindable.",
      "path": "contracts/stunir_profile3_contract.json",
      "sha256": "2b0943c673eb1fe985dd744e5b7f12779b2db3661320217ee2f136563fcb48b5",
      "snippet_sha256": "9d597b07943124daf9753b26b34f6a6ff85d8df2232e1e859803e534c9620aad"
    }
  ],
  "expected": [
    "Haskell-native canonicalization: spec JSON root \u2192 canonical IR bytes in dCBOR normal form (reject floats, stable map key ordering, stable integers/byte strings).",
    "IR emitted as asm/ir/*.dcbor with a complete, strict receipts/ir_manifest.json binding the exact set and sha256 of each file.",
    "Downstream receipt/core-id hashing uses the canonical IR bytes as inputs (UN)."
  ],
  "id": "ISSUE.IR.0001",
  "impact": {
    "breaks_build": true,
    "breaks_local_verify_strict": true,
    "breaks_receipt_generation": true
  },
  "proposed_fixes": [
    {
      "description": "Define the IR dCBOR normal form contract (Unique Normals) and implement canonicalization in the Haskell-native tool (stunir-native-hs).",
      "touched_paths": [
        "tools/native/haskell/",
        "contracts/"
      ]
    },
    {
      "description": "Update scripts/build.sh and dispatcher to produce asm/ir/*.dcbor + receipts/ir_manifest.json using the Haskell-native canonicalizer; eliminate build/ir.json as the normative artifact.",
      "touched_paths": [
        "scripts/build.sh",
        "scripts/lib/dispatch.sh"
      ]
    }
  ],
  "related": [
    "ISSUE.DISPATCH.0001",
    "ISSUE.DISPATCH.0002",
    "ISSUE.BUILD.0001",
    "ISSUE.BUILD.0002",
    "ISSUE.BUILD.0003",
    "ISSUE.NATIVE.0001",
    "ISSUE.NATIVE.0002",
    "ISSUE.NATIVE.0003",
    "ISSUE.HASKELL.0001",
    "ISSUE.HASKELL.0002"
  ],
  "reproduction": [
    "./scripts/build.sh",
    "./scripts/verify.sh --local --strict"
  ],
  "root_causes": [
    {
      "details": "Current build path treats IR as JSON (build/ir.json) and does not emit the required dCBOR-normalized IR artifacts (asm/ir/*.dcbor).",
      "type": "non_un_ir_format"
    },
    {
      "details": "No Haskell-native canonicalizer exists as the source of truth for IR normal form; dispatcher/build graph are not aligned to produce IR-as-bytes artifacts.",
      "type": "missing_canonical_backend"
    }
  ],
  "schema": "stunir.issues.issue.v1",
  "severity": "blocking",
  "status": "open",
  "symptoms": [
    "scripts/build.sh generates build/ir.json and writes placeholder receipts/ir_manifest.json rather than producing a dCBOR-normalized IR set.",
    "The pipeline cannot support Unique Normals for IR bytes/hashes without a canonical dCBOR emission step.",
    "Haskell-first strategy requires spec\u2192IR canonicalization to be defined by the compiled trust anchor, not by Python JSON."
  ],
  "title": "IR canonicalization is not dCBOR/UN: build pipeline emits build/ir.json stubs instead of asm/ir/*.dcbor (Haskell must be canonical)",
  "workarounds": [
    {
      "commands": [],
      "description": "None consistent with Haskell-first UN; current JSON IR path is a bootstrap-only placeholder and should not be treated as canonical."
    }
  ]
}