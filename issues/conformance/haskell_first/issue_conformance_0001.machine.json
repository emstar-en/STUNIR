{"category":["conformance","haskell_first"],"evidence":[{"lines":{"end":632,"start":512},"note":"Verifier defines strict canonical JSON/receipt core-id expectations; conformance must match these bytes/hashes exactly.","path":"tools/verify_build.py","sha256":"7eb1cee982e44b32a3d3e795ec36b287912fba522bcbfb65d0f8a1659b9c4bb8","snippet_sha256":"ed51f1e401823dc514dc46c3b90f3d6a46f7b5509df9d1ac49d03dc33f956730"}],"expected":["A repo-level conformance harness that selects Haskell-native as reference and checks Rust/Python backends produce identical bytes/hashes for: IR artifacts, receipts, and pack/root attestations (where applicable).","Deterministic test vectors stored in-repo (fixtures) with pinned expected sha256 digests.","Clear failure reporting identifying which backend diverged and at which artifact (path + digest)."],"id":"ISSUE.CONFORMANCE.0001","impact":{"breaks_build":false,"breaks_local_verify_strict":true,"breaks_receipt_generation":true},"proposed_fixes":[{"description":"Add fixtures (spec examples + expected IR/receipt digests) and a runner script that executes Haskell-native, Rust, and Python implementations and diffs outputs at the byte level.","touched_paths":["tests/","scripts/"]},{"description":"Require conformance checks in CI/verify profile(s) for strict mode once Haskell-native exists.","touched_paths":["scripts/verify.sh","tools/verify_build.py"]}],"related":["ISSUE.HASKELL.0001","ISSUE.HASKELL.0002","ISSUE.IR.0001"],"reproduction":["./scripts/verify.sh --local --strict"],"root_causes":[{"details":"No test vectors + runner exist that execute Haskell-native reference and assert Rust/Python outputs match exactly for selected fixtures.","type":"missing_conformance_suite"}],"schema":"stunir.issues.issue.v1","severity":"high","status":"open","symptoms":["Even after adding a Haskell-native trust anchor, the repo lacks an automated harness to enforce byte-identical outputs from Rust/Python backends.","Receipt core-id hashing and canonical JSON requirements are strict; any drift in canonicalization or field sets causes verification failures.","Without conformance tests, 'Haskell is canonical' cannot be enforced across backends (UN)."],"title":"Add Haskell-first conformance harness: Rust/Python must match Haskell bytes/hashes for IR + receipts (Unique Normals)","workarounds":[{"commands":[],"description":"Manual spot-checking of digests is possible but not sufficient for UN enforcement."}]}
