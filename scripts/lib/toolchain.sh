#!/usr/bin/env bash
# scripts/lib/toolchain.sh
# Sources the toolchain lockfile and exports STUNIR_TOOL_* variables.

LOCKFILE="build/local_toolchain.lock.json"

if [[ ! -f "$LOCKFILE" ]]; then
    if [[ "${STUNIR_STRICT:-1}" == "1" ]]; then
        echo "ERROR: Strict mode requires $LOCKFILE. Run scripts/discover_toolchain.sh first." >&2
        exit 1
    else
        # Permissive mode: do nothing, let build.sh fall back to PATH
        return 0
    fi
fi

# Simple JSON parser for bash (grep/sed based, avoids python dependency for bootstrapping)
# Looks for: "logical_name": { "path": "..." }
get_tool_path() {
    local tool_name="$1"
    # Grep for the tool block, then the path line. 
    # This is fragile but works for the specific format generated by discover_toolchain.sh
    grep -A 2 "\"$tool_name\": {" "$LOCKFILE" | grep '"path":' | cut -d '"' -f 4
}

# Export known tools
# Python
TP_PYTHON="$(get_tool_path "python")"
if [[ -n "$TP_PYTHON" ]]; then export STUNIR_TOOL_PYTHON="$TP_PYTHON"; fi

# Git
TP_GIT="$(get_tool_path "git")"
if [[ -n "$TP_GIT" ]]; then export STUNIR_TOOL_GIT="$TP_GIT"; fi

# Bash
TP_BASH="$(get_tool_path "bash")"
if [[ -n "$TP_BASH" ]]; then export STUNIR_TOOL_BASH="$TP_BASH"; fi

# CC
TP_CC="$(get_tool_path "cc")"
if [[ -n "$TP_CC" ]]; then export CC="$TP_CC"; fi

# Rust
TP_RUSTC="$(get_tool_path "rustc")"
if [[ -n "$TP_RUSTC" ]]; then export STUNIR_TOOL_RUSTC="$TP_RUSTC"; fi

TP_CARGO="$(get_tool_path "cargo")"
if [[ -n "$TP_CARGO" ]]; then export STUNIR_TOOL_CARGO="$TP_CARGO"; fi

# Native Binary
TP_NATIVE="$(get_tool_path "stunir_native")"
if [[ -n "$TP_NATIVE" ]]; then export STUNIR_BIN="$TP_NATIVE"; fi
