{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}

{-| 
Module      : STUNIR.SemanticIR.Emitters.Base
Description : Base emitter typeclass and common types for STUNIR emitters
Copyright   : (c) STUNIR Team, 2026
License     : MIT
Maintainer  : stunir@example.com

Base infrastructure for all Semantic IR emitters.
Provides common types, typeclasses, and utilities.
Based on Ada SPARK emitter specifications.
-}

module STUNIR.SemanticIR.Emitters.Base
  ( -- * Emitter Status
    EmitterStatus(..)
  , -- * Emitter Result
    EmitterResult(..)
  , GeneratedFile(..)
  , -- * Emitter Configuration
    EmitterConfig(..)
  , defaultEmitterConfig
  , -- * Base Emitter Typeclass
    Emitter(..)
  , -- * Utility Functions
    validateIR
  , computeFileHash
  , getDO178CHeader
  , getSTUNIRComment
  , indentString
  ) where

import Data.Text (Text)
import qualified Data.Text as T
import Data.ByteString (ByteString)
import qualified Data.ByteString as BS
import qualified Data.ByteString.Char8 as BS8
import Crypto.Hash (hash, Digest, SHA256)
import Data.ByteArray.Encoding (convertToBase, Base(Base16))
import GHC.Generics
import STUNIR.SemanticIR.Emitters.Types

-- | Emitter result status (matching SPARK Emitter_Status enumeration)
data EmitterStatus
  = Success
  | ErrorInvalidIR
  | ErrorWriteFailed
  | ErrorUnsupportedType
  | ErrorBufferOverflow
  | ErrorInvalidArchitecture
  deriving (Eq, Show, Generic)

-- | Generated file record (matching SPARK Generated_File_Record)
data GeneratedFile = GeneratedFile
  { gfPath :: !Text      -- ^ Relative path
  , gfHash :: !Text      -- ^ SHA-256 hash (64 hex chars)
  , gfSize :: !Int       -- ^ File size in bytes
  } deriving (Eq, Show, Generic)

-- | Emitter result (matching SPARK Emitter_Result record)
data EmitterResult = EmitterResult
  { erStatus       :: !EmitterStatus
  , erFiles        :: ![GeneratedFile]
  , erTotalSize    :: !Int
  , erErrorMessage :: !(Maybe Text)
  } deriving (Eq, Show, Generic)

-- | Emitter configuration
data EmitterConfig = EmitterConfig
  { ecOutputDir        :: !FilePath
  , ecModuleName       :: !Text
  , ecAddComments      :: !Bool
  , ecAddDO178CHeaders :: !Bool
  , ecMaxLineLength    :: !Int
  , ecIndentSize       :: !Int
  , ecDeterministic    :: !Bool  -- ^ For reproducible hash generation
  } deriving (Eq, Show, Generic)

-- | Default emitter configuration
defaultEmitterConfig :: FilePath -> Text -> EmitterConfig
defaultEmitterConfig outputDir moduleName = EmitterConfig
  { ecOutputDir = outputDir
  , ecModuleName = moduleName
  , ecAddComments = True
  , ecAddDO178CHeaders = True
  , ecMaxLineLength = 100
  , ecIndentSize = 4
  , ecDeterministic = True
  }

-- | Base emitter typeclass
-- All emitters must implement this typeclass
class Emitter e where
  -- | Emit code from IR module
  emit :: e -> IRModule -> Either Text EmitterResult

-- | Validate IR module structure
validateIR :: IRModule -> Bool
validateIR irModule =
  not (T.null (imIRVersion irModule)) &&
  not (T.null (imModuleName irModule)) &&
  True  -- Additional validation can be added

-- | Compute SHA-256 hash of content
computeFileHash :: Text -> Text
computeFileHash content =
  let bytes = BS8.pack (T.unpack content)
      digest = hash bytes :: Digest SHA256
  in T.pack $ BS8.unpack $ convertToBase Base16 digest

-- | Generate DO-178C compliant header comment
getDO178CHeader :: Bool -> Text -> Text
getDO178CHeader False _ = ""
getDO178CHeader True description = T.unlines
  [ "/*"
  , " * STUNIR Generated Code"
  , " * DO-178C Level A Compliant"
  , " * " <> description
  , " *"
  , " * This file was generated by STUNIR Semantic IR Emitter"
  , " * Based on formally verified Ada SPARK implementation"
  , " *"
  , " * WARNING: Do not modify this file manually."
  , " * All changes must be made to the source IR."
  , " */"
  , ""
  ]

-- | Generate STUNIR comment with specified prefix
getSTUNIRComment :: Bool -> Text -> Text -> Text
getSTUNIRComment False _ _ = ""
getSTUNIRComment True commentPrefix text =
  commentPrefix <> " STUNIR: " <> text <> "\n"

-- | Generate indentation string
indentString :: Int -> Int -> Text
indentString indentSize level =
  T.replicate (indentSize * level) " "
