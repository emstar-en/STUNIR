#!/usr/bin/env python3
"""Emit deterministic Common Lisp source artifacts from the emitted IR manifest.

v0 semantics: this is an "IR introspection" backend.
It binds the IR manifest contents into deterministic Lisp source files.

Targets:
- variant=portable  -> asm/lisp/portable/* (no runtime required)
- variant=sbcl      -> asm/lisp/sbcl/* (SBCL-backed execution is handled by scripts/build.sh)
"""

from __future__ import annotations

import argparse
import hashlib
import json
from pathlib import Path
from typing import Any, Dict, List


def sha256_bytes(b: bytes) -> str:
    return hashlib.sha256(b).hexdigest()


def load_ir_manifest(path: Path) -> Dict[str, Any]:
    obj = json.loads(path.read_text(encoding="utf-8"))
    if not isinstance(obj, dict) or obj.get("schema") not in ("stunir.ir_manifest.v2",):
        raise SystemExit(f"Unexpected IR manifest schema in {path}: {obj.get('schema')!r}")
    return obj


def write_text(path: Path, text: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(text, encoding="utf-8", newline="
")


def lisp_string(s: str) -> str:
    out = ['"']
    for ch in s:
        o = ord(ch)
        if ch == "\":
            out.append("\\")
        elif ch == '"':
            out.append('\"')
        elif ch == "
":
            out.append("\n")
        elif ch == "":
            out.append("\r")
        elif ch == "	":
            out.append("\t")
        elif o < 32:
            out.append("\u%04x" % o)
        else:
            out.append(ch)
    out.append('"')
    return "".join(out)


def gen_package_lisp() -> str:
    return (
        ";; Generated by STUNIR (lisp backend, v0)
"
        "(defpackage #:stunir.generated
"
        "  (:use #:cl)
"
        "  (:export #:main))
"
        "
"
        "(in-package #:stunir.generated)
"
    )


def gen_runtime_lisp() -> str:
    return (
        ";; Generated by STUNIR (lisp backend, v0)
"
        "(in-package #:stunir.generated)

"
        ";; Minimal, portable JSON writer for our embedded alist/array shape.
"
        "(defun %json-escape-string (s)
"
        "  (with-output-to-string (out)
"
        "    (write-char #\" out)
"
        "    (loop for ch across s do
"
        "      (case ch
"
        "        (#\\ (write-string "\\\\" out))
"
        "        (#\" (write-string "\\\"" out))
"
        "        (#\Newline (write-string "\\n" out))
"
        "        (#\Return (write-string "\\r" out))
"
        "        (#\Tab (write-string "\\t" out))
"
        "        (t
"
        "          (let ((code (char-code ch)))
"
        "            (if (< code 32)
"
        "                (format out "\\u~4,'0x" code)
"
        "                (write-char ch out))))))
"
        "    (write-char #\" out)))

"
        "(defun %json-object-pairs-p (x)
"
        "  (and (consp x)
"
        "       (every (lambda (e) (and (consp e) (stringp (car e)))) x)))

"
        "(defun %json-write (x out)
"
        "  (cond
"
        "    ((null x) (write-string "null" out))
"
        "    ((eq x t) (write-string "true" out))
"
        "    ((stringp x) (write-string (%json-escape-string x) out))
"
        "    ((integerp x) (princ x out))
"
        "    ((%json-object-pairs-p x)
"
        "     (write-char #\{ out)
"
        "     (let* ((pairs (sort (copy-list x) #'string< :key #'car))
"
        "            (first t))
"
        "       (dolist (kv pairs)
"
        "         (unless first (write-char #\, out))
"
        "         (setf first nil)
"
        "         (%json-write (car kv) out)
"
        "         (write-char #\: out)
"
        "         (%json-write (cdr kv) out)))
"
        "     (write-char #\} out))
"
        "    ((consp x)
"
        "     (write-char #\[ out)
"
        "     (let ((first t))
"
        "       (dolist (v x)
"
        "         (unless first (write-char #\, out))
"
        "         (setf first nil)
"
        "         (%json-write v out)))
"
        "     (write-char #\] out))
"
        "    (t (error "Unsupported JSON value type: ~S" x))))

"
        "(defun json-dumps (x)
"
        "  (with-output-to-string (out)
"
        "    (%json-write x out)))
"
    )


def gen_program_lisp(*, variant: str, embedded_obj: Dict[str, Any]) -> str:
    def to_lisp(x: Any) -> str:
        if x is None:
            return "nil"
        if x is True:
            return "t"
        if x is False:
            return "nil"
        if isinstance(x, int):
            return str(x)
        if isinstance(x, str):
            return lisp_string(x)
        if isinstance(x, list):
            return "(" + " ".join(to_lisp(v) for v in x) + ")"
        if isinstance(x, dict):
            items = []
            for k in sorted(x.keys()):
                items.append(f"({lisp_string(str(k))} . {to_lisp(x[k])})")
            return "(" + " ".join(items) + ")"
        raise TypeError(f"unsupported type for embedding: {type(x)}")

    embedded_lisp = to_lisp(embedded_obj)

    return (
        ";; Generated by STUNIR (lisp backend, v0)
"
        ";; Script entry. Loads package/runtime and prints deterministic JSON derived from IR manifest.
"
        "(let* ((here (or *load-pathname* (truename ".")))
"
        "       (dir (make-pathname :name nil :type nil :defaults here)))
"
        "  (load (merge-pathnames "package.lisp" dir))
"
        "  (load (merge-pathnames "runtime.lisp" dir)))

"
        "(in-package #:stunir.generated)

"
        f"(defparameter *stunir-embedded* {embedded_lisp})

"
        "(defun main ()
"
        "  (write-string (json-dumps *stunir-embedded*) *standard-output*)
"
        "  (write-char #\Newline *standard-output*)
"
        "  (finish-output *standard-output*))

"
        "(main)
"
    )


def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("--variant", required=True, choices=["portable", "sbcl"])
    ap.add_argument("--ir-manifest", required=True)
    ap.add_argument("--out-root", required=True)
    args = ap.parse_args()

    ir_manifest_path = Path(args.ir_manifest)
    ir = load_ir_manifest(ir_manifest_path)
    ir_manifest_sha256 = sha256_bytes(ir_manifest_path.read_bytes())

    files = ir.get("files") or []
    if not isinstance(files, list):
        raise SystemExit("IR manifest files must be a list")

    norm_files: List[Dict[str, Any]] = []
    for f in files:
        if not isinstance(f, dict):
            continue
        norm_files.append(
            {
                "file": f.get("file"),
                "sha256": f.get("sha256"),
                "bytes_len": f.get("bytes_len"),
            }
        )
    norm_files.sort(key=lambda x: str(x.get("file") or ""))

    embedded = {
        "schema": "stunir.lisp_sample_run.v0",
        "variant": args.variant,
        "ir_manifest_sha256": ir_manifest_sha256,
        "ir_files_count": len(norm_files),
        "ir_files": norm_files,
    }

    out_root = Path(args.out_root)
    out_root.mkdir(parents=True, exist_ok=True)

    write_text(out_root / "package.lisp", gen_package_lisp())
    write_text(out_root / "runtime.lisp", gen_runtime_lisp())
    write_text(out_root / "program.lisp", gen_program_lisp(variant=args.variant, embedded_obj=embedded))

    readme = (
        f"# STUNIR Lisp target ({args.variant})
"
        "This directory is generated.

"
        "- `program.lisp` prints a deterministic JSON summary embedded from `receipts/ir_manifest.json`.
"
        "- This is a v0 introspection backend, intended to bootstrap the pipeline and determinism checks.

"
        "Run (SBCL variant):
"
        "- `sbcl --noinform --non-interactive --disable-debugger --script program.lisp`
"
    )
    write_text(out_root / "README.md", readme)


if __name__ == "__main__":
    main()
