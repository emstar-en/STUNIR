#!/usr/bin/env python3
"""STUNIR Smalltalk Emitter - Generate Smalltalk code from OOP IR.

This emitter generates Smalltalk code supporting:
- Class definitions with subclass:instanceVariableNames:...
- Method definitions (instance and class side)
- Message passing (unary, binary, keyword)
- Blocks and closures
- Cascaded messages
- Collection literals
- Control structures as messages

Usage:
    from targets.oop.smalltalk_emitter import SmalltalkEmitter
    
    emitter = SmalltalkEmitter()
    result = emitter.emit(ir)
    print(result.code)
"""

from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any, Set
import json
import hashlib


# =============================================================================
# Emitter Result
# =============================================================================

@dataclass
class EmitterResult:
    """Result of code emission."""
    code: str = ''
    manifest: Dict[str, Any] = field(default_factory=dict)
    warnings: List[str] = field(default_factory=list)
    file_extension: str = '.st'


# =============================================================================
# Exceptions
# =============================================================================

class SmalltalkEmitterError(Exception):
    """Base error for Smalltalk emitter."""
    pass


class UnsupportedFeatureError(SmalltalkEmitterError):
    """Feature not supported by Smalltalk emitter."""
    pass


# =============================================================================
# Smalltalk Emitter
# =============================================================================

class SmalltalkEmitter:
    """Emit Smalltalk code from OOP IR."""
    
    DIALECT = 'smalltalk'
    FILE_EXTENSION = '.st'
    
    # Binary operators recognized by Smalltalk
    BINARY_OPS: Set[str] = {
        '+', '-', '*', '/', '//', '\\\\', '@', ',',
        '<', '>', '<=', '>=', '=', '~=', '==', '~~',
        '&', '|', '**'
    }
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """Initialize the emitter.
        
        Args:
            config: Optional configuration dictionary
        """
        self.config = config or {}
        self._indent = 0
        self._warnings: List[str] = []
        self._current_class: Optional[str] = None
    
    def emit(self, ir: Dict[str, Any]) -> EmitterResult:
        """Emit Smalltalk code from IR.
        
        Args:
            ir: IR dictionary (program, class, or method)
            
        Returns:
            EmitterResult with code and manifest
        """
        self._warnings = []
        self._indent = 0
        
        kind = ir.get('kind', '')
        
        if kind == 'smalltalk_program':
            code = self._emit_program(ir)
        elif kind == 'class_def':
            code = self._emit_class_definition(ir)
        elif kind == 'method_def':
            code = self._emit_method_definition(ir)
        else:
            # Try to emit as expression
            code = self._emit_expression(ir)
        
        manifest = self._generate_manifest(ir, code)
        
        return EmitterResult(
            code=code,
            manifest=manifest,
            warnings=self._warnings,
            file_extension=self.FILE_EXTENSION
        )
    
    def emit_class(self, ir: Dict[str, Any]) -> str:
        """Emit a single class definition."""
        return self._emit_class_definition(ir)
    
    def emit_method(self, ir: Dict[str, Any]) -> str:
        """Emit a single method definition."""
        return self._emit_method_definition(ir)
    
    # =========================================================================
    # Program Emission
    # =========================================================================
    
    def _emit_program(self, prog: Dict[str, Any]) -> str:
        """Emit complete Smalltalk program."""
        parts = []
        
        # File header
        parts.append('"Generated by STUNIR Smalltalk Emitter"')
        parts.append('')
        
        # Classes
        for cls in prog.get('classes', []):
            parts.append(self._emit_class_definition(cls))
            parts.append('')
            
            # Emit methods for this class
            class_name = cls.get('name', '')
            for method in prog.get('methods', []):
                if method.get('class_name') == class_name:
                    self._current_class = class_name
                    parts.append(self._emit_method_with_header(method))
                    parts.append('')
        
        # Workspace code
        workspace = prog.get('workspace_code', [])
        if workspace:
            parts.append('"Workspace code"')
            for expr in workspace:
                parts.append(self._emit_expression(expr) + '.')
            parts.append('')
        
        return '\n'.join(parts)
    
    # =========================================================================
    # Class Definition
    # =========================================================================
    
    def _emit_class_definition(self, cls: Dict[str, Any]) -> str:
        """Emit class definition.
        
        Format: 
            Object subclass: #ClassName
                instanceVariableNames: 'var1 var2'
                classVariableNames: 'ClassVar1'
                poolDictionaries: ''
                category: 'Category'
        """
        superclass = cls.get('superclass', 'Object')
        name = cls.get('name', 'NewClass')
        inst_vars = ' '.join(cls.get('instance_variables', []))
        class_vars = ' '.join(cls.get('class_variables', []))
        pools = ' '.join(cls.get('pool_dictionaries', []))
        category = cls.get('category', 'STUNIR-Generated')
        
        return (
            f"{superclass} subclass: #{name}\n"
            f"\tinstanceVariableNames: '{inst_vars}'\n"
            f"\tclassVariableNames: '{class_vars}'\n"
            f"\tpoolDictionaries: '{pools}'\n"
            f"\tcategory: '{category}'"
        )
    
    # =========================================================================
    # Method Definition
    # =========================================================================
    
    def _emit_method_definition(self, method: Dict[str, Any]) -> str:
        """Emit method definition body."""
        selector = method.get('selector', 'method')
        params = method.get('parameters', [])
        temps = method.get('temporaries', [])
        stmts = method.get('statements', [])
        primitive = method.get('primitive')
        
        lines = []
        
        # Build method pattern
        msg_type = method.get('message_type', 'unary')
        if msg_type == 'keyword':
            pattern = self._build_keyword_pattern(selector, params)
        elif msg_type == 'binary':
            pattern = f"{selector} {params[0]}" if params else selector
        else:  # unary
            pattern = selector
        
        lines.append(pattern)
        
        # Primitive
        if primitive is not None:
            lines.append(f"\t<primitive: {primitive}>")
        
        # Temporaries
        if temps:
            lines.append(f"\t| {' '.join(temps)} |")
        
        # Statements
        for i, stmt in enumerate(stmts):
            stmt_code = self._emit_statement(stmt)
            if i == len(stmts) - 1:
                # Last statement - add return if not already there
                if not stmt_code.strip().startswith('^'):
                    stmt_code = f"^{stmt_code}"
            lines.append(f"\t{stmt_code}")
        
        return '\n'.join(lines)
    
    def _emit_method_with_header(self, method: Dict[str, Any]) -> str:
        """Emit method with class header."""
        class_name = method.get('class_name', self._current_class or 'Object')
        is_class_method = method.get('is_class_method', False)
        category = method.get('category', 'as yet unclassified')
        
        if is_class_method:
            header = f"!{class_name} class methodsFor: '{category}'!"
        else:
            header = f"!{class_name} methodsFor: '{category}'!"
        
        body = self._emit_method_definition(method)
        
        return f"{header}\n{body}\n!"
    
    def _build_keyword_pattern(self, selector: str, params: List[str]) -> str:
        """Build keyword message pattern.
        
        Example: 'at:put:' with ['index', 'value'] -> 'at: index put: value'
        """
        if not selector:
            return ''
        
        # Split selector by colons
        keywords = [k for k in selector.split(':') if k]
        
        parts = []
        for i, keyword in enumerate(keywords):
            param = params[i] if i < len(params) else f'arg{i+1}'
            parts.append(f"{keyword}: {param}")
        
        return ' '.join(parts)
    
    # =========================================================================
    # Messages
    # =========================================================================
    
    def _emit_message(self, msg: Dict[str, Any]) -> str:
        """Emit message send."""
        receiver = self._emit_expression(msg.get('receiver', {'kind': 'self'}))
        selector = msg.get('selector', '')
        args = msg.get('arguments', [])
        msg_type = msg.get('message_type', 'unary')
        
        # Handle parenthesization for message chains
        if self._needs_parens(msg.get('receiver', {})):
            receiver = f"({receiver})"
        
        if msg_type == 'unary':
            return f"{receiver} {selector}"
        elif msg_type == 'binary':
            arg = self._emit_expression(args[0]) if args else ''
            if self._needs_parens(args[0] if args else {}):
                arg = f"({arg})"
            return f"{receiver} {selector} {arg}"
        else:  # keyword
            # Split selector by colons: "at:put:" -> ["at", "put"]
            keywords = [k for k in selector.split(':') if k]
            parts = [receiver]
            for i, keyword in enumerate(keywords):
                if i < len(args):
                    arg = self._emit_expression(args[i])
                    parts.append(f"{keyword}: {arg}")
            return ' '.join(parts)
    
    def _emit_single_message(self, msg: Dict[str, Any]) -> str:
        """Emit a single message without receiver (for cascades)."""
        selector = msg.get('selector', '')
        args = msg.get('arguments', [])
        msg_type = msg.get('message_type', 'unary')
        
        if msg_type == 'unary':
            return selector
        elif msg_type == 'binary':
            arg = self._emit_expression(args[0]) if args else ''
            return f"{selector} {arg}"
        else:  # keyword
            keywords = [k for k in selector.split(':') if k]
            parts = []
            for i, keyword in enumerate(keywords):
                if i < len(args):
                    arg = self._emit_expression(args[i])
                    parts.append(f"{keyword}: {arg}")
            return ' '.join(parts)
    
    def _emit_cascade(self, cascade: Dict[str, Any]) -> str:
        """Emit cascaded messages."""
        receiver = self._emit_expression(cascade.get('receiver'))
        messages = cascade.get('messages', [])
        
        if not messages:
            return receiver
        
        # First message with receiver
        first_msg = messages[0].copy() if isinstance(messages[0], dict) else messages[0]
        first = self._emit_single_message(first_msg)
        parts = [f"{receiver} {first}"]
        
        # Cascaded messages (without receiver)
        for msg in messages[1:]:
            msg_dict = msg if isinstance(msg, dict) else msg
            msg_str = self._emit_single_message(msg_dict)
            parts.append(msg_str)
        
        return ';\n\t'.join(parts)
    
    def _needs_parens(self, node: Dict[str, Any]) -> bool:
        """Check if expression needs parentheses."""
        kind = node.get('kind', '')
        return kind in ('message', 'binary_op', 'conditional', 'cascade')
    
    # =========================================================================
    # Blocks
    # =========================================================================
    
    def _emit_block(self, block: Dict[str, Any]) -> str:
        """Emit block: [ :arg1 :arg2 | | temp | statements ]."""
        params = block.get('parameters', [])
        temps = block.get('temporaries', [])
        stmts = block.get('statements', [])
        
        parts = ['[']
        
        # Parameters
        if params:
            if isinstance(params[0], dict):
                param_names = [p.get('name', '') for p in params]
            else:
                param_names = params
            param_str = ' '.join(f":{p}" for p in param_names)
            parts.append(f" {param_str} |")
        
        # Temporaries
        if temps:
            if isinstance(temps[0], dict):
                temp_names = [t.get('name', '') for t in temps]
            else:
                temp_names = temps
            parts.append(f" | {' '.join(temp_names)} |")
        
        # Statements
        if len(stmts) == 0:
            parts.append(' ')
        elif len(stmts) == 1:
            # Single statement - inline
            stmt_code = self._emit_statement(stmts[0])
            parts.append(f" {stmt_code} ")
        else:
            # Multiple statements
            parts.append('\n')
            for stmt in stmts:
                parts.append(f"\t{self._emit_statement(stmt)}.\n")
        
        parts.append(']')
        return ''.join(parts)
    
    # =========================================================================
    # Control Structures
    # =========================================================================
    
    def _emit_conditional(self, cond: Dict[str, Any]) -> str:
        """Emit conditional: condition ifTrue: [...] ifFalse: [...]."""
        condition = self._emit_expression(cond.get('condition'))
        true_block = cond.get('true_block')
        false_block = cond.get('false_block')
        
        if true_block and false_block:
            true_code = self._emit_block(true_block)
            false_code = self._emit_block(false_block)
            return f"{condition} ifTrue: {true_code}\n\tifFalse: {false_code}"
        elif true_block:
            return f"{condition} ifTrue: {self._emit_block(true_block)}"
        elif false_block:
            return f"{condition} ifFalse: {self._emit_block(false_block)}"
        return condition
    
    def _emit_loop(self, loop: Dict[str, Any]) -> str:
        """Emit loop: [condition] whileTrue: [body] or n timesRepeat: [body]."""
        loop_type = loop.get('loop_type', 'whileTrue:')
        cond_or_count = loop.get('condition_or_count')
        body = loop.get('body')
        
        if loop_type == 'timesRepeat:':
            count = self._emit_expression(cond_or_count)
            return f"{count} timesRepeat: {self._emit_block(body)}"
        elif loop_type in ('to:do:', 'to:by:do:'):
            start = self._emit_expression(cond_or_count)
            end = self._emit_expression(loop.get('end_value'))
            body_code = self._emit_block(body)
            step = loop.get('step')
            if step:
                step_code = self._emit_expression(step)
                return f"{start} to: {end} by: {step_code} do: {body_code}"
            return f"{start} to: {end} do: {body_code}"
        else:
            # whileTrue: or whileFalse:
            cond_block = self._emit_block({'statements': [cond_or_count]})
            body_block = self._emit_block(body)
            return f"{cond_block} {loop_type} {body_block}"
    
    def _emit_iteration(self, iter_node: Dict[str, Any]) -> str:
        """Emit collection iteration: collection do: [:each | ...]."""
        collection = self._emit_expression(iter_node.get('collection'))
        iterator = iter_node.get('iterator', 'do:')
        block = iter_node.get('block')
        
        block_code = self._emit_block(block)
        
        if iterator == 'inject:into:':
            initial = self._emit_expression(iter_node.get('initial_value'))
            return f"{collection} inject: {initial} into: {block_code}"
        
        return f"{collection} {iterator} {block_code}"
    
    # =========================================================================
    # Expressions
    # =========================================================================
    
    def _emit_expression(self, expr: Dict[str, Any]) -> str:
        """Emit expression."""
        if expr is None:
            return 'nil'
        
        kind = expr.get('kind', '')
        
        if kind == 'literal':
            return self._emit_literal(expr)
        elif kind == 'variable':
            return expr.get('name', '')
        elif kind == 'self':
            return 'self'
        elif kind == 'super':
            return 'super'
        elif kind == 'symbol':
            return f"#{expr.get('value', '')}"
        elif kind == 'character':
            return f"${expr.get('value', '')}"
        elif kind == 'array_literal':
            return self._emit_array_literal(expr)
        elif kind == 'dict_literal':
            return self._emit_dict_literal(expr)
        elif kind == 'message':
            return self._emit_message(expr)
        elif kind == 'cascade':
            return self._emit_cascade(expr)
        elif kind in ('block', 'full_block'):
            return self._emit_block(expr)
        elif kind == 'assignment':
            return self._emit_assignment(expr)
        elif kind == 'return':
            return self._emit_return(expr)
        elif kind == 'conditional':
            return self._emit_conditional(expr)
        elif kind == 'loop':
            return self._emit_loop(expr)
        elif kind == 'iteration':
            return self._emit_iteration(expr)
        elif kind == 'super_send':
            return self._emit_super_send(expr)
        elif kind == 'collection_new':
            return self._emit_collection_new(expr)
        elif kind == 'collection_access':
            return self._emit_collection_access(expr)
        elif kind == 'block_value':
            return self._emit_block_value(expr)
        elif kind == 'binary_op':
            return self._emit_binary_op(expr)
        else:
            self._warnings.append(f"Unknown expression kind: {kind}")
            return f'"unsupported: {kind}"'
    
    def _emit_statement(self, stmt: Dict[str, Any]) -> str:
        """Emit statement (expression with potential period)."""
        return self._emit_expression(stmt)
    
    def _emit_literal(self, lit: Dict[str, Any]) -> str:
        """Emit literal value."""
        value = lit.get('value')
        lit_type = lit.get('literal_type', 'object')
        
        if lit_type == 'string':
            # Escape single quotes
            escaped = str(value).replace("'", "''")
            return f"'{escaped}'"
        elif lit_type == 'symbol':
            return f"#{value}"
        elif lit_type == 'character':
            return f"${value}"
        elif lit_type == 'array':
            elements = ' '.join(self._emit_literal_element(e) for e in value)
            return f"#({elements})"
        elif lit_type == 'integer':
            return str(value)
        elif lit_type == 'float':
            return str(value)
        elif value is True:
            return 'true'
        elif value is False:
            return 'false'
        elif value is None:
            return 'nil'
        return str(value)
    
    def _emit_literal_element(self, elem: Any) -> str:
        """Emit literal element for array literal."""
        if isinstance(elem, dict):
            kind = elem.get('kind', '')
            if kind == 'literal':
                return self._emit_literal(elem)
            elif kind == 'symbol':
                return f"#{elem.get('value', '')}"
            elif kind == 'array_literal':
                return self._emit_array_literal(elem)
            return self._emit_expression(elem)
        elif isinstance(elem, str):
            return f"'{elem}'"
        elif isinstance(elem, bool):
            return 'true' if elem else 'false'
        elif elem is None:
            return 'nil'
        return str(elem)
    
    def _emit_array_literal(self, arr: Dict[str, Any]) -> str:
        """Emit array literal: #(1 2 3) or {expr1. expr2}."""
        elements = arr.get('elements', [])
        is_dynamic = arr.get('is_dynamic', False)
        
        if is_dynamic or not self._all_simple_literals(elements):
            # Dynamic array: {expr1. expr2. expr3}
            expr_strs = [self._emit_expression(e) for e in elements]
            return '{' + '. '.join(expr_strs) + '}'
        else:
            # Literal array: #(1 2 3)
            lit_strs = [self._emit_literal_element(e) for e in elements]
            return f"#({' '.join(lit_strs)})"
    
    def _emit_dict_literal(self, dct: Dict[str, Any]) -> str:
        """Emit dictionary literal."""
        entries = dct.get('entries', [])
        
        if not entries:
            return 'Dictionary new'
        
        # Build as cascaded at:put: messages
        parts = ['Dictionary new']
        for key, value in entries:
            key_code = self._emit_expression(key)
            val_code = self._emit_expression(value)
            parts.append(f"at: {key_code} put: {val_code}")
        
        return ';\n\t'.join(parts) + ';\n\tyourself'
    
    def _all_simple_literals(self, elements: List[Any]) -> bool:
        """Check if all elements are simple literals."""
        for elem in elements:
            if isinstance(elem, dict):
                kind = elem.get('kind', '')
                if kind not in ('literal', 'symbol', 'array_literal'):
                    return False
            elif not isinstance(elem, (int, float, str, bool, type(None))):
                return False
        return True
    
    def _emit_assignment(self, assign: Dict[str, Any]) -> str:
        """Emit assignment: target := value."""
        target = assign.get('target', '')
        value = self._emit_expression(assign.get('value'))
        return f"{target} := {value}"
    
    def _emit_return(self, ret: Dict[str, Any]) -> str:
        """Emit return: ^value."""
        value = ret.get('value')
        if value is None:
            return '^self'
        return f"^{self._emit_expression(value)}"
    
    def _emit_super_send(self, send: Dict[str, Any]) -> str:
        """Emit super message send."""
        msg = send.get('message', {})
        if isinstance(msg, dict):
            msg['receiver'] = {'kind': 'super'}
            return self._emit_message(msg)
        selector = send.get('selector', '')
        args = send.get('arguments', [])
        msg_type = send.get('message_type', 'unary')
        return self._emit_message({
            'receiver': {'kind': 'super'},
            'selector': selector,
            'arguments': args,
            'message_type': msg_type
        })
    
    def _emit_collection_new(self, coll: Dict[str, Any]) -> str:
        """Emit collection creation."""
        coll_type = coll.get('collection_type', 'Array')
        if isinstance(coll_type, str):
            type_name = coll_type
        else:
            type_name = coll_type.value if hasattr(coll_type, 'value') else str(coll_type)
        
        size = coll.get('initial_size')
        elements = coll.get('initial_elements', [])
        
        if elements:
            elem_strs = [self._emit_expression(e) for e in elements]
            return f"{type_name} with: {' with: '.join(elem_strs)}"
        elif size:
            return f"{type_name} new: {size}"
        return f"{type_name} new"
    
    def _emit_collection_access(self, access: Dict[str, Any]) -> str:
        """Emit collection access."""
        collection = self._emit_expression(access.get('collection'))
        operation = access.get('operation', 'at:')
        args = access.get('arguments', [])
        
        if not args:
            return f"{collection} {operation.rstrip(':')}"
        
        arg_strs = [self._emit_expression(a) for a in args]
        
        # Handle keyword message format
        keywords = [k for k in operation.split(':') if k]
        parts = [collection]
        for i, kw in enumerate(keywords):
            if i < len(arg_strs):
                parts.append(f"{kw}: {arg_strs[i]}")
        
        return ' '.join(parts)
    
    def _emit_block_value(self, bv: Dict[str, Any]) -> str:
        """Emit block evaluation."""
        block = self._emit_expression(bv.get('block'))
        args = bv.get('arguments', [])
        
        if not args:
            return f"{block} value"
        elif len(args) == 1:
            return f"{block} value: {self._emit_expression(args[0])}"
        else:
            arg_strs = [self._emit_expression(a) for a in args]
            return f"{block} valueWithArguments: #({' '.join(arg_strs)})"
    
    def _emit_binary_op(self, op: Dict[str, Any]) -> str:
        """Emit binary operation as message."""
        left = self._emit_expression(op.get('left'))
        right = self._emit_expression(op.get('right'))
        operator = op.get('operator', '+')
        return f"{left} {operator} {right}"
    
    # =========================================================================
    # Manifest Generation
    # =========================================================================
    
    def _generate_manifest(self, ir: Dict[str, Any], code: str) -> Dict[str, Any]:
        """Generate deterministic manifest."""
        code_hash = hashlib.sha256(code.encode('utf-8')).hexdigest()
        ir_hash = hashlib.sha256(
            json.dumps(ir, sort_keys=True, default=str).encode('utf-8')
        ).hexdigest()
        
        manifest = {
            'schema': 'stunir.manifest.targets.v1',
            'generator': 'stunir.smalltalk.emitter',
            'dialect': self.DIALECT,
            'ir_hash': ir_hash,
            'output': {
                'hash': code_hash,
                'size': len(code),
                'format': 'smalltalk',
                'extension': self.FILE_EXTENSION,
            },
        }
        
        return manifest
    
    # =========================================================================
    # Indentation Helpers
    # =========================================================================
    
    def _indent_str(self) -> str:
        """Get current indentation string."""
        return '\t' * self._indent
