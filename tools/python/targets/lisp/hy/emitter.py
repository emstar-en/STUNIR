#!/usr/bin/env python3
"""STUNIR Hy (Python Lisp) Emitter.

Generates Hy code from STUNIR IR.
Hy is a Lisp dialect that compiles to Python.

Part of Phase 5B: Extended Lisp Implementation.
"""

import time
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional, Set

from ..base import LispEmitterBase, LispEmitterConfig, EmitterResult, compute_sha256, canonical_json
from .types import HyTypeMapper, HY_TYPES


@dataclass
class HyConfig(LispEmitterConfig):
    """Hy specific configuration."""
    emit_type_annotations: bool = True    # Python type hints
    emit_docstrings: bool = True          # Python docstrings
    python_version: str = "3.10"          # Target Python version
    use_threading_macros: bool = True     # Use -> and ->>


class HyEmitter(LispEmitterBase):
    """Emitter for Hy (Python Lisp) code.
    
    Generates valid Hy code with:
    - Full Python interop
    - Hy macro definitions
    - Python type hints via annotations
    - Python classes
    """
    
    DIALECT = "hy"
    FILE_EXTENSION = ".hy"
    
    # Hy specific operators (map to Python operators)
    BINARY_OPS = {
        '+': '+',
        '-': '-',
        '*': '*',
        '/': '/',
        '%': '%',
        '//': '//',
        '**': '**',
        '==': '=',
        '!=': '!=',
        '<': '<',
        '>': '>',
        '<=': '<=',
        '>=': '>=',
        'and': 'and',
        'or': 'or',
        '&': '&',
        '|': '|',
        '^': '^',
        '<<': '<<',
        '>>': '>>',
        '@': '@',  # Matrix multiplication
    }
    
    def __init__(self, config: HyConfig):
        """Initialize Hy emitter.
        
        Args:
            config: Hy emitter configuration.
        """
        super().__init__(config)
        self.config: HyConfig = config
        self.type_mapper = HyTypeMapper(config.emit_type_annotations)
    
    def emit(self, ir: Dict[str, Any]) -> EmitterResult:
        """Emit Hy code from IR.
        
        Args:
            ir: STUNIR IR dictionary.
            
        Returns:
            EmitterResult with generated code.
        """
        module_name = self._lisp_name(ir.get('module', 'unnamed'))
        
        # Build code sections
        sections = []
        
        # Header
        sections.append(self._emit_header(module_name))
        
        # Imports
        for imp in ir.get('imports', []):
            sections.append(self._emit_import(imp))
        
        # Type definitions (Python classes)
        for type_def in ir.get('types', []):
            sections.append(self._emit_class(type_def))
        
        # Functions
        for func in ir.get('functions', []):
            sections.append(self._emit_function(func))
        
        code = "\n\n".join(filter(None, sections))
        
        # Write main file
        main_file = f"{module_name.replace('-', '_')}.hy"
        self._write_file(main_file, code)
        
        return EmitterResult(
            code=code,
            files={main_file: code},
            manifest=self._generate_manifest(ir)
        )
    
    def _emit_header(self, module_name: str) -> str:
        """Emit file header comment."""
        lines = [
            f";;; Generated by STUNIR Hy Emitter",
            f";;; Module: {module_name}",
            f";;; Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}",
        ]
        return "\n".join(lines)
    
    def _emit_import(self, imp: Dict[str, Any]) -> str:
        """Emit an import statement."""
        module = imp.get('module', imp.get('name', ''))
        names = imp.get('names', [])
        
        if names:
            # from X import Y, Z
            name_str = ' '.join(names)
            return f"(import [{module} [{name_str}]])"
        return f"(import {module})"
    
    def _emit_class(self, type_def: Dict[str, Any]) -> str:
        """Emit a Python class definition."""
        name = type_def.get('name', 'Unnamed')
        # Keep PascalCase for class names
        if '_' in name:
            # Convert snake_case to PascalCase
            name = ''.join(word.capitalize() for word in name.split('_'))
        
        fields = type_def.get('fields', [])
        docstring = type_def.get('docstring', type_def.get('doc', ''))
        
        lines = [f"(defclass {name} []"]
        
        if docstring:
            lines.append(f'  "{docstring}"')
        
        # Generate __init__ method
        if fields:
            # Build parameter list with type annotations
            init_params = ["self"]
            for field in fields:
                fname = self._lisp_name(field.get('name', 'field'))
                ftype = field.get('type', 'any')
                if self.config.emit_type_annotations:
                    init_params.append(f"^{self.type_mapper.map_type(ftype)} {fname}")
                else:
                    init_params.append(fname)
            
            param_str = ' '.join(init_params)
            lines.append(f"  (defn __init__ [{param_str}]")
            lines.append(f'    "Initialize {name}."')
            
            for field in fields:
                fname = self._lisp_name(field.get('name', 'field'))
                lines.append(f"    (setv self.{fname} {fname})")
            
            lines.append(")")
        
        lines.append(")")
        
        return "\n".join(lines)
    
    def _emit_function(self, func: Dict[str, Any]) -> str:
        """Emit a function definition."""
        name = self._lisp_name(func.get('name', 'unnamed'))
        params = func.get('params', [])
        body = func.get('body', [])
        docstring = func.get('docstring', func.get('doc', ''))
        return_type = func.get('return_type', '')
        is_async = func.get('async', False)
        
        # Build parameter list with type annotations
        param_parts = []
        for p in params:
            pname = self._lisp_name(p.get('name', '_'))
            ptype = p.get('type', '')
            if self.config.emit_type_annotations and ptype:
                param_parts.append(f"^{self.type_mapper.map_type(ptype)} {pname}")
            else:
                param_parts.append(pname)
        
        param_str = ' '.join(param_parts)
        
        # Function definition keyword
        defn_keyword = "defn/a" if is_async else "defn"
        
        # Build function
        lines = [f"({defn_keyword} {name}"]
        
        # Docstring
        if docstring:
            lines.append(f'  "{docstring}"')
        
        # Parameters with optional return type annotation
        if self.config.emit_type_annotations and return_type:
            ret_type = self.type_mapper.map_type(return_type)
            lines.append(f"  [{param_str}] -> {ret_type}")
        else:
            lines.append(f"  [{param_str}]")
        
        # Body
        if body:
            for stmt in body:
                stmt_str = self._emit_statement(stmt)
                lines.append(f"  {stmt_str}")
        else:
            lines.append("  None")
        
        lines.append(")")
        
        return "\n".join(lines)
    
    def _emit_var_decl(self, stmt: Dict[str, Any]) -> str:
        """Emit variable declaration using setv."""
        name = self._lisp_name(stmt.get('name', '_'))
        value = stmt.get('value', stmt.get('init'))
        
        if value is not None:
            val_str = self._emit_expression(value)
            return f"(setv {name} {val_str})"
        return f"(setv {name} None)"
    
    def _emit_assignment(self, stmt: Dict[str, Any]) -> str:
        """Emit assignment statement using setv."""
        name = self._lisp_name(stmt.get('name', stmt.get('target', '_')))
        value = self._emit_expression(stmt.get('value', {}))
        return f"(setv {name} {value})"
    
    def _emit_if_stmt(self, stmt: Dict[str, Any]) -> str:
        """Emit if statement."""
        cond = self._emit_expression(stmt.get('condition', stmt.get('cond', {})))
        then_body = stmt.get('then', stmt.get('consequent', []))
        else_body = stmt.get('else', stmt.get('alternate', []))
        
        # Handle body as list or single statement
        if isinstance(then_body, list):
            if len(then_body) == 1:
                then_str = self._emit_statement(then_body[0])
            elif then_body:
                then_stmts = ' '.join(self._emit_statement(s) for s in then_body)
                then_str = f"(do {then_stmts})"
            else:
                then_str = 'None'
        else:
            then_str = self._emit_statement(then_body)
        
        if else_body:
            if isinstance(else_body, list):
                if len(else_body) == 1:
                    else_str = self._emit_statement(else_body[0])
                else:
                    else_stmts = ' '.join(self._emit_statement(s) for s in else_body)
                    else_str = f"(do {else_stmts})"
            else:
                else_str = self._emit_statement(else_body)
            return f"(if {cond}\n    {then_str}\n    {else_str})"
        
        # Use when for single-branch
        return f"(when {cond}\n    {then_str})"
    
    def _emit_while(self, stmt: Dict[str, Any]) -> str:
        """Emit while loop."""
        cond = self._emit_expression(stmt.get('condition', stmt.get('cond', {})))
        body = stmt.get('body', [])
        
        body_strs = [self._emit_statement(s) for s in body] if body else ['None']
        body_str = '\n    '.join(body_strs)
        
        return f"(while {cond}\n    {body_str})"
    
    def _emit_for(self, stmt: Dict[str, Any]) -> str:
        """Emit for loop."""
        var = self._lisp_name(stmt.get('var', 'i'))
        body = stmt.get('body', [])
        
        # Check if iterating over a collection or a range
        if 'iterable' in stmt:
            iterable = self._emit_expression(stmt['iterable'])
            body_strs = [self._emit_statement(s) for s in body] if body else ['None']
            body_str = '\n    '.join(body_strs)
            return f"(for [{var} {iterable}]\n    {body_str})"
        else:
            # Range-based loop
            start = self._emit_expression(stmt.get('start', {'kind': 'literal', 'value': 0}))
            end = self._emit_expression(stmt.get('end', {'kind': 'literal', 'value': 10}))
            body_strs = [self._emit_statement(s) for s in body] if body else ['None']
            body_str = '\n    '.join(body_strs)
            return f"(for [{var} (range {start} {end})]\n    {body_str})"
    
    def _emit_literal(self, value: Any) -> str:
        """Emit a Hy literal (Python-style)."""
        if value is None:
            return "None"
        if isinstance(value, bool):
            return "True" if value else "False"
        if isinstance(value, str):
            escaped = value.replace('\\', '\\\\').replace('"', '\\"')
            return f'"{escaped}"'
        return str(value)
    
    def _emit_lambda(self, data: Dict[str, Any]) -> str:
        """Emit a lambda expression with Hy syntax."""
        params = data.get('params', [])
        param_names = ' '.join(self._lisp_name(p.get('name', '_')) for p in params)
        body = data.get('body', [])
        body_str = ' '.join(self._emit_statement(stmt) for stmt in body) if body else 'None'
        return f"(fn [{param_names}] {body_str})"
    
    def _lisp_name(self, name: str) -> str:
        """Convert name to Hy naming convention.
        
        Hy uses kebab-case but allows underscores for Python interop.
        """
        # Keep underscores for Python compatibility but convert camelCase
        result = []
        for i, char in enumerate(name):
            if char.isupper() and i > 0 and name[i-1].islower():
                result.append('-')
                result.append(char.lower())
            else:
                result.append(char.lower())
        return ''.join(result)
    
    def _map_type(self, ir_type: str) -> str:
        """Map IR type to Hy/Python type."""
        return self.type_mapper.map_type(ir_type)
