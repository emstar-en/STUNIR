"""Base emitter class for expert systems.

This module provides the base class for expert system emitters
(CLIPS, Jess, etc.).
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional
import hashlib
import json

from ir.rules import RuleBase, Rule, Fact, FactTemplate, FunctionDef
from ir.rules import Condition, PatternCondition, TestCondition, CompositeCondition
from ir.rules import Action, AssertAction, RetractAction, ModifyAction, BindAction, CallAction, PrintoutAction
from ir.rules import EmitterResult
from ir.rules.pattern import AnyPatternElement, LiteralPattern, VariablePattern, WildcardPattern, MultifieldPattern


def canonical_json(obj: Any) -> str:
    """Generate canonical JSON string.
    
    Args:
        obj: Object to serialize
        
    Returns:
        Canonical JSON string with sorted keys
    """
    return json.dumps(obj, sort_keys=True, separators=(',', ':'))


def compute_sha256(data: bytes) -> str:
    """Compute SHA256 hash of data.
    
    Args:
        data: Bytes to hash
        
    Returns:
        Hex-encoded SHA256 hash
    """
    return hashlib.sha256(data).hexdigest()


class BaseExpertSystemEmitter(ABC):
    """Abstract base class for expert system emitters.
    
    Provides common functionality for emitting expert system
    languages like CLIPS and Jess.
    """
    
    DIALECT: str = "base"
    VERSION: str = "1.0"
    
    # Type mapping IR -> target language
    TYPE_MAP: Dict[str, str] = {
        "i32": "INTEGER",
        "i64": "INTEGER",
        "f32": "FLOAT",
        "f64": "FLOAT",
        "bool": "SYMBOL",
        "string": "STRING",
        "symbol": "SYMBOL",
        "any": "?VARIABLE"
    }
    
    def __init__(self, pretty_print: bool = True):
        """Initialize the emitter.
        
        Args:
            pretty_print: Whether to format output with indentation
        """
        self.pretty_print = pretty_print
        self._indent = 0
        self._output: List[str] = []
        self._warnings: List[str] = []
    
    @abstractmethod
    def emit(self, rulebase: RuleBase) -> EmitterResult:
        """Emit code from a RuleBase.
        
        Args:
            rulebase: The knowledge base to emit
            
        Returns:
            EmitterResult with code and manifest
        """
        pass
    
    def _emit_header(self, rulebase: RuleBase) -> None:
        """Emit file header.
        
        Args:
            rulebase: The knowledge base
        """
        self._line(f";;;; {self.DIALECT.upper()} Expert System: {rulebase.name}")
        self._line(f";;;; Generated by STUNIR {self.DIALECT} Emitter")
        self._line("")
    
    @abstractmethod
    def _emit_template(self, template: FactTemplate) -> None:
        """Emit a fact template definition."""
        pass
    
    @abstractmethod
    def _emit_function(self, func: FunctionDef) -> None:
        """Emit a function definition."""
        pass
    
    @abstractmethod
    def _emit_rule(self, rule: Rule) -> None:
        """Emit a rule definition."""
        pass
    
    def _emit_initial_facts(self, facts: List[Fact], name: str) -> None:
        """Emit initial facts block.
        
        Args:
            facts: List of initial facts
            name: Name for the deffacts block
        """
        self._line(f"(deffacts {name}-initial-facts")
        self._indent += 3
        
        for fact in facts:
            self._emit_fact(fact)
        
        self._indent -= 3
        self._line(")")
        self._line("")
    
    def _emit_fact(self, fact: Fact) -> None:
        """Emit a single fact.
        
        Args:
            fact: The fact to emit
        """
        if fact.is_ordered():
            values = " ".join(self._format_value(v) for v in fact.values)
            self._line(f"({values})")
        else:
            slots = " ".join(
                f"({k} {self._format_value(v)})"
                for k, v in fact.slots.items()
            )
            self._line(f"({fact.template_name} {slots})")
    
    def _emit_condition(self, condition: Condition) -> None:
        """Emit a rule condition.
        
        Args:
            condition: The condition to emit
        """
        if isinstance(condition, PatternCondition):
            self._emit_pattern_condition(condition)
        elif isinstance(condition, TestCondition):
            self._line(f"(test {condition.expression})")
        elif isinstance(condition, CompositeCondition):
            self._emit_composite_condition(condition)
    
    def _emit_pattern_condition(self, condition: PatternCondition) -> None:
        """Emit a pattern condition.
        
        Args:
            condition: The pattern condition
        """
        binding = f"?{condition.binding_name} <- " if condition.binding_name else ""
        
        if condition.template_name:
            # Template pattern
            patterns = " ".join(
                f"({slot} {self._format_pattern(pat)})"
                for slot, pat in condition.patterns
            )
            self._line(f"{binding}({condition.template_name} {patterns})")
        else:
            # Ordered pattern
            patterns = " ".join(
                self._format_pattern(pat)
                for pat in condition.ordered_patterns
            )
            self._line(f"{binding}({patterns})")
    
    def _emit_composite_condition(self, condition: CompositeCondition) -> None:
        """Emit a composite condition (AND/OR/NOT).
        
        Args:
            condition: The composite condition
        """
        op_name = condition.condition_type.name.lower()
        self._line(f"({op_name}")
        self._indent += 3
        for child in condition.children:
            self._emit_condition(child)
        self._indent -= 3
        self._line(")")
    
    def _emit_action(self, action: Action) -> None:
        """Emit a rule action.
        
        Args:
            action: The action to emit
        """
        if isinstance(action, AssertAction):
            if action.fact_template:
                slots = " ".join(
                    f"({k} {self._format_value(v)})"
                    for k, v in action.slot_values.items()
                )
                self._line(f"(assert ({action.fact_template} {slots}))")
            else:
                values = " ".join(self._format_value(v) for v in action.ordered_values)
                self._line(f"(assert ({values}))")
        
        elif isinstance(action, RetractAction):
            self._line(f"(retract ?{action.fact_reference})")
        
        elif isinstance(action, ModifyAction):
            mods = " ".join(
                f"({k} {self._format_value(v)})"
                for k, v in action.modifications.items()
            )
            self._line(f"(modify ?{action.fact_reference} {mods})")
        
        elif isinstance(action, BindAction):
            self._line(f"(bind ?{action.variable} {action.expression})")
        
        elif isinstance(action, CallAction):
            args = " ".join(self._format_value(a) for a in action.arguments)
            self._line(f"({action.function_name} {args})")
        
        elif isinstance(action, PrintoutAction):
            items = " ".join(self._format_value(i) for i in action.items)
            self._line(f"(printout {action.router} {items})")
    
    def _format_pattern(self, pattern: AnyPatternElement) -> str:
        """Format a pattern element.
        
        Args:
            pattern: The pattern element
            
        Returns:
            Formatted pattern string
        """
        if isinstance(pattern, LiteralPattern):
            # Literal patterns in ordered facts are typically symbols
            return self._format_value(pattern.value, as_symbol=True)
        elif isinstance(pattern, VariablePattern):
            if pattern.constraint:
                return f"?{pattern.name}&:{pattern.constraint}"
            return f"?{pattern.name}"
        elif isinstance(pattern, WildcardPattern):
            return "?"
        elif isinstance(pattern, MultifieldPattern):
            if pattern.name:
                return f"$?{pattern.name}"
            return "$?"
        return "?"
    
    def _format_value(self, value: Any, as_symbol: bool = False) -> str:
        """Format a value for output.
        
        Args:
            value: The value to format
            as_symbol: If True, treat strings as symbols (no quotes)
            
        Returns:
            Formatted value string
        """
        if value is None:
            return "nil"
        elif isinstance(value, bool):
            return "TRUE" if value else "FALSE"
        elif isinstance(value, str):
            if value.startswith("?"):
                return value  # Variable reference
            elif value in ("crlf", "t", "nil", "TRUE", "FALSE"):
                return value  # Keywords
            elif as_symbol:
                return value  # Emit as symbol without quotes
            return f'"{value}"'
        elif isinstance(value, (int, float)):
            return str(value)
        elif isinstance(value, list):
            return " ".join(self._format_value(v) for v in value)
        return str(value)
    
    def _map_type(self, ir_type: str) -> str:
        """Map an IR type to target language type.
        
        Args:
            ir_type: IR type name
            
        Returns:
            Target language type
        """
        return self.TYPE_MAP.get(ir_type, "?VARIABLE")
    
    def _line(self, text: str) -> None:
        """Add a line with proper indentation.
        
        Args:
            text: Text to add
        """
        if self.pretty_print:
            indent = " " * self._indent
            self._output.append(f"{indent}{text}")
        else:
            self._output.append(text)
    
    def _generate_manifest(self, rulebase: RuleBase, code: str) -> Dict[str, Any]:
        """Generate manifest for emitted code.
        
        Args:
            rulebase: The knowledge base
            code: The generated code
            
        Returns:
            Manifest dict
        """
        code_hash = compute_sha256(code.encode('utf-8'))
        
        manifest = {
            "schema": "stunir.manifest.expert_systems.v1",
            "generator": f"stunir.{self.DIALECT}.emitter",
            "dialect": self.DIALECT,
            "version": self.VERSION,
            "rulebase": rulebase.name,
            "statistics": {
                "rules": len(rulebase.rules),
                "templates": len(rulebase.templates),
                "initial_facts": len(rulebase.initial_facts),
                "functions": len(rulebase.functions)
            },
            "output": {
                "hash": code_hash,
                "size": len(code),
                "lines": len(self._output)
            },
            "warnings": self._warnings
        }
        
        manifest["manifest_hash"] = compute_sha256(
            canonical_json({k: v for k, v in manifest.items() if k != "manifest_hash"}).encode()
        )
        
        return manifest
