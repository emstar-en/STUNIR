"module spark_arith;

// Type definitions for arithmetic expressions
type ArithmeticOp {
    | Add
    | Mul
}

type Number {
    value: Integer;
}

// IR node for binary operations
ir BinaryExpr {
    op: ArithmeticOp;
    child left: Expr;
    child right: Expr;
    -- SPARK-specific annotation (if supported)
    pragma Inline;
}

type Expr {
    | Num(Number)
    | Bin(BinaryExpr)
}

// Evaluator function (SPARK-compliant)
function Evaluate(expr: Expr) return Integer is
begin
    case expr is
        when Num(n) => return n.value;
        when Bin(b) =>
            declare
                l, r : Integer;
            begin
                l := Evaluate(b.left);
                r := Evaluate(b.right);
                case b.op is
                    when Add => return l + r;
                    when Mul => return l * r;
                end case;
            end;
    end case;
end Evaluate;

// SPARK target definition
target Spark {
    extension: \".adb\";

    -- Emit a Number node (SPARK-compliant)
    emit Number(n: Number) is
    begin
        pragma Annotate(GNATproof, False);
        Emit(\"  \" & Integer'Image(n.value));
    end;

    -- Emit a BinaryExpr with SPARK syntax
    emit BinaryExpr(b: BinaryExpr) is
    begin
        Emit(\"(\");
        Emit(b.left);
        case b.op is
            when Add => Emit(\" + \");
            when Mul => Emit(\" * \");
        end case;
        Emit(b.right);
        Emit(\")\");
    end;

    -- Main function template (SPARK-compliant)
    emit Function(func: Function) is
    begin
        Emit(\"function \" & func.name & \" return Integer is\" & ASCII.LF);
        Emit(\"begin\" & ASCII.LF);

        if func.body.Statements'Length > 0 then
            for S of func.body.Statements loop
                Emit(\"  \" & S.Text & ASCII.LF);
            end loop;
        end if;

        Emit(\"end \" & func.name & \";\");
    end;
}

// Test case: Compute (2 + 3) * 4
function Main return Integer is
begin
    declare
        expr : constant Expr := Bin({
            op: Mul,
            left: Bin({ -- Sub-expression: 2 + 3
                op: Add,
                left: Num({value: 2}),
                right: Num({value: 3})
            }),
            right: Num({value: 4})
        });
    begin
        return Evaluate(expr); -- Expected result: (2 + 3) * 4 = 20
    end;
end Main;"