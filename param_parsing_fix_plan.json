{
  "issue": "Parameter names are being appended as arg0/arg1 because pointer-prefixed or complex names (e.g., *str, (*cb)(int), array declarators) fail the current regex, causing the extractor to treat the full parameter as type and synthesize a name.",
  "objectives": [
    "Split parameter type and name reliably for C/C++ pointer, reference, and array declarations",
    "Preserve correct typing while eliminating arg0/arg1 artifacts when a name is present",
    "Handle complex declarators including function pointers, arrays, and qualifiers",
    "Retain safe fallbacks for ambiguous parameters",
    "Keep parsing deterministic and traceable via warnings"
  ],
  "scope": [
    "extract_bc_functions.py",
    "test_extraction_logic.py (new verification script)",
    "stunir_execution_workspace/gnu_bc/batch_01/extraction.json",
    "stunir_execution_workspace/gnu_bc/batch_01/generated.cpp"
  ],
  "root_cause": [
    "The existing regex only captures names that begin with [A-Za-z_], missing names attached to '*' or '&'.",
    "When the regex fails, the entire parameter string becomes the type and a synthetic argN name is used.",
    "The parsing logic does not follow C/C++ declarator rules where the identifier is the rightmost primary token."
  ],
  "approach": [
    "Replace simple regex matching with a right-to-left declarator parse:",
    "1) Normalize whitespace and remove surrounding parentheses where safe.",
    "2) Detect and preserve varargs '...'.",
    "3) Extract and preserve trailing array declarators (e.g., [10], [], [3][3]) to append to the type.",
    "4) Detect function pointer declarators by locating a name inside '(*)' or '(&)' patterns.",
    "5) Otherwise find the rightmost valid identifier using a boundary-aware regex.",
    "6) Split the parameter at the identifier; left side is type, right side is name.",
    "7) Normalize type spacing (collapse spaces, standardize pointer/reference adjacency).",
    "8) Fallback: if no identifier found, keep full string as type and use argN."
  ],
  "parsing_rules": {
    "identifier_regex": "(?<![\\w])([A-Za-z_][A-Za-z0-9_]*)$",
    "function_pointer_regex": "\\((\\*|&)\\s*([A-Za-z_][A-Za-z0-9_]*)\\s*\\)",
    "array_suffix_regex": "(\\s*\\[[^\\]]*\\])+\\s*$",
    "varargs": "...",
    "type_normalization": [
      "Collapse multiple spaces to single spaces",
      "Remove spaces before ']' and after '['",
      "Normalize '*', '&' adjacency as 'type *' and 'type &' while preserving original multiplicity"
    ]
  },
  "edge_cases": [
    {
      "case": "Pointer with space",
      "example": "const char *str",
      "expected": {"type": "const char *", "name": "str"}
    },
    {
      "case": "Pointer without space",
      "example": "char*str",
      "expected": {"type": "char*", "name": "str"}
    },
    {
      "case": "Reference",
      "example": "int &ref",
      "expected": {"type": "int &", "name": "ref"}
    },
    {
      "case": "Double pointer",
      "example": "char **argv",
      "expected": {"type": "char **", "name": "argv"}
    },
    {
      "case": "Const pointer to const",
      "example": "const char * const p",
      "expected": {"type": "const char * const", "name": "p"}
    },
    {
      "case": "Struct pointer",
      "example": "struct my_struct *ptr",
      "expected": {"type": "struct my_struct *", "name": "ptr"}
    },
    {
      "case": "Array parameter",
      "example": "int vals[10]",
      "expected": {"type": "int [10]", "name": "vals"}
    },
    {
      "case": "Array of pointers",
      "example": "char *argv[]",
      "expected": {"type": "char * []", "name": "argv"}
    },
    {
      "case": "Multi-dimensional array",
      "example": "int matrix[3][3]",
      "expected": {"type": "int [3][3]", "name": "matrix"}
    },
    {
      "case": "Function pointer",
      "example": "int (*cb)(int)",
      "expected": {"type": "int (*)(int)", "name": "cb"}
    },
    {
      "case": "Function pointer with qualifiers",
      "example": "void (* const handler)(int)",
      "expected": {"type": "void (* const)(int)", "name": "handler"}
    },
    {
      "case": "Pointer to array",
      "example": "int (*arr)[10]",
      "expected": {"type": "int (* )[10]", "name": "arr"}
    },
    {
      "case": "Unnamed parameter",
      "example": "int",
      "expected": {"type": "int", "name": "argN"}
    },
    {
      "case": "Void types",
      "example": "void",
      "expected": {"type": "void", "name": "argN"}
    },
    {
      "case": "Variable arguments",
      "example": "...",
      "expected": {"type": "...", "name": "args"}
    },
    {
      "case": "Typedef name",
      "example": "size_t n",
      "expected": {"type": "size_t", "name": "n"}
    },
    {
      "case": "Pointer with macro-like identifier",
      "example": "MYTYPE *x",
      "expected": {"type": "MYTYPE *", "name": "x"}
    }
  ],
  "implementation_steps": [
    "Create test_extraction_logic.py to unit test parsing behavior on all edge cases before modifying the main script.",
    "Add a helper function parse_param_decl(param_str, index) that returns {type, name}.",
    "In parse_param_decl:",
    "  - Trim input; return {...} for varargs '...' with name 'args'.",
    "  - Extract array suffixes via array_suffix_regex and store in array_suffix.",
    "  - If function_pointer_regex matches, capture name from group 2, remove the name from the declarator, and keep the rest as type.",
    "  - Otherwise, find the rightmost identifier using identifier_regex on the trimmed string (after removing array suffix).",
    "  - If found, split by last occurrence index to type and name.",
    "  - Normalize type and append array_suffix to type.",
    "  - If no identifier found, set type to full string (plus array_suffix) and name to argN.",
    "Integrate parse_param_decl into extract_c_functions and replace existing param_match logic.",
    "Add warnings when falling back to argN due to parse failure."
  ],
  "verification_steps": [
    "Run test_extraction_logic.py and ensure 100% pass rate on edge cases.",
    "Run extract_bc_functions.py on the GNU bc source files (batch_01).",
    "Inspect extraction.json to ensure each parameter object has a clean 'type' and the correct 'name'.",
    "Run the full STUNIR pipeline (spec_assemble -> spec_to_ir -> ir_to_code).",
    "Confirm generated.cpp has no argN suffixes when a name exists and compiles syntactically."
  ],
  "risk_assessment": [
    {
      "risk": "Incorrect parsing of macro-heavy or preprocessor-expanded declarations",
      "mitigation": "If identifier resolution is ambiguous, fall back to treating the string as type and use argN to avoid data loss."
    },
    {
      "risk": "Regressing simple cases",
      "mitigation": "Unit tests include basic int/char cases and ensure prior behavior is preserved."
    },
    {
      "risk": "Function pointer parsing misses nested parentheses",
      "mitigation": "Keep conservative parsing and fall back cleanly; do not attempt to fully parse C declarators."
    }
  ],
  "acceptance_criteria": [
    "Parameters like 'const char *str' become type='const char *' and name='str'.",
    "No argN suffixes appear when a valid name exists in the source declaration.",
    "Unnamed parameters still receive argN as a fallback.",
    "Function pointers and arrays retain syntactically valid types and correct names.",
    "Generated C/C++ signatures are syntactically valid for the tested samples."
  ]
}
