"""CHR (Constraint Handling Rules) emitter.

This module emits constraint models to CHR format for Prolog.
"""

from typing import List, Set, Tuple

from .base import BaseConstraintEmitter, compute_sha256
from ir.constraints import (
    ConstraintModel, Variable, ArrayVariable, Domain, Parameter,
    Constraint, RelationalConstraint, LogicalConstraint, GlobalConstraint,
    Objective, SearchAnnotation, ConstraintEmitterResult,
    Expression, VariableRef, Literal,
    ConstraintType, ObjectiveType, VariableType, DomainType
)


class CHREmitter(BaseConstraintEmitter):
    """CHR (Constraint Handling Rules) emitter.
    
    Emits constraint models to CHR format for Prolog.
    CHR is a rule-based language for constraint propagation.
    """
    
    DIALECT = "chr"
    VERSION = "1.0"
    FILE_EXTENSION = ".pl"
    
    # Constraint type to CHR constraint name
    CONSTRAINT_NAMES = {
        ConstraintType.EQ: "eq",
        ConstraintType.NE: "neq",
        ConstraintType.LT: "lt",
        ConstraintType.LE: "leq",
        ConstraintType.GT: "gt",
        ConstraintType.GE: "geq",
        ConstraintType.ALLDIFFERENT: "alldifferent",
    }
    
    def emit(self, model: ConstraintModel) -> ConstraintEmitterResult:
        """Emit CHR/Prolog model.
        
        Args:
            model: Constraint model to emit
            
        Returns:
            ConstraintEmitterResult with CHR code
        """
        self._output = []
        self._warnings = []
        self._constraint_signatures: Set[str] = set()
        
        # Validate model
        errors = model.validate()
        for error in errors:
            self._warn(f"Validation error: {error}")
        
        # Collect constraint signatures
        self._collect_constraint_signatures(model)
        
        # Emit sections
        self._emit_header(model)
        self._emit_module_declaration(model)
        self._emit_chr_constraints()
        self._emit_domain_rules(model)
        self._emit_chr_rules(model)
        self._emit_constraint_rules(model)
        self._emit_utility_predicates(model)
        self._emit_query(model)
        
        code = self._get_code()
        manifest = self._generate_manifest(model, code)
        return ConstraintEmitterResult(code, manifest, self._warnings)
    
    def _emit_header(self, model: ConstraintModel) -> None:
        """Emit file header."""
        self._line(f"%% Model: {model.name}")
        self._line("%% Generated by STUNIR CHR Emitter")
        self._line("%%")
        self._line("%% Usage: ?- solve.")
        self._line()
    
    def _emit_module_declaration(self, model: ConstraintModel) -> None:
        """Emit module and use_module declarations."""
        self._line(":- use_module(library(chr)).")
        self._line(":- use_module(library(lists)).")
        self._line()
    
    def _collect_constraint_signatures(self, model: ConstraintModel) -> None:
        """Collect all constraint signatures needed."""
        # Always include domain constraint
        self._constraint_signatures.add("domain/2")
        
        for constraint in model.constraints:
            if isinstance(constraint, RelationalConstraint):
                name = self.CONSTRAINT_NAMES.get(constraint.constraint_type, "constraint")
                self._constraint_signatures.add(f"{name}/2")
            elif isinstance(constraint, GlobalConstraint):
                if constraint.constraint_type == ConstraintType.ALLDIFFERENT:
                    self._constraint_signatures.add("alldifferent/1")
                    self._constraint_signatures.add("exclude/2")
    
    def _emit_chr_constraints(self) -> None:
        """Emit CHR constraint declarations."""
        if self._constraint_signatures:
            sigs = ", ".join(sorted(self._constraint_signatures))
            self._line(f":- chr_constraint {sigs}.")
            self._line()
    
    def _emit_domain_rules(self, model: ConstraintModel) -> None:
        """Emit domain-related CHR rules."""
        self._line("%% Domain rules")
        self._line()
        
        # Domain initialization
        self._line("%% Domain unification")
        self._line("domain(X, D), domain(X, D) <=> domain(X, D).")
        self._line()
        
        # Domain narrowing
        self._line("%% Domain intersection")
        self._line("domain(X, D1) \\ domain(X, D2) <=> ")
        self._indent_inc()
        self._line("intersection(D1, D2, D3), D3 \\= [] |")
        self._line("domain(X, D3).")
        self._indent_dec()
        self._line()
    
    def _emit_chr_rules(self, model: ConstraintModel) -> None:
        """Emit main CHR rules."""
        self._line("%% Constraint propagation rules")
        self._line()
        
        # Equality propagation
        self._line("%% Equality: X = V reduces domain")
        self._line("eq(X, V), domain(X, D) <=> member(V, D) | X = V.")
        self._line()
        
        # Inequality propagation
        self._line("%% Inequality: X != V removes V from domain")
        self._line("neq(X, V), domain(X, D) <=> ")
        self._indent_inc()
        self._line("delete(D, V, D1), D1 \\= [] |")
        self._line("domain(X, D1).")
        self._indent_dec()
        self._line()
        
        # Less than propagation
        self._line("%% Less than")
        self._line("lt(X, Y), domain(X, DX), domain(Y, DY) <=>")
        self._indent_inc()
        self._line("max_list(DX, MaxX), min_list(DY, MinY), MaxX < MinY |")
        self._line("domain(X, DX), domain(Y, DY).")
        self._indent_dec()
        self._line()
    
    def _emit_constraint_rules(self, model: ConstraintModel) -> None:
        """Emit rules for specific constraints."""
        has_alldiff = any(
            isinstance(c, GlobalConstraint) and c.constraint_type == ConstraintType.ALLDIFFERENT
            for c in model.constraints
        )
        
        if has_alldiff:
            self._emit_alldifferent_rules()
    
    def _emit_alldifferent_rules(self) -> None:
        """Emit alldifferent constraint rules."""
        self._line("%% Alldifferent constraint")
        self._line("alldifferent([]) <=> true.")
        self._line("alldifferent([_]) <=> true.")
        self._line("alldifferent([X|Xs]) <=> ")
        self._indent_inc()
        self._line("exclude(X, Xs), alldifferent(Xs).")
        self._indent_dec()
        self._line()
        
        self._line("%% Exclude a value from a list of variables")
        self._line("exclude(_, []) <=> true.")
        self._line("exclude(X, [Y|Ys]) <=>")
        self._indent_inc()
        self._line("neq(X, Y), exclude(X, Ys).")
        self._indent_dec()
        self._line()
    
    def _emit_utility_predicates(self, model: ConstraintModel) -> None:
        """Emit utility predicates."""
        self._line("%% Utility predicates")
        self._line()
        
        # Generate domain helper
        self._line("%% Create domain from range")
        self._line("make_domain(X, Lower, Upper) :-")
        self._indent_inc()
        self._line("numlist(Lower, Upper, Dom),")
        self._line("domain(X, Dom).")
        self._indent_dec()
        self._line()
    
    def _emit_query(self, model: ConstraintModel) -> None:
        """Emit the main solve predicate."""
        self._line("%% Main solve predicate")
        self._line("solve :-")
        self._indent_inc()
        
        # Emit variable initializations
        for var in model.variables:
            domain = var.domain
            if domain.domain_type == DomainType.RANGE:
                self._line(f"make_domain({var.name}, {domain.lower}, {domain.upper}),")
            elif domain.domain_type == DomainType.SET:
                vals = list(sorted(domain.values))
                self._line(f"domain({var.name}, {vals}),")
            elif domain.domain_type == DomainType.BOOL:
                self._line(f"domain({var.name}, [0, 1]),")
        
        # Emit array initializations
        for arr in model.arrays:
            domain = arr.element_domain
            for i in range(1, arr.size + 1):
                var_name = f"{arr.name}_{i}"
                if domain.domain_type == DomainType.RANGE:
                    self._line(f"make_domain({var_name}, {domain.lower}, {domain.upper}),")
        
        # Emit constraints
        for constraint in model.constraints:
            self._emit_constraint(constraint)
        
        # Emit labeling
        self._line("% Labeling")
        var_names = [var.name for var in model.variables]
        if var_names:
            self._line(f"label([{', '.join(var_names)}]).")
        else:
            self._line("true.")
        
        self._indent_dec()
        self._line()
        
        # Labeling predicate
        self._line("%% Labeling")
        self._line("label([]).")
        self._line("label([X|Xs]) :-")
        self._indent_inc()
        self._line("domain(X, D),")
        self._line("member(V, D),")
        self._line("X = V,")
        self._line("label(Xs).")
        self._indent_dec()
    
    def _emit_variable(self, var: Variable) -> None:
        """Emit a variable (handled in solve predicate)."""
        pass
    
    def _emit_constraint(self, constraint: Constraint) -> None:
        """Emit a single constraint."""
        if isinstance(constraint, RelationalConstraint):
            self._emit_relational_constraint(constraint)
        elif isinstance(constraint, GlobalConstraint):
            self._emit_global_constraint(constraint)
        elif isinstance(constraint, LogicalConstraint):
            self._emit_logical_constraint(constraint)
    
    def _emit_relational_constraint(self, constraint: RelationalConstraint) -> None:
        """Emit a relational constraint."""
        name = self.CONSTRAINT_NAMES.get(constraint.constraint_type, "eq")
        left = self._format_prolog_expr(constraint.left)
        right = self._format_prolog_expr(constraint.right)
        self._line(f"{name}({left}, {right}),")
    
    def _emit_global_constraint(self, constraint: GlobalConstraint) -> None:
        """Emit a global constraint."""
        if constraint.constraint_type == ConstraintType.ALLDIFFERENT:
            args = [self._format_prolog_expr(a) for a in constraint.args]
            self._line(f"alldifferent([{', '.join(args)}]),")
        else:
            self._warn(f"Unsupported global constraint: {constraint.constraint_type}")
    
    def _emit_logical_constraint(self, constraint: LogicalConstraint) -> None:
        """Emit a logical constraint."""
        self._warn("Logical constraints have limited CHR support")
    
    def _emit_objective(self, objective: Objective) -> None:
        """Emit objective (limited in CHR)."""
        if objective.objective_type != ObjectiveType.SATISFY:
            self._warn("Optimization objectives not supported in basic CHR")
    
    def _format_prolog_expr(self, expr: Expression) -> str:
        """Format an expression for Prolog."""
        if isinstance(expr, VariableRef):
            # Prolog variables start with uppercase
            name = expr.name
            return name[0].upper() + name[1:] if name else name
        elif isinstance(expr, Literal):
            if isinstance(expr.value, bool):
                return '1' if expr.value else '0'
            return str(expr.value)
        else:
            return self._format_expression(expr)


def emit_simplification_rule(name: str, head: str, guard: str, body: str) -> str:
    """Create a CHR simplification rule string.
    
    Simplification rules have the form: H <=> G | B.
    They replace the head constraint with the body.
    
    Args:
        name: Rule name (for documentation)
        head: Head constraint(s)
        guard: Guard condition (can be empty)
        body: Body constraint(s)
        
    Returns:
        CHR rule string
    """
    if guard:
        return f"{head} <=> {guard} | {body}."
    return f"{head} <=> {body}."


def emit_propagation_rule(name: str, head: str, guard: str, body: str) -> str:
    """Create a CHR propagation rule string.
    
    Propagation rules have the form: H ==> G | B.
    They keep the head and add the body.
    
    Args:
        name: Rule name (for documentation)
        head: Head constraint(s)
        guard: Guard condition (can be empty)
        body: Body constraint(s)
        
    Returns:
        CHR rule string
    """
    if guard:
        return f"{head} ==> {guard} | {body}."
    return f"{head} ==> {body}."


def emit_simpagation_rule(kept: str, removed: str, guard: str, body: str) -> str:
    """Create a CHR simpagation rule string.
    
    Simpagation rules have the form: K \\ R <=> G | B.
    They keep K, remove R, and add B.
    
    Args:
        kept: Constraints to keep
        removed: Constraints to remove
        guard: Guard condition (can be empty)
        body: Body constraint(s)
        
    Returns:
        CHR rule string
    """
    if guard:
        return f"{kept} \\ {removed} <=> {guard} | {body}."
    return f"{kept} \\ {removed} <=> {body}."
