#!/usr/bin/env python3
"""Yacc/Bison grammar emitter.

Emits grammars in Yacc/Bison format:
- %token declarations for terminals
- %start declaration for start symbol
- %% section separator
- Productions with semantic actions
"""

from typing import Dict, List, Optional, Any, Set

from ir.grammar.grammar_ir import Grammar, EmitterResult
from ir.grammar.production import ProductionRule, BodyElement
from ir.grammar.production import OptionalOp, Repetition, OneOrMore, Group, Alternation
from ir.grammar.symbol import Symbol
from targets.grammar.base import GrammarEmitterBase


class YaccEmitter(GrammarEmitterBase):
    """Emitter for Yacc/Bison grammar format.
    
    Yacc format:
        %{
        #include <stdio.h>
        %}
        
        %token NUM PLUS MINUS
        %start expr
        
        %%
        
        expr : term
             | expr PLUS term  { $$ = $1 + $3; }
             | expr MINUS term { $$ = $1 - $3; }
             ;
        
        %%
    
    Config options:
        include_prolog (bool): Include C prolog section (default: True)
        include_epilog (bool): Include C epilog section (default: True)
        generate_actions (bool): Generate placeholder semantic actions (default: False)
    """
    
    FORMAT = "yacc"
    FILE_EXTENSION = ".y"
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__(config)
        self.include_prolog = self.config.get('include_prolog', True)
        self.include_epilog = self.config.get('include_epilog', True)
        self.generate_actions = self.config.get('generate_actions', False)
    
    def emit(self, grammar: Grammar) -> EmitterResult:
        """Emit grammar in Yacc/Bison format.
        
        Args:
            grammar: The grammar to emit
        
        Returns:
            EmitterResult with Yacc code and manifest
        """
        self._warnings = []
        lines = []
        
        # Prolog (C declarations)
        if self.include_prolog:
            lines.append("%{")
            lines.append(f"/* Grammar: {grammar.name} */")
            lines.append(f"/* Generated by STUNIR Grammar Emitter */")
            lines.append("")
            lines.append("#include <stdio.h>")
            lines.append("#include <stdlib.h>")
            lines.append("")
            lines.append("extern int yylex(void);")
            lines.append("extern void yyerror(const char *s);")
            lines.append("%}")
            lines.append("")
        
        # Token declarations
        tokens = sorted(grammar.terminals, key=lambda s: s.name)
        if tokens:
            token_names = [self._to_yacc_token(t.name) for t in tokens]
            lines.append("%token " + " ".join(token_names))
            lines.append("")
        
        # Start symbol
        start_name = self._to_yacc_rule(grammar.start_symbol.name)
        lines.append(f"%start {start_name}")
        lines.append("")
        
        # Section separator
        lines.append("%%")
        lines.append("")
        
        # Grammar rules
        for nt in sorted(grammar.nonterminals, key=lambda s: s.name):
            prods = grammar.get_productions(nt)
            if not prods:
                continue
            
            rule_name = self._to_yacc_rule(nt.name)
            lines.append(f"{rule_name}")
            
            for i, prod in enumerate(prods):
                body = self._emit_body(prod)
                prefix = "    :" if i == 0 else "    |"
                
                if self.generate_actions and prod.action:
                    lines.append(f"{prefix} {body}  {{ {prod.action} }}")
                elif self.generate_actions:
                    lines.append(f"{prefix} {body}  {{ /* action */ }}")
                else:
                    lines.append(f"{prefix} {body}")
            
            lines.append("    ;")
            lines.append("")
        
        # Section separator
        lines.append("%%")
        lines.append("")
        
        # Epilog (C code)
        if self.include_epilog:
            lines.append("/* Epilog - user code */")
            lines.append("")
            lines.append("void yyerror(const char *s) {")
            lines.append('    fprintf(stderr, "Error: %s\\n", s);')
            lines.append("}")
            lines.append("")
            lines.append("int main(void) {")
            lines.append("    return yyparse();")
            lines.append("}")
        
        code = "\n".join(lines)
        manifest = self._generate_manifest(grammar, code)
        
        return EmitterResult(
            code=code,
            manifest=manifest,
            format=self.FORMAT,
            warnings=self._warnings
        )
    
    def emit_production(self, rule: ProductionRule) -> str:
        """Emit a single production rule in Yacc format.
        
        Args:
            rule: The production rule to emit
        
        Returns:
            Yacc production string
        """
        rule_name = self._to_yacc_rule(rule.head.name)
        body = self._emit_body(rule)
        return f"{rule_name} : {body} ;"
    
    def _emit_body(self, rule: ProductionRule) -> str:
        """Emit the body of a production rule."""
        if rule.is_epsilon_production():
            return "/* empty */"
        
        parts = []
        for elem in rule.body:
            parts.append(self._emit_yacc_element(elem))
        
        return " ".join(parts)
    
    def _emit_yacc_element(self, element: BodyElement) -> str:
        """Emit a body element in Yacc notation."""
        if isinstance(element, Symbol):
            if element.is_nonterminal():
                return self._to_yacc_rule(element.name)
            elif element.is_terminal():
                return self._to_yacc_token(element.name)
            elif element.is_epsilon():
                return "/* empty */"
            else:
                return str(element)
        elif isinstance(element, (OptionalOp, Repetition, OneOrMore, Group, Alternation)):
            # Yacc doesn't support EBNF - warn and emit best effort
            self._add_warning(f"EBNF operator not supported in Yacc: {type(element).__name__}")
            return self._emit_element(element)
        else:
            return str(element)
    
    def _to_yacc_rule(self, name: str) -> str:
        """Convert to valid Yacc rule name."""
        # Yacc rules are typically lowercase with underscores
        clean = name.replace('-', '_').replace('.', '_')
        return clean.lower()
    
    def _to_yacc_token(self, name: str) -> str:
        """Convert to valid Yacc token name."""
        # Tokens are typically UPPERCASE
        clean = name.replace('-', '_').replace('.', '_')
        # Handle special characters
        if len(clean) == 1 and not clean.isalnum():
            # Single character token like '+', '-', etc.
            return f"'{clean}'"
        if clean[0].isdigit():
            clean = 'T_' + clean
        return clean.upper()
    
    def _get_comment_char(self) -> str:
        return "/*"
