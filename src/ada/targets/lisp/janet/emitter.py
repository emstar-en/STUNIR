#!/usr/bin/env python3
"""STUNIR Janet Emitter.

Generates Janet code from STUNIR IR.
Janet is a modern, embeddable Lisp for scripting and system programming.

Part of Phase 5B: Extended Lisp Implementation.
"""

import time
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional, Set

from ..base import LispEmitterBase, LispEmitterConfig, EmitterResult, compute_sha256, canonical_json
from .types import JanetTypeMapper, JANET_TYPES


@dataclass
class JanetConfig(LispEmitterConfig):
    """Janet specific configuration."""
    emit_structs: bool = True       # Use struct for types
    emit_peg: bool = False          # Generate PEG patterns
    emit_fiber: bool = False        # Use fiber patterns
    use_shortfn: bool = True        # Use | short fn syntax


class JanetEmitter(LispEmitterBase):
    """Emitter for Janet code.
    
    Generates valid Janet code with:
    - Modern Lisp syntax
    - Struct and table definitions
    - PEG patterns (optional)
    - Fiber-based concurrency (optional)
    """
    
    DIALECT = "janet"
    FILE_EXTENSION = ".janet"
    
    # Janet specific operators
    BINARY_OPS = {
        '+': '+',
        '-': '-',
        '*': '*',
        '/': '/',
        '%': 'mod',
        '==': '=',
        '!=': 'not=',
        '<': '<',
        '>': '>',
        '<=': '<=',
        '>=': '>=',
        'and': 'and',
        'or': 'or',
        '&': 'band',
        '|': 'bor',
        '^': 'bxor',
        '<<': 'blshift',
        '>>': 'brshift',
    }
    
    def __init__(self, config: JanetConfig):
        """Initialize Janet emitter.
        
        Args:
            config: Janet emitter configuration.
        """
        super().__init__(config)
        self.config: JanetConfig = config
        self.type_mapper = JanetTypeMapper()
    
    def emit(self, ir: Dict[str, Any]) -> EmitterResult:
        """Emit Janet code from IR.
        
        Args:
            ir: STUNIR IR dictionary.
            
        Returns:
            EmitterResult with generated code.
        """
        module_name = self._lisp_name(ir.get('module', 'unnamed'))
        
        # Build code sections
        sections = []
        
        # Header (Janet uses # for comments)
        sections.append(self._emit_header(module_name))
        
        # Imports
        for imp in ir.get('imports', []):
            sections.append(self._emit_import(imp))
        
        # Type definitions (structs)
        if self.config.emit_structs:
            for type_def in ir.get('types', []):
                sections.append(self._emit_struct(type_def))
        
        # Functions
        for func in ir.get('functions', []):
            sections.append(self._emit_function(func))
        
        code = "\n\n".join(filter(None, sections))
        
        # Write main file
        main_file = f"{module_name}.janet"
        self._write_file(main_file, code)
        
        return EmitterResult(
            code=code,
            files={main_file: code},
            manifest=self._generate_manifest(ir)
        )
    
    def _emit_header(self, module_name: str) -> str:
        """Emit file header comment (Janet uses #)."""
        lines = [
            f"# Generated by STUNIR Janet Emitter",
            f"# Module: {module_name}",
            f"# Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}",
        ]
        return "\n".join(lines)
    
    def _emit_import(self, imp: Dict[str, Any]) -> str:
        """Emit an import statement."""
        name = imp.get('module', imp.get('name', ''))
        return f"(import {self._lisp_name(name)})"
    
    def _emit_struct(self, type_def: Dict[str, Any]) -> str:
        """Emit a struct definition."""
        name = self._lisp_name(type_def.get('name', 'unnamed'))
        fields = type_def.get('fields', [])
        
        # Janet doesn't have built-in struct definitions,
        # but we can create a constructor function
        field_names = [self._lisp_name(f.get('name', 'field')) for f in fields]
        field_keywords = ' '.join(f":{fn} {fn}" for fn in field_names)
        params = ' '.join(field_names)
        
        return f"""# Struct: {name}
(defn {name} [{params}]
  @{{{field_keywords}}})"""
    
    def _emit_function(self, func: Dict[str, Any]) -> str:
        """Emit a function definition."""
        name = self._lisp_name(func.get('name', 'unnamed'))
        params = func.get('params', [])
        body = func.get('body', [])
        docstring = func.get('docstring', func.get('doc', ''))
        
        # Parameter list with brackets []
        param_names = ' '.join(self._lisp_name(p.get('name', '_')) for p in params)
        
        # Build function
        lines = [f"(defn {name}"]
        
        # Docstring
        if docstring:
            lines.append(f'  "{docstring}"')
        
        # Parameters in brackets
        lines.append(f"  [{param_names}]")
        
        # Body
        if body:
            for stmt in body:
                stmt_str = self._emit_statement(stmt)
                lines.append(f"  {stmt_str}")
        else:
            lines.append("  nil")
        
        lines.append(")")
        
        return "\n".join(lines)
    
    def _emit_var_decl(self, stmt: Dict[str, Any]) -> str:
        """Emit variable declaration using def or var."""
        name = self._lisp_name(stmt.get('name', '_'))
        value = stmt.get('value', stmt.get('init'))
        mutable = stmt.get('mutable', False)
        
        keyword = 'var' if mutable else 'def'
        
        if value is not None:
            val_str = self._emit_expression(value)
            return f"({keyword} {name} {val_str})"
        return f"({keyword} {name} nil)"
    
    def _emit_assignment(self, stmt: Dict[str, Any]) -> str:
        """Emit assignment statement using set."""
        name = self._lisp_name(stmt.get('name', stmt.get('target', '_')))
        value = self._emit_expression(stmt.get('value', {}))
        return f"(set {name} {value})"
    
    def _emit_if_stmt(self, stmt: Dict[str, Any]) -> str:
        """Emit if statement."""
        cond = self._emit_expression(stmt.get('condition', stmt.get('cond', {})))
        then_body = stmt.get('then', stmt.get('consequent', []))
        else_body = stmt.get('else', stmt.get('alternate', []))
        
        # Handle body as list or single statement
        if isinstance(then_body, list):
            if len(then_body) == 1:
                then_str = self._emit_statement(then_body[0])
            elif then_body:
                then_stmts = ' '.join(self._emit_statement(s) for s in then_body)
                then_str = f"(do {then_stmts})"
            else:
                then_str = 'nil'
        else:
            then_str = self._emit_statement(then_body)
        
        if else_body:
            if isinstance(else_body, list):
                if len(else_body) == 1:
                    else_str = self._emit_statement(else_body[0])
                else:
                    else_stmts = ' '.join(self._emit_statement(s) for s in else_body)
                    else_str = f"(do {else_stmts})"
            else:
                else_str = self._emit_statement(else_body)
            return f"(if {cond}\n    {then_str}\n    {else_str})"
        
        # Use when for single-branch
        return f"(when {cond}\n    {then_str})"
    
    def _emit_while(self, stmt: Dict[str, Any]) -> str:
        """Emit while loop."""
        cond = self._emit_expression(stmt.get('condition', stmt.get('cond', {})))
        body = stmt.get('body', [])
        
        body_strs = [self._emit_statement(s) for s in body] if body else ['nil']
        body_str = '\n    '.join(body_strs)
        
        return f"(while {cond}\n    {body_str})"
    
    def _emit_for(self, stmt: Dict[str, Any]) -> str:
        """Emit for loop using loop or each."""
        var = self._lisp_name(stmt.get('var', 'i'))
        body = stmt.get('body', [])
        
        # Check if iterating over a collection or a range
        if 'iterable' in stmt:
            iterable = self._emit_expression(stmt['iterable'])
            body_strs = [self._emit_statement(s) for s in body] if body else ['nil']
            body_str = '\n    '.join(body_strs)
            return f"(each {var} {iterable}\n    {body_str})"
        else:
            # Range-based loop with for
            start = self._emit_expression(stmt.get('start', {'kind': 'literal', 'value': 0}))
            end = self._emit_expression(stmt.get('end', {'kind': 'literal', 'value': 10}))
            body_strs = [self._emit_statement(s) for s in body] if body else ['nil']
            body_str = '\n    '.join(body_strs)
            return f"(for {var} {start} {end}\n    {body_str})"
    
    def _emit_literal(self, value: Any) -> str:
        """Emit a Janet literal."""
        if value is None:
            return "nil"
        if isinstance(value, bool):
            return "true" if value else "false"
        if isinstance(value, str):
            escaped = value.replace('\\', '\\\\').replace('"', '\\"')
            return f'"{escaped}"'
        return str(value)
    
    def _emit_lambda(self, data: Dict[str, Any]) -> str:
        """Emit a lambda expression with Janet syntax."""
        params = data.get('params', [])
        param_names = ' '.join(self._lisp_name(p.get('name', '_')) for p in params)
        body = data.get('body', [])
        body_str = ' '.join(self._emit_statement(stmt) for stmt in body) if body else 'nil'
        return f"(fn [{param_names}] {body_str})"
    
    def _map_type(self, ir_type: str) -> str:
        """Map IR type to Janet type."""
        return self.type_mapper.map_type(ir_type)
