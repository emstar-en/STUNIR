/* STUNIR Generated Code
 * Generated by: stunir_ir_to_code_spark v0.7.1
 * Module: ap_math_crc
 */

#include <stdint.h>
#include <stdbool.h>

uint16_t crc_crc4(u16[] data) {
  uint8_t n_rem = 0;
  uint8_t cnt = 0;
  while (cnt < 16) {
    if (cnt & 1) {
      n_rem = n_rem ^ (data[cnt >> 1] & 0x00FF);
      n_rem = n_rem ^ (data[cnt >> 1] >> 8);
    } else {
      n_rem = n_rem ^ (data[cnt >> 1] >> 8);
    }
    n_bit = 8;
    while (n_bit > 0) {
      if (n_rem & 0x8000) {
        n_rem = (n_rem << 1) ^ 0x3000;
        n_rem = n_rem << 1;
      } else {
        n_rem = n_rem << 1;
      }
      n_bit = n_bit - 1;
    }
    cnt = cnt + 1;
  }
  return (n_rem >> 12) & 0xF;

}

uint8_t crc_crc8(u8[] p, uint8_t len) {
  int32_t crc = 0x0;
  while (len > 0) {
    i = (crc ^ *p) & 0xFF;
    crc = (crc8_table[i] ^ (crc << 8)) & 0xFF;
    p = p + 1;
    len = len - 1;
  }
  return crc & 0xFF;

}

uint8_t crc8_dvb_s2(uint8_t crc, uint8_t a) {
  return crc8_dvb(crc, a, 0xD5);

}

uint8_t crc8_dvb(uint8_t crc, uint8_t a, uint8_t seed) {
  uint8_t i = 0;
  int32_t crc = crc ^ a;
  while (i < 8) {
    if (crc & 0x80) {
      crc = (crc << 1) ^ seed;
      crc = crc << 1;
    } else {
      crc = crc << 1;
    }
    i = i + 1;
  }
  return crc;

}

uint16_t crc16_ccitt(u8[] buf, uint32_t len, uint16_t crc) {
  uint8_t i = 0;
  while (i < len) {
    crc = (crc << 8) ^ crc16tab[((crc >> 8) ^ *buf) & 0x00FF];
    buf = buf + 1;
    i = i + 1;
  }
  return crc;

}

uint16_t crc_fletcher16(u8[] buffer, uint32_t len) {
  uint8_t c0 = 0;
  uint8_t c1 = 0;
  uint8_t i = 0;
  while (i < len) {
    c0 = (c0 + buffer[i]) % 255;
    c1 = (c1 + c0) % 255;
    i = i + 1;
  }
  return (c1 << 8) | c0;

}

void crc8_table(void) {
    /* TODO: Implement */
    return;
}

void crc16tab(void) {
    /* TODO: Implement */
    return;
}

float vector2_length_squared(float x, float y) {
  return x*x + y*y;

}

float vector2_length(float x, float y) {
  return sqrt(x*x + y*y);

}

bool vector2_limit_length(float x, float y, float max_length) {
  int32_t len = vector2_length(x, y);
  if (len > max_length && len > 0) {
    x = x * (max_length / len);
    y = y * (max_length / len);
  return true;
  }
  return false;

}

float vector2_dot_product(float x1, float y1, float x2, float y2) {
  return x1*x2 + y1*y2;

}

float vector2_cross_product(float x1, float y1, float x2, float y2) {
  return x1*y2 - y1*x2;

}

float vector2_angle_between(float x1, float y1, float x2, float y2) {
  int32_t len = vector2_length(x1, y1) * vector2_length(x2, y2);
  if (len <= 0) {
  return 0.0;
  }
  int32_t cosv = vector2_dot_product(x1, y1, x2, y2) / len;
  if (cosv >= 1.0) {
  return 0.0;
  }
  if (cosv <= -1.0) {
  return 3.14159265;
  }
  return acos(cosv);

}

void vector2_normalize(float x, float y) {
  int32_t len = vector2_length(x, y);
  if (len > 0) {
    x = x / len;
    y = y / len;
  }
  return;
}

bool vector2_segment_intersection(float seg1_start_x, float seg1_start_y, float seg1_end_x, float seg1_end_y, float seg2_start_x, float seg2_start_y, float seg2_end_x, float seg2_end_y) {
  int32_t r1_x = seg1_end_x - seg1_start_x;
  int32_t r1_y = seg1_end_y - seg1_start_y;
  int32_t r2_x = seg2_end_x - seg2_start_x;
  int32_t r2_y = seg2_end_y - seg2_start_y;
  int32_t r1xr2 = r1_x * r2_y - r1_y * r2_x;
  if (r1xr2 == 0) {
  return false;
  }
  int32_t ss2_ss1_x = seg2_start_x - seg1_start_x;
  int32_t ss2_ss1_y = seg2_start_y - seg1_start_y;
  int32_t t = (ss2_ss1_x * r2_y - ss2_ss1_y * r2_x) / r1xr2;
  int32_t u = (ss2_ss1_x * r1_y - ss2_ss1_y * r1_x) / r1xr2;
  if (u >= 0 && u <= 1 && t >= 0 && t <= 1) {
    out_x = seg1_start_x + r1_x * t;
    out_y = seg1_start_y + r1_y * t;
  return true;
  }
  return false;

}

